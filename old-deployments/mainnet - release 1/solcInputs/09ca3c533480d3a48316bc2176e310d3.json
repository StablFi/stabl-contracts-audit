{
  "language": "Solidity",
  "sources": {
    "contracts/Box.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Box {\r\n    string private greeting;\r\n    \r\n    function greet() public view returns (string memory) {\r\n        return greeting;\r\n    }\r\n\r\n    function setGreeting(string memory _greeting) public {\r\n        console.log(\"Changing greeting from '%s' to '%s'\", greeting, _greeting);\r\n        greeting = _greeting;\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/vault/VaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Vault Admin Contract\r\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\r\n * @author Stabl Protocol Inc\r\n */\r\n\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { IOracle } from \"../interfaces/IOracle.sol\";\r\nimport { IHarvester } from \"../interfaces/IHarvester.sol\";\r\nimport { IDripper } from \"../interfaces/IDripper.sol\";\r\nimport \"./VaultStorage.sol\";\r\nimport \"../utils/Sort.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract VaultAdmin is VaultStorage {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\r\n     */\r\n    modifier onlyVaultOrGovernorOrStrategist() {\r\n        require(\r\n            msg.sender == address(this) ||\r\n                msg.sender == strategistAddr ||\r\n                isGovernor(),\r\n            \"Caller is not the Vault, Governor, or Strategist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernorOrStrategist() {\r\n        require(\r\n            msg.sender == strategistAddr || isGovernor(),\r\n            \"Caller is not the Strategist or Governor\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n                 Configuration\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Set address of price provider.\r\n     * @param _priceProvider Address of price provider\r\n     */\r\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\r\n        priceProvider = _priceProvider;\r\n        emit PriceProviderUpdated(_priceProvider);\r\n    }\r\n \r\n    /**\r\n     * @dev Set a fee in basis points to be charged for a redeem.\r\n     * @param _redeemFeeBps Basis point fee to be charged\r\n     */\r\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\r\n        require(_redeemFeeBps <= 1000, \"Redeem fee should not be over 10%\");\r\n        redeemFeeBps = _redeemFeeBps;\r\n        emit RedeemFeeUpdated(_redeemFeeBps);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a buffer of assets to keep in the Vault to handle most\r\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\r\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\r\n     */\r\n    function setVaultBuffer(uint256 _vaultBuffer)\r\n        external\r\n        onlyGovernorOrStrategist\r\n    {\r\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\r\n        vaultBuffer = _vaultBuffer;\r\n        emit VaultBufferUpdated(_vaultBuffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the minimum amount of CASH in a mint to trigger an\r\n     * automatic allocation of funds afterwords.\r\n     * @param _threshold CASH amount with 18 fixed decimals.\r\n     */\r\n    function setAutoAllocateThreshold(uint256 _threshold)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        autoAllocateThreshold = _threshold;\r\n        emit AllocateThresholdUpdated(_threshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a minimum amount of CASH in a mint or redeem that triggers a\r\n     * rebase\r\n     * @param _threshold CASH amount with 18 fixed decimals.\r\n     */\r\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\r\n        rebaseThreshold = _threshold;\r\n        emit RebaseThresholdUpdated(_threshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Set address of Strategist\r\n     * @param _address Address of Strategist\r\n     */\r\n    function setStrategistAddr(address _address) external onlyGovernor {\r\n        strategistAddr = _address;\r\n        emit StrategistUpdated(_address);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the default Strategy for an asset, i.e. the one which the asset\r\n            will be automatically allocated to and withdrawn from\r\n     * @param _asset Address of the asset\r\n     * @param _strategy Address of the Strategy\r\n     */\r\n    function setAssetDefaultStrategy(address _asset, address _strategy)\r\n        external\r\n        onlyGovernorOrStrategist\r\n    {\r\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\r\n        // If its a zero address being passed for the strategy we are removing\r\n        // the default strategy\r\n        if (_strategy != address(0)) {\r\n            // Make sure the strategy meets some criteria\r\n            require(strategies[_strategy].isSupported, \"Strategy not approved\");\r\n            IStrategy strategy = IStrategy(_strategy);\r\n            require(assets[_asset].isSupported, \"Asset is not supported\");\r\n            require(\r\n                strategy.supportsAsset(_asset),\r\n                \"Asset not supported by Strategy\"\r\n            );\r\n        }\r\n        assetDefaultStrategies[_asset] = _strategy;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a supported asset to the contract, i.e. one that can be\r\n     *         to mint CASH.\r\n     * @param _asset Address of asset\r\n     */\r\n    function supportAsset(address _asset) external onlyGovernor {\r\n        require(!assets[_asset].isSupported, \"Asset already supported\");\r\n\r\n        assets[_asset] = Asset({ isSupported: true });\r\n        allAssets.push(_asset);\r\n\r\n        // Verify that our oracle supports the asset\r\n        // slither-disable-next-line unused-return\r\n        console.log(\"priceProvider\",priceProvider);\r\n        IOracle(priceProvider).price(_asset);\r\n\r\n        emit AssetSupported(_asset);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a strategy to the Vault.\r\n     * @param _addr Address of the strategy to add\r\n     */\r\n    function approveStrategy(address _addr) external onlyGovernor {\r\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\r\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\r\n        allStrategies.push(_addr);\r\n        emit StrategyApproved(_addr);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a strategy from the Vault.\r\n     * @param _addr Address of the strategy to remove\r\n     */\r\n\r\n    function removeStrategy(address _addr) external onlyGovernor {\r\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\r\n\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            require(\r\n                assetDefaultStrategies[allAssets[i]] != _addr,\r\n                \"Strategy is default for an asset\"\r\n            );\r\n        }\r\n\r\n        // Initialize strategyIndex with out of bounds result so function will\r\n        // revert if no valid index found\r\n        uint256 strategyIndex = allStrategies.length;\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            if (allStrategies[i] == _addr) {\r\n                strategyIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (strategyIndex < allStrategies.length) {\r\n            allStrategies[strategyIndex] = allStrategies[\r\n                allStrategies.length - 1\r\n            ];\r\n            allStrategies.pop();\r\n\r\n            // Mark the strategy as not supported\r\n            strategies[_addr].isSupported = false;\r\n\r\n            // Withdraw all assets\r\n            IStrategy strategy = IStrategy(_addr);\r\n            strategy.withdrawAll();\r\n\r\n            emit StrategyRemoved(_addr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Move assets from one Strategy to another\r\n     * @param _strategyFromAddress Address of Strategy to move assets from.\r\n     * @param _strategyToAddress Address of Strategy to move assets to.\r\n     * @param _assets Array of asset address that will be moved\r\n     * @param _amounts Array of amounts of each corresponding asset to move.\r\n     */\r\n    function reallocate(\r\n        address _strategyFromAddress,\r\n        address _strategyToAddress,\r\n        address[] calldata _assets,\r\n        uint256[] calldata _amounts\r\n    ) external onlyGovernorOrStrategist {\r\n        require(\r\n            strategies[_strategyFromAddress].isSupported,\r\n            \"Invalid from Strategy\"\r\n        );\r\n        require(\r\n            strategies[_strategyToAddress].isSupported,\r\n            \"Invalid to Strategy\"\r\n        );\r\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\r\n\r\n        IStrategy strategyFrom = IStrategy(_strategyFromAddress);\r\n        IStrategy strategyTo = IStrategy(_strategyToAddress);\r\n\r\n        for (uint256 i = 0; i < _assets.length; i++) {\r\n            require(strategyTo.supportsAsset(_assets[i]), \"Asset unsupported\");\r\n            // Withdraw from Strategy and pass other Strategy as recipient\r\n            strategyFrom.withdraw(address(strategyTo), _assets[i], _amounts[i]);\r\n        }\r\n        // Tell new Strategy to deposit into protocol\r\n        strategyTo.depositAll();\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the maximum allowable difference between\r\n     * total supply and backing assets' value.\r\n     */\r\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\r\n        maxSupplyDiff = _maxSupplyDiff;\r\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the trusteeAddress that can receive a portion of yield.\r\n     *      Setting to the zero address disables this feature.\r\n     */\r\n    function setTrusteeAddress(address _address) external onlyGovernor {\r\n        trusteeAddress = _address;\r\n        emit TrusteeAddressChanged(_address);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the TrusteeFeeBps to the percentage of yield that should be\r\n     *      received in basis points.\r\n     */\r\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\r\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\r\n        trusteeFeeBps = _basis;\r\n        emit TrusteeFeeBpsChanged(_basis);\r\n    }\r\n\r\n    /***************************************\r\n                    Pause\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Set the deposit paused flag to true to prevent rebasing.\r\n     */\r\n    function pauseRebase() external onlyGovernorOrStrategist {\r\n        rebasePaused = true;\r\n        emit RebasePaused();\r\n    }\r\n\r\n    /**\r\n     * @dev Set the deposit paused flag to true to allow rebasing.\r\n     */\r\n    function unpauseRebase() external onlyGovernor {\r\n        rebasePaused = false;\r\n        emit RebaseUnpaused();\r\n    }\r\n\r\n    /**\r\n     * @dev Set the deposit paused flag to true to prevent capital movement.\r\n     */\r\n    function pauseCapital() external onlyGovernorOrStrategist {\r\n        capitalPaused = true;\r\n        emit CapitalPaused();\r\n    }\r\n\r\n    /**\r\n     * @dev Set the deposit paused flag to false to enable capital movement.\r\n     */\r\n    function unpauseCapital() external onlyGovernorOrStrategist {\r\n        capitalPaused = false;\r\n        emit CapitalUnpaused();\r\n    }\r\n\r\n    /***************************************\r\n                    Utils\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\r\n     *      contract, i.e. mistaken sends.\r\n     * @param _asset Address for the asset\r\n     * @param _amount Amount of the asset to transfer\r\n     */\r\n    function transferToken(address _asset, uint256 _amount)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\r\n        IERC20(_asset).safeTransfer(governor(), _amount);\r\n    }\r\n\r\n    /***************************************\r\n                    Pricing\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Returns the total price in 18 digit USD for a given asset.\r\n     *      Never goes above 1, since that is how we price mints\r\n     * @param asset address of the asset\r\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\r\n     */\r\n    function priceUSDMint(address asset) external view returns (uint256) {\r\n        uint256 price = IOracle(priceProvider).price(asset);\r\n        require(price >= MINT_MINIMUM_ORACLE, \"Asset price below peg\");\r\n        if (price > 1e8) {\r\n            price = 1e8;\r\n        }\r\n        // Price from Oracle is returned with 8 decimals so scale to 18\r\n        return price.scaleBy(18, 8);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total price in 18 digit USD for a given asset.\r\n     *      Never goes below 1, since that is how we price redeems\r\n     * @param asset Address of the asset\r\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\r\n     */\r\n    function priceUSDRedeem(address asset) external view returns (uint256) {\r\n        uint256 price = IOracle(priceProvider).price(asset);\r\n        if (price < 1e8) {\r\n            price = 1e8;\r\n        }\r\n        // Price from Oracle is returned with 8 decimals so scale to 18\r\n        return price.scaleBy(18, 8);\r\n    }\r\n\r\n    /***************************************\r\n             Strategies Admin\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Withdraws all assets from the strategy and sends assets to the Vault.\r\n     * @param _strategyAddr Strategy address.\r\n     */\r\n    function withdrawAllFromStrategy(address _strategyAddr)\r\n        external\r\n        onlyGovernorOrStrategist\r\n    {\r\n        require(\r\n            strategies[_strategyAddr].isSupported,\r\n            \"Strategy is not supported\"\r\n        );\r\n        IStrategy strategy = IStrategy(_strategyAddr);\r\n        strategy.withdrawAll();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws all assets from all the strategies and sends assets to the Vault.\r\n     */\r\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            strategy.withdrawAll();\r\n        }\r\n    }\r\n\r\n    /*************************************\r\n              Startegies Weights\r\n    *************************************/\r\n    \r\n    function sortWeightsByTarget(StrategyWithWeight[] memory weights) internal pure returns(StrategyWithWeight[] memory) {\r\n        uint[] memory targets = new uint[](weights.length);\r\n        for(uint i = 0; i < weights.length; i++) {\r\n            targets[i] = weights[i].targetWeight;\r\n        }\r\n        uint[] memory indices = new uint[](targets.length);\r\n        for (uint z = 0; z < indices.length; z++) {\r\n            indices[z] = z;\r\n        }\r\n        Sort.quickSort(targets, 0, int(targets.length-1), indices);\r\n        StrategyWithWeight[] memory sorted = new StrategyWithWeight[](targets.length);\r\n        for (uint z = 0; z < indices.length; z++) {\r\n            sorted[z] = weights[indices[z]];\r\n        }\r\n        return sorted;\r\n    }\r\n\r\n    function setStrategyWithWeights(StrategyWithWeight[] calldata _strategyWithWeights) external onlyGovernorOrStrategist {\r\n        uint256 totalTarget = 0;\r\n        for (uint8 i = 0; i < _strategyWithWeights.length; i++) {\r\n            StrategyWithWeight memory strategyWithWeight = _strategyWithWeights[i];\r\n            require(strategyWithWeight.strategy != address(0), \"weight without strategy\");\r\n            require(\r\n                strategyWithWeight.minWeight <= strategyWithWeight.targetWeight,\r\n                \"minWeight shouldn't higher than targetWeight\"\r\n            );\r\n            require(\r\n                strategyWithWeight.targetWeight <= strategyWithWeight.maxWeight,\r\n                \"targetWeight shouldn't higher than maxWeight\"\r\n            );\r\n            totalTarget += strategyWithWeight.targetWeight;\r\n        }\r\n        require(totalTarget == TOTAL_WEIGHT, \"Total target should equal to TOTAL_WEIGHT\");\r\n        StrategyWithWeight[] memory sorted = sortWeightsByTarget(_strategyWithWeights);\r\n        for (uint8 i = 0; i < sorted.length; i++) {\r\n            _addStrategyWithWeightAt(sorted[i], i);\r\n            strategyWithWeightPositions[strategyWithWeights[i].strategy] = i;\r\n        }\r\n        // truncate if need\r\n        if (strategyWithWeights.length > sorted.length) {\r\n            uint256 removeCount = strategyWithWeights.length - sorted.length;\r\n            for (uint8 i = 0; i < removeCount; i++) {\r\n                strategyWithWeights.pop();\r\n            }\r\n        }\r\n\r\n        // console.log from strategyWithWeights\r\n        for (uint8 i = 0; i < strategyWithWeights.length; i++) {\r\n            StrategyWithWeight memory strategyWithWeight = strategyWithWeights[i];\r\n            console.log(strategyWithWeight.strategy, strategyWithWeight.targetWeight);\r\n        }\r\n\r\n    }\r\n    function _addStrategyWithWeightAt(StrategyWithWeight memory strategyWithWeight, uint256 index) internal {\r\n        uint256 currentLength = strategyWithWeights.length;\r\n        // expand if need\r\n        if (currentLength == 0 || currentLength - 1 < index) {\r\n            uint256 additionalCount = index - currentLength + 1;\r\n            for (uint8 i = 0; i < additionalCount; i++) {\r\n                strategyWithWeights.push();\r\n            }\r\n        }\r\n        strategyWithWeights[index] = strategyWithWeight;\r\n    }\r\n    function getStrategyWithWeight(address strategy) public view returns (StrategyWithWeight memory) {\r\n        return strategyWithWeights[strategyWithWeightPositions[strategy]];\r\n    }\r\n\r\n    function getAllStrategyWithWeights() public view returns (StrategyWithWeight[] memory) {\r\n        return strategyWithWeights;\r\n    }\r\n    /***************************\r\n            PRIMARY STABLE\r\n    ****************************/\r\n    function setPrimaryStable(address _primaryStable) external onlyGovernorOrStrategist {\r\n        primaryStableAddress = _primaryStable;\r\n    }\r\n\r\n    /***********************************\r\n            QuickDepositStartegies\r\n    ************************************/\r\n    function setQuickDepositStrategies(address[] calldata _quickDepositStrategies) external onlyGovernorOrStrategist {\r\n        quickDepositStrategies = _quickDepositStrategies;\r\n    }\r\n    /***********************************\r\n                setSwapper\r\n    ************************************/\r\n    function setSwapper(address _balancerVault, bytes32 _balancerPoolId) external onlyGovernorOrStrategist {\r\n        balancerVault = _balancerVault;\r\n        balancerPoolId = _balancerPoolId;\r\n    }\r\n\r\n    /***********************************\r\n                Harvester & Dripper\r\n    ************************************/\r\n    function setHarvester(address _harvester) external onlyGovernorOrStrategist {\r\n        harvesterAddress = _harvester;\r\n    }\r\n    function setDripper(address _dripper) external onlyGovernorOrStrategist {\r\n        dripperAddress = _dripper;\r\n    }\r\n\r\n\r\n    /***********************************\r\n            Fee Parameters\r\n    ************************************/\r\n    function setFeeParams(address _labsAddress, uint256 _labsFeeBps, address _teamAddress, uint256 _teamFeeBps) external onlyGovernor {\r\n        labsAddress = _labsAddress;\r\n        labsFeeBps = _labsFeeBps;\r\n        teamAddress = _teamAddress;\r\n        teamFeeBps = _teamFeeBps;\r\n        IHarvester(harvesterAddress).setLabs(labsAddress, labsFeeBps);\r\n        IHarvester(harvesterAddress).setTeam(teamAddress, teamFeeBps);\r\n    }\r\n    function getFeeParams() public view returns (address, uint256, address, uint256)  {\r\n        return (labsAddress, labsFeeBps, teamAddress, teamFeeBps);\r\n    }\r\n\r\n\r\n\r\n    /***************************\r\n              PAYOUT\r\n    ****************************/\r\n    function payout() external {\r\n        _payout();\r\n    }\r\n    function _payout() internal {\r\n        IHarvester(harvesterAddress).harvestAndDistribute();\r\n        IDripper(dripperAddress).collectAndRebase();\r\n        _balance();\r\n    }\r\n\r\n    /***************************\r\n            REBALANCE\r\n    ****************************/\r\n    function balance() external onlyGovernorOrStrategist {\r\n        _balance();\r\n    }\r\n    function _balance() internal {\r\n        IERC20 asset = IERC20(primaryStableAddress);\r\n        StrategyWithWeight[] memory strategies = getAllStrategyWithWeights();\r\n\r\n        // 1. calc total USDC equivalent\r\n        uint256 totalAssetInStrat = 0;\r\n        uint256 totalWeight = 0;\r\n        for (uint8 i; i < strategies.length; i++) {\r\n            if (!strategies[i].enabled) {// Skip if strategy is not enabled\r\n                continue;\r\n            }\r\n\r\n            // UnstakeFull from Strategies with targetWeight == 0\r\n            if(strategies[i].targetWeight == 0){\r\n                IStrategy(strategies[i].strategy).withdrawAll();\r\n            }else {\r\n                console.log(\"Balance in startegy: \",IStrategy(strategies[i].strategy).checkBalance());\r\n                totalAssetInStrat += IStrategy(strategies[i].strategy).checkBalance();\r\n                totalWeight += strategies[i].targetWeight;\r\n            }\r\n\r\n        }\r\n        uint256 totalAsset = totalAssetInStrat +  asset.balanceOf(address(this));\r\n        console.log(\"Total asset: \", totalAsset);\r\n\r\n        \r\n        // 3. calc diffs for strategies liquidity\r\n        Order[] memory stakeOrders = new Order[](strategies.length);\r\n        uint8 stakeOrdersCount = 0;\r\n        for (uint8 i; i < strategies.length; i++) {\r\n\r\n            if (!strategies[i].enabled) {// Skip if strategy is not enabled\r\n                continue;\r\n            }\r\n\r\n            uint256 targetLiquidity;\r\n            if (strategies[i].targetWeight == 0) {\r\n                targetLiquidity = 0;\r\n            } else {\r\n                targetLiquidity = (totalAsset * strategies[i].targetWeight) / totalWeight;\r\n            }\r\n\r\n            uint256 currentLiquidity = IStrategy(strategies[i].strategy).checkBalance();\r\n            if (targetLiquidity == currentLiquidity) {\r\n                // skip already at target strategies\r\n                continue;\r\n            }\r\n\r\n            if (targetLiquidity < currentLiquidity) {\r\n                // unstake now\r\n                console.log(\"Withdraw now amount from\", currentLiquidity - targetLiquidity, strategies[i].strategy);\r\n                IStrategy(strategies[i].strategy).withdraw(\r\n                    address(this),\r\n                    address(asset),\r\n                    currentLiquidity - targetLiquidity\r\n                );\r\n            } else {\r\n                console.log(\"Deposit later amount from\", targetLiquidity - currentLiquidity, strategies[i].strategy);\r\n                // save to stake later\r\n                stakeOrders[stakeOrdersCount] = Order(\r\n                    true,\r\n                    strategies[i].strategy,\r\n                    targetLiquidity - currentLiquidity\r\n                );\r\n                stakeOrdersCount++;\r\n            }\r\n        }\r\n        console.log(\"_asset Balance available after withdrawing\", asset.balanceOf(address(this)));\r\n        // 4.  make staking\r\n        for (uint8 i; i < stakeOrdersCount; i++) {\r\n\r\n            address strategy = stakeOrders[i].strategy;\r\n            uint256 amount = stakeOrders[i].amount;\r\n            console.log(\"Processing stake order of\", strategy, amount );\r\n\r\n            uint256 currentBalance = asset.balanceOf(address(this));\r\n            if (currentBalance < amount) {\r\n                amount = currentBalance;\r\n            }\r\n            asset.transfer(strategy, amount);\r\n\r\n            IStrategy(strategy).deposit(\r\n                address(asset),\r\n                amount\r\n            );\r\n        }\r\n\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n// Based on StableMath from Stability Labs Pty. Ltd.\r\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\r\n\r\nlibrary StableMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /***************************************\r\n                    Helpers\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Adjust the scale of an integer\r\n     * @param to Decimals to scale to\r\n     * @param from Decimals to scale from\r\n     */\r\n    function scaleBy(\r\n        uint256 x,\r\n        uint256 to,\r\n        uint256 from\r\n    ) internal pure returns (uint256) {\r\n        if (to > from) {\r\n            x = x.mul(10**(to - from));\r\n        } else if (to < from) {\r\n            x = x.div(10**(from - to));\r\n        }\r\n        return x;\r\n    }\r\n\r\n    /***************************************\r\n               Precise Arithmetic\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *         scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *         scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        uint256 z = x.mul(y);\r\n        // return 9e36 / 1e18 = 9e18\r\n        return z.div(scale);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *          scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x.mul(y);\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil.div(FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x Left hand input to division\r\n     * @param y Right hand input to division\r\n     * @return Result after multiplying the left operand by the scale, and\r\n     *         executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        uint256 z = x.mul(FULL_SCALE);\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return z.div(y);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOracle {\r\n    /**\r\n     * @dev returns the asset price in USD, 8 decimal digits.\r\n     */\r\n    function price(address asset) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IHarvester.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IHarvester {\r\n    event RewardTokenConfigUpdated(\r\n        address _tokenAddress,\r\n        uint16 _allowedSlippageBps,\r\n        uint16 _harvestRewardBps,\r\n        address _uniswapV2CompatibleAddr,\r\n        uint256 _liquidationLimit,\r\n        bool _doSwapRewardToken\r\n    );\r\n\r\n    // Governable.sol\r\n    function transferGovernance(address _newGovernor) external;\r\n\r\n    function claimGovernance() external;\r\n\r\n    function governor() external view returns (address);\r\n\r\n    // Harvester.sol\r\n    function addSwapToken(address _addr) external;\r\n\r\n    function removeSwapToken(address _addr) external;\r\n\r\n    function setRewardsProceedsAddress(address _rewardProceedsAddress) external;\r\n    function setLabs(address _labs, uint256 _feeBps) external;\r\n    function setTeam(address _team, uint256 _feeBps) external;\r\n    function getLabs() external view returns (address, uint256);\r\n    function getTeam() external view returns (address, uint256);\r\n\r\n    function harvest() external;\r\n\r\n    function harvest(address _strategyAddr) external;\r\n\r\n    function harvestAndDistribute() external;\r\n\r\n    function harvestAndDistribute(address _strategyAddr) external;\r\n\r\n    function harvestAndDistribute(address _strategyAddr, address _rewardTo) external;\r\n\r\n    function distributeFees() external;\r\n\r\n    function distributeProceeds() external;\r\n\r\n    function setSupportedStrategy(address _strategyAddress, bool _isSupported)\r\n        external;\r\n}\r\n"
    },
    "contracts/interfaces/IDripper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IDripper {\r\n    function availableFunds() external view returns (uint256);\r\n    function collect() external;\r\n    function collectAndRebase() external;\r\n    function setDripDuration(uint256 _durationSeconds) external;\r\n    function transferToken(address _asset, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH VaultStorage Contract\r\n * @notice The VaultStorage contract defines the storage for the Vault contracts\r\n * @author Stabl Protocol Inc\r\n */\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\nimport { CASH } from \"../token/CASH.sol\";\r\nimport { Initializable } from \"../utils/Initializable.sol\";\r\nimport \"../utils/Helpers.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\n\r\ncontract VaultStorage is Initializable, Governable {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n    using SafeMath for int256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event AssetSupported(address _asset);\r\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\r\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\r\n    event StrategyApproved(address _addr);\r\n    event StrategyRemoved(address _addr);\r\n    event Mint(address _addr, uint256 _value);\r\n    event Redeem(address _addr, uint256 _value);\r\n    event CapitalPaused();\r\n    event CapitalUnpaused();\r\n    event RebasePaused();\r\n    event RebaseUnpaused();\r\n    event VaultBufferUpdated(uint256 _vaultBuffer);\r\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\r\n    event PriceProviderUpdated(address _priceProvider);\r\n    event AllocateThresholdUpdated(uint256 _threshold);\r\n    event RebaseThresholdUpdated(uint256 _threshold);\r\n    event StrategistUpdated(address _address);\r\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\r\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\r\n    event TrusteeFeeBpsChanged(uint256 _basis);\r\n    event TrusteeAddressChanged(address _address);\r\n\r\n    // Assets supported by the Vault, i.e. Stablecoins\r\n    struct Asset {\r\n        bool isSupported;\r\n    }\r\n    mapping(address => Asset) internal assets;\r\n    address[] internal allAssets;\r\n\r\n    // Strategies approved for use by the Vault\r\n    struct Strategy {\r\n        bool isSupported;\r\n        uint256 _deprecated; // Deprecated storage slot\r\n    }\r\n    mapping(address => Strategy) internal strategies;\r\n    address[] internal allStrategies;\r\n\r\n    // Address of the Oracle price provider contract\r\n    address public priceProvider;\r\n    // Pausing bools\r\n    bool public rebasePaused = false;\r\n    bool public capitalPaused = true;\r\n    \r\n    // Redemption fee in basis points\r\n    uint256 public redeemFeeBps;\r\n    address public labsAddress;\r\n    uint256 public labsFeeBps;\r\n    address public teamAddress;\r\n    uint256 public teamFeeBps;\r\n\r\n    // Buffer of assets to keep in Vault to handle (most) withdrawals\r\n    uint256 public vaultBuffer;\r\n    // Mints over this amount automatically allocate funds. 18 decimals.\r\n    uint256 public autoAllocateThreshold;\r\n    // Mints over this amount automatically rebase. 18 decimals.\r\n    uint256 public rebaseThreshold;\r\n\r\n    CASH internal cash;\r\n\r\n    //keccak256(\"CASH.vault.governor.admin.impl\");\r\n    bytes32 constant adminImplPosition =\r\n        0x10e4e34101c81b29558fe5b91534ae1af03c346313e21b0f6446695a8e18e243;\r\n\r\n    // Address of the contract responsible for post rebase syncs with AMMs\r\n    address private _deprecated_rebaseHooksAddr = address(0);\r\n\r\n    // Deprecated: Address of Uniswap\r\n    // slither-disable-next-line constable-states\r\n    address private _deprecated_uniswapAddr = address(0);\r\n\r\n    // Address of the Strategist\r\n    address public strategistAddr = address(0);\r\n\r\n    // Mapping of asset address to the Strategy that they should automatically\r\n    // be allocated to\r\n    mapping(address => address) public assetDefaultStrategies;\r\n\r\n    uint256 public maxSupplyDiff;\r\n\r\n    // Trustee contract that can collect a percentage of yield\r\n    address public trusteeAddress;\r\n\r\n    // Amount of yield collected in basis points\r\n    uint256 public trusteeFeeBps;\r\n\r\n    // Deprecated: Tokens that should be swapped for stablecoins\r\n    address[] private _deprecated_swapTokens;\r\n\r\n    uint256 constant MINT_MINIMUM_ORACLE = 99800000;\r\n\r\n    address public primaryStableAddress;\r\n    \r\n    // List of strategies for quickly depositing the primaryStable to.\r\n    address[] public quickDepositStrategies;\r\n\r\n    // Balancer pool to swap the asset to primaryStable\r\n    address public balancerVault;\r\n    bytes32 public balancerPoolId;\r\n\r\n    // Harvester & Dripper\r\n    address public harvesterAddress;\r\n    address public dripperAddress;\r\n\r\n\r\n    struct StrategyWithWeight {\r\n        address strategy;\r\n        uint256 minWeight;\r\n        uint256 targetWeight;\r\n        uint256 maxWeight;\r\n        bool enabled;\r\n        bool enabledReward;\r\n    }\r\n\r\n    mapping(address => uint256) public strategyWithWeightPositions;\r\n    StrategyWithWeight[] public strategyWithWeights;\r\n    uint256 public constant TOTAL_WEIGHT = 100000; // 100000 ~ 100%\r\n\r\n    struct Order {\r\n        bool stake;\r\n        address strategy;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it\r\n     * @param newImpl address of the implementation\r\n     */\r\n    function setAdminImpl(address newImpl) external onlyGovernor {\r\n        require(\r\n            Address.isContract(newImpl),\r\n            \"new implementation is not a contract\"\r\n        );\r\n        bytes32 position = adminImplPosition;\r\n        assembly {\r\n            sstore(position, newImpl)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Sort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nlibrary Sort {\r\n    function quickSort(uint[] memory arr, int left, int right, uint[] memory indices) internal pure {\r\n        int i = left;\r\n        int j = right;\r\n        if (i == j) return;\r\n\r\n        uint pivot = arr[uint(left + (right - left) / 2)];\r\n\r\n        while (i <= j) {\r\n            while (arr[uint(i)] > pivot) i++;\r\n            while (pivot > arr[uint(j)]) j--;\r\n            if (i <= j) {\r\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\r\n                (indices[uint(i)], indices[uint(j)]) = (indices[uint(j)], indices[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(arr, left, j, indices);\r\n        if (i < right)\r\n            quickSort(arr, i, right, indices);\r\n    }\r\n\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\r\n */\r\ninterface IStrategy {\r\n    /**\r\n     * @dev Deposit the given asset to platform\r\n     * @param _asset asset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount) external;\r\n\r\n    /**\r\n     * @dev Deposit the entire balance of all supported assets in the Strategy\r\n     *      to the platform\r\n     */\r\n    function depositAll() external;\r\n\r\n    /**\r\n     * @dev Withdraw given asset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Liquidate all assets in strategy and return them to Vault.\r\n     */\r\n    function withdrawAll() external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given asset.\r\n     */\r\n    function checkBalance()\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns bool indicating whether strategy supports asset.\r\n     */\r\n    function supportsAsset(address _asset) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Collect reward tokens from the Strategy.\r\n     */\r\n    function collectRewardTokens() external;\r\n\r\n    /**\r\n     * @dev The address array of the reward tokens for the Strategy.\r\n     */\r\n    function getRewardTokenAddresses() external view returns (address[] memory);\r\n}\r\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Governable Contract\r\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\r\n *      from owner to governor and renounce methods removed. Does not use\r\n *      Context.sol like Ownable.sol does for simplification.\r\n * @author Stabl Protocol Inc\r\n */\r\ncontract Governable {\r\n    // Storage position of the owner and pendingOwner of the contract\r\n    // keccak256(\"CASH.governor\");\r\n    bytes32 private constant governorPosition =\r\n        0x83f34c88ec39d54d1e423bd8a181ebc59ede5dcc9996c2df334668b4f89fdd73;\r\n\r\n    // keccak256(\"CASH.pending.governor\");\r\n    bytes32 private constant pendingGovernorPosition =\r\n        0x7eaf9a7750884803435dfabc67aa617a7d8fefb23d8d84b3c9722bd69e48c4bc;\r\n\r\n    // keccak256(\"CASH.reentry.status\");\r\n    bytes32 private constant reentryStatusPosition =\r\n        0x48a06827bfe8bfc0a59fe65d0fa78f553938265ed1f971326fc09947d19a593c;\r\n\r\n    // See OpenZeppelin ReentrancyGuard implementation\r\n    uint256 constant _NOT_ENTERED = 1;\r\n    uint256 constant _ENTERED = 2;\r\n\r\n    event PendingGovernorshipTransfer(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    event GovernorshipTransferred(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial Governor.\r\n     */\r\n    constructor() {\r\n        _setGovernor(msg.sender);\r\n        emit GovernorshipTransferred(address(0), _governor());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current Governor.\r\n     */\r\n    function governor() public view returns (address) {\r\n        return _governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current Governor.\r\n     */\r\n    function _governor() internal view returns (address governorOut) {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            governorOut := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the pending Governor.\r\n     */\r\n    function _pendingGovernor()\r\n        internal\r\n        view\r\n        returns (address pendingGovernor)\r\n    {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            pendingGovernor := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        require(isGovernor(), \"Caller is not the Governor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current Governor.\r\n     */\r\n    function isGovernor() public view returns (bool) {\r\n        return msg.sender == _governor();\r\n    }\r\n\r\n    function _setGovernor(address newGovernor) internal {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        bytes32 position = reentryStatusPosition;\r\n        uint256 _reentry_status;\r\n        assembly {\r\n            _reentry_status := sload(position)\r\n        }\r\n\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        assembly {\r\n            sstore(position, _ENTERED)\r\n        }\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        assembly {\r\n            sstore(position, _NOT_ENTERED)\r\n        }\r\n    }\r\n\r\n    function _setPendingGovernor(address newGovernor) internal {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the current Governor. Must be claimed for this to complete\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function transferGovernance(address _newGovernor) external onlyGovernor {\r\n        _setPendingGovernor(_newGovernor);\r\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the new Governor.\r\n     */\r\n    function claimGovernance() external {\r\n        require(\r\n            msg.sender == _pendingGovernor(),\r\n            \"Only the pending Governor can complete the claim\"\r\n        );\r\n        _changeGovernor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function _changeGovernor(address _newGovernor) internal {\r\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\r\n        emit GovernorshipTransferred(_governor(), _newGovernor);\r\n        _setGovernor(_newGovernor);\r\n    }\r\n}\r\n"
    },
    "contracts/token/CASH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Token Contract\r\n * @dev ERC20 compatible contract for CASH\r\n * @dev Implements an elastic supply\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport { Initializable } from \"../utils/Initializable.sol\";\r\nimport { InitializableERC20Detailed } from \"../utils/InitializableERC20Detailed.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\n\r\n/**\r\n * NOTE that this is an ERC20 token but the invariant that the sum of\r\n * balanceOf(x) for all x is not >= totalSupply(). This is a consequence of the\r\n * rebasing design. Any integrations with CASH should be aware.\r\n */\r\n\r\ncontract CASH is Initializable, InitializableERC20Detailed, Governable {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n\r\n    event TotalSupplyUpdatedHighres(\r\n        uint256 totalSupply,\r\n        uint256 rebasingCredits,\r\n        uint256 rebasingCreditsPerToken\r\n    );\r\n\r\n    enum RebaseOptions {\r\n        NotSet,\r\n        OptOut,\r\n        OptIn\r\n    }\r\n\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\r\n    uint256 public _totalSupply;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    address public vaultAddress = address(0);\r\n    mapping(address => uint256) private _creditBalances;\r\n    uint256 private _rebasingCredits;\r\n    uint256 private _rebasingCreditsPerToken;\r\n    // Frozen address/credits are non rebasing (value is held in contracts which\r\n    // do not receive yield unless they explicitly opt in)\r\n    uint256 public nonRebasingSupply;\r\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\r\n    mapping(address => RebaseOptions) public rebaseState;\r\n    mapping(address => uint256) public isUpgraded;\r\n\r\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\r\n\r\n    function initialize(\r\n        string calldata _nameArg,\r\n        string calldata _symbolArg,\r\n        address _vaultAddress\r\n    ) external onlyGovernor initializer {\r\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\r\n        _rebasingCreditsPerToken = 1e18;\r\n        vaultAddress = _vaultAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault contract\r\n     */\r\n    modifier onlyVault() {\r\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return The total supply of CASH.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @return Low resolution rebasingCreditsPerToken\r\n     */\r\n    function rebasingCreditsPerToken() public view returns (uint256) {\r\n        return _rebasingCreditsPerToken / RESOLUTION_INCREASE;\r\n    }\r\n\r\n    /**\r\n     * @return Low resolution total number of rebasing credits\r\n     */\r\n    function rebasingCredits() public view returns (uint256) {\r\n        return _rebasingCredits / RESOLUTION_INCREASE;\r\n    }\r\n\r\n    /**\r\n     * @return High resolution rebasingCreditsPerToken\r\n     */\r\n    function rebasingCreditsPerTokenHighres() public view returns (uint256) {\r\n        return _rebasingCreditsPerToken;\r\n    }\r\n\r\n    /**\r\n     * @return High resolution total number of rebasing credits\r\n     */\r\n    function rebasingCreditsHighres() public view returns (uint256) {\r\n        return _rebasingCredits;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _account Address to query the balance of.\r\n     * @return A uint256 representing the amount of base units owned by the\r\n     *         specified address.\r\n     */\r\n    function balanceOf(address _account)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        if (_creditBalances[_account] == 0) return 0;\r\n        return\r\n            _creditBalances[_account].divPrecisely(_creditsPerToken(_account));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the credits balance of the specified address.\r\n     * @dev Backwards compatible with old low res credits per token.\r\n     * @param _account The address to query the balance of.\r\n     * @return (uint256, uint256) Credit balance and credits per token of the\r\n     *         address\r\n     */\r\n    function creditsBalanceOf(address _account)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 cpt = _creditsPerToken(_account);\r\n        if (cpt == 1e27) {\r\n            // For a period before the resolution upgrade, we created all new\r\n            // contract accounts at high resolution. Since they are not changing\r\n            // as a result of this upgrade, we will return their true values\r\n            return (_creditBalances[_account], cpt);\r\n        } else {\r\n            return (\r\n                _creditBalances[_account] / RESOLUTION_INCREASE,\r\n                cpt / RESOLUTION_INCREASE\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the credits balance of the specified address.\r\n     * @param _account The address to query the balance of.\r\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\r\n     *         address, and isUpgraded\r\n     */\r\n    function creditsBalanceOfHighres(address _account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            bool\r\n        )\r\n    {\r\n        return (\r\n            _creditBalances[_account],\r\n            _creditsPerToken(_account),\r\n            isUpgraded[_account] == 1\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address.\r\n     * @param _to the address to transfer to.\r\n     * @param _value the amount to be transferred.\r\n     * @return true on success.\r\n     */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n        // TODO: Hardcoded WrappedCASHProxy: 0xf72C31DF1FFaEBE7911C1a146f754f104C4DeacE\r\n        require(\r\n            _value <= balanceOf(msg.sender),\r\n            \"Balance not enough\"\r\n        );\r\n\r\n        _executeTransfer(msg.sender, _to, _value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * @param _from The address you want to send tokens from.\r\n     * @param _to The address you want to transfer to.\r\n     * @param _value The amount of tokens to be transferred.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override returns (bool) {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n        require(_value <= balanceOf(_from), \"Transfer greater than balance\");\r\n\r\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\r\n            _value\r\n        );\r\n\r\n        _executeTransfer(_from, _to, _value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the count of non rebasing credits in response to a transfer\r\n     * @param _from The address you want to send tokens from.\r\n     * @param _to The address you want to transfer to.\r\n     * @param _value Amount of CASH to transfer\r\n     */\r\n    function _executeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        bool isNonRebasingTo = _isNonRebasingAccount(_to);\r\n        bool isNonRebasingFrom = _isNonRebasingAccount(_from);\r\n\r\n        // Credits deducted and credited might be different due to the\r\n        // differing creditsPerToken used by each account\r\n        uint256 creditsCredited = _value.mulTruncate(_creditsPerToken(_to));\r\n        uint256 creditsDeducted = _value.mulTruncate(_creditsPerToken(_from));\r\n\r\n        _creditBalances[_from] = _creditBalances[_from].sub(\r\n            creditsDeducted,\r\n            \"Transfer amount exceeds balance\"\r\n        );\r\n        _creditBalances[_to] = _creditBalances[_to].add(creditsCredited);\r\n\r\n        if (isNonRebasingTo && !isNonRebasingFrom) {\r\n            // Transfer to non-rebasing account from rebasing account, credits\r\n            // are removed from the non rebasing tally\r\n            nonRebasingSupply = nonRebasingSupply.add(_value);\r\n            // Update rebasingCredits by subtracting the deducted amount\r\n            _rebasingCredits = _rebasingCredits.sub(creditsDeducted);\r\n        } else if (!isNonRebasingTo && isNonRebasingFrom) {\r\n            // Transfer to rebasing account from non-rebasing account\r\n            // Decreasing non-rebasing credits by the amount that was sent\r\n            nonRebasingSupply = nonRebasingSupply.sub(_value);\r\n            // Update rebasingCredits by adding the credited amount\r\n            _rebasingCredits = _rebasingCredits.add(creditsCredited);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that _owner has allowed to\r\n     *      `_spender`.\r\n     * @param _owner The address which owns the funds.\r\n     * @param _spender The address which will spend the funds.\r\n     * @return The number of tokens still available for the _spender.\r\n     */\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens\r\n     *      on behalf of msg.sender. This method is included for ERC20\r\n     *      compatibility. `increaseAllowance` and `decreaseAllowance` should be\r\n     *      used instead.\r\n     *\r\n     *      Changing an allowance with this method brings the risk that someone\r\n     *      may transfer both the old and the new allowance - if they are both\r\n     *      greater than zero - if a transfer transaction is mined before the\r\n     *      later approve() call is mined.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner has allowed to\r\n     *      `_spender`.\r\n     *      This method should be used instead of approve() to avoid the double\r\n     *      approval vulnerability described above.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]\r\n            .add(_addedValue);\r\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner has allowed to\r\n            `_spender`.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance\r\n     *        by.\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowances[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            _allowances[msg.sender][_spender] = 0;\r\n        } else {\r\n            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints new tokens, increasing totalSupply.\r\n     */\r\n    function mint(address _account, uint256 _amount) external onlyVault {\r\n        _mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address _account, uint256 _amount) internal nonReentrant {\r\n        require(_account != address(0), \"Mint to the zero address\");\r\n\r\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\r\n\r\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\r\n        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);\r\n\r\n        // If the account is non rebasing and doesn't have a set creditsPerToken\r\n        // then set it i.e. this is a mint from a fresh contract\r\n        if (isNonRebasingAccount) {\r\n            nonRebasingSupply = nonRebasingSupply.add(_amount);\r\n        } else {\r\n            _rebasingCredits = _rebasingCredits.add(creditAmount);\r\n        }\r\n\r\n        _totalSupply = _totalSupply.add(_amount);\r\n\r\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\r\n\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens, decreasing totalSupply.\r\n     */\r\n    function burn(address account, uint256 amount) external onlyVault {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `_account` cannot be the zero address.\r\n     * - `_account` must have at least `_amount` tokens.\r\n     */\r\n    function _burn(address _account, uint256 _amount) internal nonReentrant {\r\n        require(_account != address(0), \"Burn from the zero address\");\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n\r\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\r\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\r\n        uint256 currentCredits = _creditBalances[_account];\r\n\r\n        // Remove the credits, burning rounding errors\r\n        if (\r\n            currentCredits == creditAmount || currentCredits - 1 == creditAmount\r\n        ) {\r\n            // Handle dust from rounding\r\n            _creditBalances[_account] = 0;\r\n        } else if (currentCredits > creditAmount) {\r\n            _creditBalances[_account] = _creditBalances[_account].sub(\r\n                creditAmount\r\n            );\r\n        } else {\r\n            revert(\"Remove exceeds balance\");\r\n        }\r\n\r\n        // Remove from the credit tallies and non-rebasing supply\r\n        if (isNonRebasingAccount) {\r\n            nonRebasingSupply = nonRebasingSupply.sub(_amount);\r\n        } else {\r\n            _rebasingCredits = _rebasingCredits.sub(creditAmount);\r\n        }\r\n\r\n        _totalSupply = _totalSupply.sub(_amount);\r\n\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the credits per token for an account. Returns a fixed amount\r\n     *      if the account is non-rebasing.\r\n     * @param _account Address of the account.\r\n     */\r\n    function _creditsPerToken(address _account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (nonRebasingCreditsPerToken[_account] != 0) {\r\n            return nonRebasingCreditsPerToken[_account];\r\n        } else {\r\n            return _rebasingCreditsPerToken;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Is an account using rebasing accounting or non-rebasing accounting?\r\n     *      Also, ensure contracts are non-rebasing if they have not opted in.\r\n     * @param _account Address of the account.\r\n     */\r\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\r\n        bool isContract = Address.isContract(_account);\r\n        if (isContract && rebaseState[_account] == RebaseOptions.NotSet) {\r\n            _ensureRebasingMigration(_account);\r\n        }\r\n        return nonRebasingCreditsPerToken[_account] > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures internal account for rebasing and non-rebasing credits and\r\n     *      supply is updated following deployment of frozen yield change.\r\n     */\r\n    function _ensureRebasingMigration(address _account) internal {\r\n        if (nonRebasingCreditsPerToken[_account] == 0) {\r\n            if (_creditBalances[_account] == 0) {\r\n                // Since there is no existing balance, we can directly set to\r\n                // high resolution, and do not have to do any other bookkeeping\r\n                nonRebasingCreditsPerToken[_account] = 1e27;\r\n            } else {\r\n                // Migrate an existing account:\r\n\r\n                // Set fixed credits per token for this account\r\n                nonRebasingCreditsPerToken[_account] = _rebasingCreditsPerToken;\r\n                // Update non rebasing supply\r\n                nonRebasingSupply = nonRebasingSupply.add(balanceOf(_account));\r\n                // Update credit tallies\r\n                _rebasingCredits = _rebasingCredits.sub(\r\n                    _creditBalances[_account]\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a contract address to the non-rebasing exception list. The\r\n     * address's balance will be part of rebases and the account will be exposed\r\n     * to upside and downside.\r\n     */\r\n    function rebaseOptIn() public nonReentrant {\r\n        require(_isNonRebasingAccount(msg.sender), \"Account has not opted out\");\r\n\r\n        // Convert balance into the same amount at the current exchange rate\r\n        uint256 newCreditBalance = _creditBalances[msg.sender]\r\n            .mul(_rebasingCreditsPerToken)\r\n            .div(_creditsPerToken(msg.sender));\r\n\r\n        // Decreasing non rebasing supply\r\n        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));\r\n\r\n        _creditBalances[msg.sender] = newCreditBalance;\r\n\r\n        // Increase rebasing credits, totalSupply remains unchanged so no\r\n        // adjustment necessary\r\n        _rebasingCredits = _rebasingCredits.add(_creditBalances[msg.sender]);\r\n\r\n        rebaseState[msg.sender] = RebaseOptions.OptIn;\r\n\r\n        // Delete any fixed credits per token\r\n        delete nonRebasingCreditsPerToken[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * @dev Explicitly mark that an address is non-rebasing.\r\n     */\r\n    function rebaseOptOut() public nonReentrant {\r\n        require(!_isNonRebasingAccount(msg.sender), \"Account has not opted in\");\r\n\r\n        // Increase non rebasing supply\r\n        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));\r\n        // Set fixed credits per token\r\n        nonRebasingCreditsPerToken[msg.sender] = _rebasingCreditsPerToken;\r\n\r\n        // Decrease rebasing credits, total supply remains unchanged so no\r\n        // adjustment necessary\r\n        _rebasingCredits = _rebasingCredits.sub(_creditBalances[msg.sender]);\r\n\r\n        // Mark explicitly opted out of rebasing\r\n        rebaseState[msg.sender] = RebaseOptions.OptOut;\r\n    }\r\n\r\n    /**\r\n     * @dev Modify the supply without minting new tokens. This uses a change in\r\n     *      the exchange rate between \"credits\" and CASH tokens to change balances.\r\n     * @param _newTotalSupply New total supply of CASH.\r\n     */\r\n    function changeSupply(uint256 _newTotalSupply)\r\n        external\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        require(_totalSupply > 0, \"Cannot increase 0 supply\");\r\n\r\n        if (_totalSupply == _newTotalSupply) {\r\n            emit TotalSupplyUpdatedHighres(\r\n                _totalSupply,\r\n                _rebasingCredits,\r\n                _rebasingCreditsPerToken\r\n            );\r\n            return;\r\n        }\r\n\r\n        _totalSupply = _newTotalSupply > MAX_SUPPLY\r\n            ? MAX_SUPPLY\r\n            : _newTotalSupply;\r\n\r\n        _rebasingCreditsPerToken = _rebasingCredits.divPrecisely(\r\n            _totalSupply.sub(nonRebasingSupply)\r\n        );\r\n\r\n        require(_rebasingCreditsPerToken > 0, \"Invalid change in supply\");\r\n\r\n        _totalSupply = _rebasingCredits\r\n            .divPrecisely(_rebasingCreditsPerToken)\r\n            .add(nonRebasingSupply);\r\n\r\n        emit TotalSupplyUpdatedHighres(\r\n            _totalSupply,\r\n            _rebasingCredits,\r\n            _rebasingCreditsPerToken\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            initializing || !initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\r\n\r\nlibrary Helpers {\r\n    /**\r\n     * @notice Fetch the `symbol()` from an ERC20 token\r\n     * @dev Grabs the `symbol()` from a contract\r\n     * @param _token Address of the ERC20 token\r\n     * @return string Symbol of the ERC20 token\r\n     */\r\n    function getSymbol(address _token) internal view returns (string memory) {\r\n        string memory symbol = IBasicToken(_token).symbol();\r\n        return symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch the `decimals()` from an ERC20 token\r\n     * @dev Grabs the `decimals()` from a contract and fails if\r\n     *      the decimal value does not live within a certain range\r\n     * @param _token Address of the ERC20 token\r\n     * @return uint256 Decimals of the ERC20 token\r\n     */\r\n    function getDecimals(address _token) internal view returns (uint256) {\r\n        uint256 decimals = IBasicToken(_token).decimals();\r\n        require(\r\n            decimals >= 4 && decimals <= 18,\r\n            \"Token must have sufficient decimal places\"\r\n        );\r\n\r\n        return decimals;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n */\r\nabstract contract InitializableERC20Detailed is IERC20 {\r\n    // Storage gap to skip storage from prior to CASH reset\r\n    uint256[100] private _____gap;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(\r\n        string memory nameArg,\r\n        string memory symbolArg,\r\n        uint8 decimalsArg\r\n    ) internal {\r\n        _name = nameArg;\r\n        _symbol = symbolArg;\r\n        _decimals = decimalsArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBasicToken {\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH VaultInitializer Contract\r\n * @notice The Vault contract initializes the vault.\r\n * @author Stabl Protocol Inc\r\n */\r\n\r\nimport \"./VaultStorage.sol\";\r\n\r\ncontract VaultInitializer is VaultStorage {\r\n    function initialize(address _priceProvider, address _cash)\r\n        external\r\n        onlyGovernor\r\n        initializer\r\n    {\r\n        require(_priceProvider != address(0), \"PriceProvider address is zero\");\r\n        require(_cash != address(0), \"cash address is zero\");\r\n\r\n        cash = CASH(_cash);\r\n\r\n        priceProvider = _priceProvider;\r\n\r\n        rebasePaused = false;\r\n        capitalPaused = true;\r\n\r\n        // Initial  fee of 0 basis points\r\n        redeemFeeBps = 0;\r\n        teamFeeBps = 0;\r\n        labsFeeBps = 0;\r\n        // Initial Vault buffer of 0%\r\n        vaultBuffer = 0;\r\n        // Initial allocate threshold of 25,000 CASH\r\n        autoAllocateThreshold = 25000e18;\r\n        // Threshold for rebasing\r\n        rebaseThreshold = 1000e18;\r\n        // Initialize all strategies\r\n        allStrategies = new address[](0);\r\n        // Initialize all quick deposit strategies\r\n        quickDepositStrategies = new address[](0);\r\n    }\r\n}\r\n"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH VaultInitializer Contract\r\n * @notice The VaultInitializer sets up the initial contract.\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { VaultInitializer } from \"./VaultInitializer.sol\";\r\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\r\n\r\n\r\ncontract Vault is VaultInitializer, VaultAdmin {}\r\n"
    },
    "contracts/mocks/MockVault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { VaultCore } from \"../vault/VaultCore.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { VaultInitializer } from \"../vault/VaultInitializer.sol\";\r\nimport \"../utils/Helpers.sol\";\r\n\r\ncontract MockVault is VaultCore, VaultInitializer {\r\n    using StableMath for uint256;\r\n\r\n    uint256 storedTotalValue;\r\n\r\n    function setTotalValue(uint256 _value) public {\r\n        storedTotalValue = _value;\r\n    }\r\n\r\n    function totalValue() external view override returns (uint256) {\r\n        return storedTotalValue;\r\n    }\r\n\r\n    function _totalValue() internal view override returns (uint256) {\r\n        return storedTotalValue;\r\n    }\r\n\r\n    function _checkBalance()\r\n        internal\r\n        view\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n        return storedTotalValue;\r\n    }\r\n\r\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\r\n        maxSupplyDiff = _maxSupplyDiff;\r\n    }\r\n}\r\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Vault Contract\r\n * @notice The Vault contract stores assets. On a deposit, CASH will be minted\r\n           and sent to the depositor. On a withdrawal, CASH will be burned and\r\n           assets will be sent to the withdrawer. The Vault accepts deposits of\r\n           interest from yield bearing strategies which will modify the supply\r\n           of CASH.\r\n * @author Stabl Protocol Inc\r\n */\r\n\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { IOracle } from \"../interfaces/IOracle.sol\";\r\nimport { IBuyback } from \"../interfaces/IBuyback.sol\";\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport \"./VaultStorage.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract VaultCore is VaultStorage, BalancerExchange {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant MAX_UINT =\r\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Verifies that the rebasing is not paused.\r\n     */\r\n    modifier whenNotRebasePaused() {\r\n        require(!rebasePaused, \"Rebasing paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the deposits are not paused.\r\n     */\r\n    modifier whenNotCapitalPaused() {\r\n        require(!capitalPaused, \"Capital paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit a supported asset and mint CASH.\r\n     * @param _asset Address of the asset being deposited\r\n     * @param _amount Amount of the asset being deposited\r\n     * @param _minimumCASHAmount Minimum CASH to mint\r\n     */\r\n    function mint(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _minimumCASHAmount\r\n    ) external whenNotCapitalPaused nonReentrant {\r\n        _mint(_asset, _amount, _minimumCASHAmount);\r\n\r\n        // Swap to primaryStable\r\n        _swapAsset(_asset, primaryStableAddress);\r\n\r\n        _quickAllocate(); // _allocate(); // Change this to _quickAllocate()\r\n    }\r\n    function justMint(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _minimumCASHAmount\r\n    ) external whenNotCapitalPaused nonReentrant {\r\n        _mint(_asset, _amount, _minimumCASHAmount);\r\n    }\r\n    function _mint(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _minimumCASHAmount\r\n    ) internal {\r\n        require(assets[_asset].isSupported, \"Asset is not supported\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        uint256 price = IOracle(priceProvider).price(_asset);\r\n        if (price > 1e8) {\r\n            price = 1e8;\r\n        }\r\n        require(price >= MINT_MINIMUM_ORACLE, \"Asset price below peg\");\r\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\r\n        // Scale up to 18 decimal\r\n        uint256 unitAdjustedDeposit = _amount.scaleBy(18, assetDecimals);\r\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\r\n            price.scaleBy(18, 8), // Oracles have 8 decimal precision\r\n            10**assetDecimals\r\n        );\r\n\r\n        if (_minimumCASHAmount > 0) {\r\n            require(\r\n                priceAdjustedDeposit >= _minimumCASHAmount,\r\n                \"Mint amount lower than minimum\"\r\n            );\r\n        }\r\n\r\n        emit Mint(msg.sender, priceAdjustedDeposit);\r\n\r\n        // Rebase must happen before any transfers occur.\r\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\r\n            _rebase();\r\n        }\r\n\r\n        // Mint matching CASH\r\n        cash.mint(msg.sender, priceAdjustedDeposit);\r\n\r\n        // Transfer the deposited coins to the vault\r\n        IERC20 asset = IERC20(_asset);\r\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\r\n    }\r\n\r\n    // In memoriam\r\n\r\n    /**\r\n     * @dev Withdraw a supported asset and burn CASH.\r\n     * @param _amount Amount of CASH to burn\r\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\r\n     */\r\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\r\n        external\r\n        whenNotCapitalPaused\r\n        nonReentrant\r\n    {\r\n        _redeem(_amount, _minimumUnitAmount);\r\n    }\r\n    \r\n    \r\n\r\n\r\n    /**\r\n     * @dev Withdraw a supported asset and burn CASH.\r\n     * @param _amount Amount of CASH to burn\r\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\r\n     */\r\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        // Calculate redemption outputs\r\n        (\r\n            uint256 output,\r\n            uint256 backingValue,\r\n            uint256 redeemFee\r\n        ) = _calculateRedeemOutput(_amount);\r\n        console.log(\"Redeem output:\", output);\r\n        console.log(\"Backing value:\", backingValue);\r\n        console.log(\"Redeem Fee:\", redeemFee);\r\n        \r\n        uint256 primaryStableDecimals = Helpers.getDecimals(primaryStableAddress);\r\n\r\n        // Check that CASH is backed by enough assets\r\n        uint256 _totalSupply = cash.totalSupply();\r\n        if (maxSupplyDiff > 0) {\r\n            // Allow a max difference of maxSupplyDiff% between\r\n            // backing assets value and CASH total supply\r\n            uint256 diff = _totalSupply.divPrecisely(backingValue);\r\n            require(\r\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\r\n                    maxSupplyDiff,\r\n                \"Backing supply liquidity error\"\r\n            );\r\n        }\r\n        if (_minimumUnitAmount > 0) {\r\n            uint256 unitTotal = output.scaleBy(18, primaryStableDecimals);\r\n            require(\r\n                unitTotal >= _minimumUnitAmount,\r\n                \"Redeem amount lower than minimum\"\r\n            );\r\n        }\r\n        emit Redeem(msg.sender, _amount);\r\n\r\n        // Send output\r\n        require(output > 0, \"Nothing to redeem\");\r\n\r\n        IERC20 primaryStable = IERC20(primaryStableAddress);\r\n        address[] memory strategiesToWithdrawFrom = new address[](strategyWithWeights.length);\r\n        uint256[] memory amountsToWithdraw = new uint256[](strategyWithWeights.length);\r\n        uint256 totalAmount = primaryStable.balanceOf(address(this));\r\n        uint8 strategyIndex = 0;\r\n        uint8  index = 0;\r\n        while((totalAmount <= (output + redeemFee)) && (strategyIndex < strategyWithWeights.length)) {\r\n            uint256 currentStratBal = IStrategy(strategyWithWeights[strategyIndex].strategy).checkBalance();\r\n            console.log(\"Current strategy balance:\", strategyWithWeights[strategyIndex].strategy, currentStratBal);\r\n            if (currentStratBal > 0) {\r\n                if ( (currentStratBal + totalAmount) > (output + redeemFee) ) {\r\n                    strategiesToWithdrawFrom[index] = strategyWithWeights[strategyIndex].strategy;\r\n                    amountsToWithdraw[index] = currentStratBal - ((currentStratBal + totalAmount) - (output + redeemFee));\r\n                    totalAmount += currentStratBal - ((currentStratBal + totalAmount) - (output + redeemFee));\r\n                } else {\r\n                    strategiesToWithdrawFrom[index] = strategyWithWeights[strategyIndex].strategy;\r\n                    amountsToWithdraw[index] = currentStratBal;\r\n                    totalAmount += currentStratBal;\r\n                }\r\n                index++;\r\n            }\r\n            console.log(\"Total amount after:\", strategyWithWeights[strategyIndex].strategy, totalAmount);\r\n\r\n            strategyIndex++;\r\n        }\r\n        console.log(\"Total amount:\", totalAmount);\r\n        require(totalAmount >= (output + redeemFee), \"Not enough funds anywhere to redeem.\");\r\n\r\n        // Withdraw from strategies\r\n        for (uint8 i = 0; i < strategyWithWeights.length; i++) {\r\n            if (strategiesToWithdrawFrom[i] == address(0)) {\r\n                break;\r\n            }\r\n            console.log(\"VaultCore - Redeem - Withdraw from strategy: \", strategiesToWithdrawFrom[i], amountsToWithdraw[i]);\r\n            IStrategy(strategiesToWithdrawFrom[i]).withdraw(address(this), primaryStableAddress, amountsToWithdraw[i]);\r\n        }\r\n        require(primaryStable.balanceOf(address(this)) >= (output + redeemFee), \"Not enough funds after withdrawl.\");\r\n\r\n        primaryStable.safeTransfer(msg.sender, output);\r\n        _distributeFees(redeemFee);\r\n        cash.burn(msg.sender, _amount);\r\n\r\n        // Until we can prove that we won't affect the prices of our assets\r\n        // by withdrawing them, this should be here.\r\n        // It's possible that a strategy was off on its asset total, perhaps\r\n        // a reward token sold for more or for less than anticipated.\r\n        if (_amount > rebaseThreshold && !rebasePaused) {\r\n            _rebase();\r\n        }\r\n    }\r\n\r\n    function _distributeFees(uint256 _amount) internal {\r\n        require(\r\n            _amount > 0,\r\n            \"Amount should be greater than zero\"\r\n        );\r\n        console.log(\"Distributing fee:\", _amount);\r\n        uint256 labsfees = _amount.mul(labsFeeBps*10).div(10000);  // Since, we have already made the 10% of redeem amount, we need to make take labsFeeBps*10 percent of the fee amount\r\n        console.log(\"labsFeeBps:\", labsFeeBps);\r\n        console.log(\"Sending labs fees:\", labsfees);\r\n        uint256 teamfees =  _amount.mul(teamFeeBps*10).div(10000); \r\n        console.log(\"teamFeeBps:\", teamFeeBps);\r\n        console.log(\"Sending team fees:\", teamfees);\r\n        IERC20(primaryStableAddress).transfer(\r\n            labsAddress,\r\n            labsfees\r\n        );\r\n        IERC20(primaryStableAddress).transfer(\r\n            teamAddress,\r\n            teamfees\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Withdraw a supported asset and burn all CASH.\r\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\r\n     */\r\n    function redeemAll(uint256 _minimumUnitAmount)\r\n        external\r\n        whenNotCapitalPaused\r\n        nonReentrant\r\n    {\r\n        _redeem(cash.balanceOf(msg.sender), _minimumUnitAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate unallocated funds on Vault to strategies.\r\n     * @dev Allocate unallocated funds on Vault to strategies.\r\n     **/\r\n    function allocate() external whenNotCapitalPaused nonReentrant {\r\n        _allocate();\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate unallocated funds on Vault to strategies.\r\n     * @dev Allocate unallocated funds on Vault to strategies.\r\n     **/\r\n    function _allocate() internal {\r\n        uint256 vaultValue = _totalValueInVault();\r\n        // Nothing in vault to allocate\r\n        if (vaultValue == 0) return;\r\n        uint256 strategiesValue = _totalValueInStrategies();\r\n        // We have a method that does the same as this, gas optimisation\r\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\r\n\r\n        // We want to maintain a buffer on the Vault so calculate a percentage\r\n        // modifier to multiply each amount being allocated by to enforce the\r\n        // vault buffer\r\n        uint256 vaultBufferModifier;\r\n        if (strategiesValue == 0) {\r\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\r\n            // strategies\r\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\r\n        } else {\r\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\r\n                vaultValue\r\n            );\r\n            if (1e18 > vaultBufferModifier) {\r\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\r\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\r\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\r\n            } else {\r\n                // We need to let the buffer fill\r\n                return;\r\n            }\r\n        }\r\n        if (vaultBufferModifier == 0) return;\r\n\r\n        // Iterate over all assets in the Vault and allocate to the appropriate\r\n        // strategy\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            IERC20 asset = IERC20(allAssets[i]);\r\n            uint256 assetBalance = asset.balanceOf(address(this));\r\n            console.log(allAssets[i], \"assetBalance: \", assetBalance);\r\n            // No balance, nothing to do here\r\n            if (assetBalance == 0) continue;\r\n\r\n            // Multiply the balance by the vault buffer modifier and truncate\r\n            // to the scale of the asset decimals\r\n            uint256 allocateAmount = assetBalance.mulTruncate(\r\n                vaultBufferModifier\r\n            );\r\n\r\n            address depositStrategyAddr = assetDefaultStrategies[\r\n                address(asset)\r\n            ];\r\n\r\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\r\n                console.log(\"Sending \" , allocateAmount , \" to \" , depositStrategyAddr);\r\n                IStrategy strategy = IStrategy(depositStrategyAddr);\r\n                // Transfer asset to Strategy and call deposit method to\r\n                // mint or take required action\r\n                asset.safeTransfer(address(strategy), allocateAmount);\r\n                strategy.deposit(address(asset), allocateAmount);\r\n                emit AssetAllocated(\r\n                    address(asset),\r\n                    depositStrategyAddr,\r\n                    allocateAmount\r\n                );\r\n            }\r\n        }\r\n\r\n        // Trigger OGN Buyback\r\n        address _trusteeAddress = trusteeAddress; // gas savings\r\n        if (_trusteeAddress != address(0)) {\r\n            IBuyback(trusteeAddress).swap();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Allocate unallocated funds on Vault to quick deposit strategies.\r\n     * @dev Allocate unallocated funds on Vault to quick deposit strategies.\r\n     **/\r\n\r\n    function quickAllocate() external whenNotCapitalPaused nonReentrant {\r\n        _quickAllocate();\r\n    }\r\n    function _quickAllocate() internal {\r\n        console.log(\"quickAllocate -  primaryStableBalance: \", IERC20(primaryStableAddress).balanceOf(address(this)));\r\n        uint256 index =  block.number  % quickDepositStrategies.length;\r\n        address quickDepositStrategyAddr = quickDepositStrategies[index];\r\n        uint256 allocateAmount = IERC20(primaryStableAddress).balanceOf(address(this));\r\n        if (quickDepositStrategyAddr != address(0)   && allocateAmount > 0 ) {\r\n            IStrategy strategy = IStrategy(quickDepositStrategyAddr);\r\n            console.log(\"Quick Depositing \" , allocateAmount , \" to \" , quickDepositStrategyAddr);\r\n            IERC20(primaryStableAddress).safeTransfer(address(strategy), allocateAmount);\r\n            strategy.deposit(primaryStableAddress, allocateAmount);\r\n            emit AssetAllocated(\r\n                primaryStableAddress,\r\n                quickDepositStrategyAddr,\r\n                allocateAmount\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Calculate the total value of assets held by the Vault and all\r\n     *      strategies and update the supply of CASH.\r\n     */\r\n    function rebase() external virtual nonReentrant {\r\n        _rebase();\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the total value of assets held by the Vault and all\r\n     *      strategies and update the supply of CASH, optionally sending a\r\n     *      portion of the yield to the trustee.\r\n     */\r\n    function _rebase() internal whenNotRebasePaused {\r\n        uint256 cashSupply = cash.totalSupply();\r\n        console.log(\"Total CASH Supply: \", cashSupply);\r\n        if (cashSupply == 0) {\r\n            return;\r\n        }\r\n        uint256 vaultValue = _totalValue();\r\n        console.log(\"Total Vault Value: \", vaultValue);\r\n\r\n        // Yield fee collection\r\n        address _trusteeAddress = trusteeAddress; // gas savings\r\n        console.log(\"Trustee Address: \", _trusteeAddress);\r\n        if (_trusteeAddress != address(0) && (vaultValue > cashSupply)) {\r\n            console.log(\"Yield fee collection\");\r\n            uint256 yield = vaultValue.sub(cashSupply);\r\n            console.log(\"Yield: \", yield);\r\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\r\n            console.log(\"Fee: \", fee);\r\n            require(yield > fee, \"Fee must not be greater than yield\");\r\n            if (fee > 0) {\r\n                console.log(\"Minting CASH for fee \" , fee , \" to \" , _trusteeAddress);\r\n                cash.mint(_trusteeAddress, fee);\r\n            }\r\n            emit YieldDistribution(_trusteeAddress, yield, fee);\r\n        }\r\n\r\n        // Only rachet CASH supply upwards\r\n        cashSupply = cash.totalSupply(); // Final check should use latest value\r\n        if (vaultValue > cashSupply) {\r\n            console.log(\"Still vault value greater than supply, changing supply of CASH for vaultValue \" , vaultValue);\r\n            cash.changeSupply(vaultValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Determine the total value of assets held by the vault and its\r\n     *         strategies.\r\n     * @return value Total value in USD (1e18)\r\n     */\r\n    function totalValue() external view virtual returns (uint256 value) {\r\n        value = _totalValue();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Calculate the total value of the assets held by the\r\n     *         vault and its strategies.\r\n     * @return value Total value in USD (1e18)\r\n     */\r\n    function _totalValue() internal view virtual returns (uint256 value) {\r\n        return _totalValueInVault().add(_totalValueInStrategies());\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held in Vault.\r\n     * @return value Total value in ETH (1e18)\r\n     */\r\n    function _totalValueInVault() internal view returns (uint256 value) {\r\n        for (uint256 y = 0; y < allAssets.length; y++) {\r\n            IERC20 asset = IERC20(allAssets[y]);\r\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\r\n            uint256 balance = asset.balanceOf(address(this));\r\n            if (balance > 0) {\r\n                value = value.add(balance.scaleBy(18, assetDecimals));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held in Strategies.\r\n     * @return value Total value in ETH (1e18)\r\n     */\r\n    function _totalValueInStrategies() internal view returns (uint256 value) {\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held by strategy.\r\n     * @param _strategyAddr Address of the strategy\r\n     */\r\n    function _totalValueInStrategy(address _strategyAddr)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IStrategy strategy = IStrategy(_strategyAddr);\r\n        return strategy.checkBalance();\r\n        \r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of an asset held in Vault and all strategies.\r\n     * @return uint256 Balance of asset in decimals of asset\r\n     */\r\n    function checkBalance() external view returns (uint256) {\r\n        return _checkBalance();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of an asset held in Vault and all strategies.\r\n     * @return balance Balance of asset in decimals of asset\r\n     */\r\n    function _checkBalance()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256 balance)\r\n    {\r\n        IERC20 asset = IERC20(primaryStableAddress);\r\n        balance = asset.balanceOf(address(this));\r\n\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            balance = balance.add(strategy.checkBalance());\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Calculate the output for a redeem function\r\n     */\r\n    function calculateRedeemOutput(uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 output, ,) = _calculateRedeemOutput(_amount);\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the output for a redeem function\r\n     * @return output  amount respective to the primary stable\r\n     * @return totalBalance Total balance of Vault\r\n     */\r\n    function _calculateRedeemOutput(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n\r\n        IOracle oracle = IOracle(priceProvider);\r\n        uint256 primaryStablePrice =  oracle.price(primaryStableAddress).scaleBy(18, 8);\r\n        uint256 primaryStableBalance = _checkBalance();\r\n        uint256 primaryStableDecimals =  Helpers.getDecimals(primaryStableAddress);\r\n        uint256 totalBalance = 0;\r\n        uint256 redeemFee = 0;\r\n        // Calculate redeem fee\r\n        if (labsFeeBps > 0  || teamFeeBps > 0) {\r\n            redeemFee = _amount.mul(redeemFeeBps).div(10000);\r\n            _amount = _amount.sub(redeemFee);\r\n        }\r\n\r\n        totalBalance = totalBalance.add(primaryStableBalance.scaleBy(18, primaryStableDecimals));\r\n\r\n        // Never give out more than one\r\n        // stablecoin per dollar of CASH\r\n        if (primaryStablePrice < 1e18) {\r\n            primaryStablePrice = 1e18;\r\n        }\r\n        \r\n        // Calculate totalOutputRatio\r\n        uint256 ratio = primaryStableBalance\r\n            .scaleBy(18,primaryStableDecimals)\r\n            .mul(primaryStablePrice)\r\n            .div(totalBalance);\r\n\r\n        // Calculate final outputs\r\n        uint256 factor = _amount.divPrecisely(ratio);\r\n        return (primaryStableBalance.mul(factor).div(totalBalance), totalBalance, redeemFee.div(10**(18 - primaryStableDecimals)));\r\n    }\r\n\r\n    /**\r\n     * @notice Get an array of the supported asset prices in USD.\r\n     * @return assetPrices Array of asset prices in USD (1e18)\r\n     */\r\n    function _getAssetPrices()\r\n        internal\r\n        view\r\n        returns (uint256[] memory assetPrices)\r\n    {\r\n        assetPrices = new uint256[](getAssetCount());\r\n\r\n        IOracle oracle = IOracle(priceProvider);\r\n        // Price from Oracle is returned with 8 decimals\r\n        // _amount is in assetDecimals\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            assetPrices[i] = oracle.price(allAssets[i]).scaleBy(18, 8);\r\n        }\r\n    }\r\n\r\n    /********************************\r\n                Swapping\r\n    *********************************/\r\n    function _swapAsset(address tokenFrom, address tokenTo) internal {\r\n        setBalancerVault(balancerVault);\r\n        if ( ( tokenFrom != tokenTo) && (IERC20(tokenFrom).balanceOf(address(this)) > 0) )  {\r\n            console.log(\"VaultCore: Swapping from \", tokenFrom, tokenTo);\r\n            swap(\r\n                balancerPoolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(tokenFrom)),\r\n                IAsset(address(tokenTo)),\r\n                address(this),\r\n                address(this),\r\n                IERC20(tokenFrom).balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n        \r\n    }\r\n\r\n    /***************************************\r\n                    Utils\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Return the number of assets supported by the Vault.\r\n     */\r\n    function getAssetCount() public view returns (uint256) {\r\n        return allAssets.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all asset addresses in order\r\n     */\r\n    function getAllAssets() external view returns (address[] memory) {\r\n        return allAssets;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the number of strategies active on the Vault.\r\n     */\r\n    function getStrategyCount() external view returns (uint256) {\r\n        return allStrategies.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the array of all strategies\r\n     */\r\n    function getAllStrategies() external view returns (address[] memory) {\r\n        return allStrategies;\r\n    }\r\n\r\n    function isSupportedAsset(address _asset) external view returns (bool) {\r\n        return assets[_asset].isSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Falldown to the admin implementation\r\n     * @notice This is a catch all for all functions not declared in core\r\n     */\r\n    fallback() external payable {\r\n        bytes32 slot = adminImplPosition;\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(\r\n                gas(),\r\n                sload(slot),\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IBuyback.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBuyback {\r\n    function swap() external;\r\n}\r\n"
    },
    "contracts/exchanges/BalancerExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity  ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/balancer/interfaces/IVault.sol\";\r\nimport \"../interfaces/balancer/interfaces/IGeneralPool.sol\";\r\nimport \"../interfaces/balancer/interfaces/IMinimalSwapInfoPool.sol\";\r\nimport \"../interfaces/balancer/interfaces/IPoolSwapStructs.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\nabstract contract BalancerExchange {\r\n\r\n    int256 public constant MAX_VALUE = 10 ** 27;\r\n\r\n    IVault private balancerVault;\r\n\r\n    function setBalancerVault(address _balancerVault) internal {\r\n        balancerVault = IVault(_balancerVault);\r\n    }\r\n\r\n    function swap(\r\n        bytes32 poolId,\r\n        IVault.SwapKind kind,\r\n        IAsset tokenIn,\r\n        IAsset tokenOut,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        uint256 limit\r\n    ) internal returns (uint256) {\r\n        console.log(\"BalancerVault: swapping 1\", address(balancerVault));\r\n        console.log(\"BalancerVault: swapping 1\", address(tokenIn),  IERC20(address(tokenIn)).balanceOf(address(this)) );\r\n        IERC20(address(tokenIn)).approve(address(balancerVault), IERC20(address(tokenIn)).balanceOf(address(this)));\r\n\r\n        IVault.SingleSwap memory singleSwap;\r\n        singleSwap.poolId = poolId;\r\n        singleSwap.kind = kind;\r\n        singleSwap.assetIn = tokenIn;\r\n        singleSwap.assetOut = tokenOut;\r\n        singleSwap.amount = amount;\r\n\r\n        IVault.FundManagement memory fundManagement;\r\n        fundManagement.sender = sender;\r\n        fundManagement.fromInternalBalance = false;\r\n        fundManagement.recipient = payable(recipient);\r\n        fundManagement.toInternalBalance = false;\r\n\r\n        return balancerVault.swap(singleSwap, fundManagement, limit, block.timestamp + 600);\r\n    }\r\n\r\n    function swap(\r\n        bytes32 poolId,\r\n        IVault.SwapKind kind,\r\n        IAsset tokenIn,\r\n        IAsset tokenOut,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        console.log(\"BalancerVault: swapping 2\", address(tokenIn),  IERC20(address(tokenIn)).balanceOf(address(this)) );\r\n\r\n        IERC20(address(tokenIn)).approve(address(balancerVault), IERC20(address(tokenIn)).balanceOf(address(this)));\r\n\r\n        IVault.SingleSwap memory singleSwap;\r\n        singleSwap.poolId = poolId;\r\n        singleSwap.kind = kind;\r\n        singleSwap.assetIn = tokenIn;\r\n        singleSwap.assetOut = tokenOut;\r\n        singleSwap.amount = amount;\r\n\r\n        IVault.FundManagement memory fundManagement;\r\n        fundManagement.sender = sender;\r\n        fundManagement.fromInternalBalance = false;\r\n        fundManagement.recipient = payable(recipient);\r\n        fundManagement.toInternalBalance = false;\r\n\r\n        return balancerVault.swap(singleSwap, fundManagement, uint256(MAX_VALUE), block.timestamp + 600);\r\n    }\r\n\r\n    function batchSwap(\r\n        bytes32 poolId1,\r\n        bytes32 poolId2,\r\n        IVault.SwapKind kind,\r\n        IAsset tokenIn,\r\n        IAsset tokenMid,\r\n        IAsset tokenOut,\r\n        address sender,\r\n        address payable recipient,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n\r\n        IERC20(address(tokenIn)).approve(address(balancerVault), amount);\r\n\r\n        IVault.BatchSwapStep[] memory swaps = new IVault.BatchSwapStep[](2);\r\n\r\n        IVault.BatchSwapStep memory batchSwap1;\r\n        batchSwap1.poolId = poolId1;\r\n        batchSwap1.assetInIndex = 0;\r\n        batchSwap1.assetOutIndex = 1;\r\n        batchSwap1.amount = amount;\r\n        swaps[0] = batchSwap1;\r\n\r\n        IVault.BatchSwapStep memory batchSwap2;\r\n        batchSwap2.poolId = poolId2;\r\n        batchSwap2.assetInIndex = 1;\r\n        batchSwap2.assetOutIndex = 2;\r\n        batchSwap2.amount = 0;\r\n        swaps[1] = batchSwap2;\r\n\r\n        IAsset[] memory assets = new IAsset[](3);\r\n        assets[0] = tokenIn;\r\n        assets[1] = tokenMid;\r\n        assets[2] = tokenOut;\r\n\r\n        IVault.FundManagement memory fundManagement;\r\n        fundManagement.sender = sender;\r\n        fundManagement.fromInternalBalance = false;\r\n        fundManagement.recipient = recipient;\r\n        fundManagement.toInternalBalance = false;\r\n\r\n        int256[] memory limits = new int256[](3);\r\n        if (kind == IVault.SwapKind.GIVEN_IN) {\r\n            limits[0] = MAX_VALUE;\r\n            limits[1] = MAX_VALUE;\r\n            limits[2] = MAX_VALUE;\r\n        } else {\r\n            limits[0] = 0;\r\n            limits[1] = 0;\r\n            limits[2] = 0;\r\n        }\r\n\r\n        return uint256(- balancerVault.batchSwap(kind, swaps, assets, fundManagement, limits, block.timestamp + 600)[2]);\r\n    }\r\n\r\n    function onSwap(\r\n        bytes32 poolId,\r\n        IVault.SwapKind kind,\r\n        IERC20 tokenIn,\r\n        IERC20 tokenOut,\r\n        uint256 balance\r\n    ) internal view returns (uint256) {\r\n\r\n        IPoolSwapStructs.SwapRequest memory swapRequest;\r\n        swapRequest.kind = kind;\r\n        swapRequest.tokenIn = tokenIn;\r\n        swapRequest.tokenOut = tokenOut;\r\n        swapRequest.amount = balance;\r\n\r\n        (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock) = balancerVault.getPoolTokens(poolId);\r\n\r\n        (address pool, IVault.PoolSpecialization poolSpecialization) = balancerVault.getPool(poolId);\r\n\r\n        if (poolSpecialization == IVault.PoolSpecialization.GENERAL) {\r\n\r\n            uint256 indexIn;\r\n            uint256 indexOut;\r\n            for (uint8 i = 0; i < tokens.length; i++) {\r\n                if (tokens[i] == tokenIn) {\r\n                    indexIn = i;\r\n                } else if (tokens[i] == tokenOut) {\r\n                    indexOut = i;\r\n                }\r\n            }\r\n\r\n            return IGeneralPool(pool).onSwap(swapRequest, balances, indexIn, indexOut);\r\n\r\n        } else if (poolSpecialization == IVault.PoolSpecialization.MINIMAL_SWAP_INFO) {\r\n\r\n            uint256 balanceIn;\r\n            uint256 balanceOut;\r\n            for (uint8 i = 0; i < tokens.length; i++) {\r\n                if (tokens[i] == tokenIn) {\r\n                    balanceIn = balances[i];\r\n                } else if (tokens[i] == tokenOut) {\r\n                    balanceOut = balances[i];\r\n                }\r\n            }\r\n\r\n            return IMinimalSwapInfoPool(pool).onSwap(swapRequest, balanceIn, balanceOut);\r\n\r\n        } else {\r\n\r\n            uint256 balanceIn;\r\n            uint256 balanceOut;\r\n            for (uint8 i = 0; i < tokens.length; i++) {\r\n                if (tokens[i] == tokenIn) {\r\n                    balanceIn = balances[i];\r\n                } else if (tokens[i] == tokenOut) {\r\n                    balanceOut = balances[i];\r\n                }\r\n            }\r\n\r\n            return IMinimalSwapInfoPool(pool).onSwap(swapRequest, balanceIn, balanceOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get amount of token1 nominated in token0 where amount0Total is total getting amount nominated in token0\r\n     *\r\n     * precision: 0 - no correction, 1 - one correction (recommended value), 2 or more - several corrections\r\n     */\r\n    function _getAmountToSwap(\r\n        uint256 amount0Total,\r\n        uint256 reserve0,\r\n        uint256 reserve1,\r\n        uint256 denominator0,\r\n        uint256 denominator1,\r\n        uint256 precision,\r\n        bytes32 poolId,\r\n        IERC20 token0,\r\n        IERC20 token1\r\n    ) internal view returns (uint256) {\r\n        uint256 amount0ToSwap = (amount0Total * reserve1) / (reserve0 * denominator1 / denominator0 + reserve1);\r\n        console.log(\"amount0ToSwap\", amount0ToSwap);\r\n        for (uint i = 0; i < precision; i++) {\r\n            console.log(\"onSwap\", address(token0), address(token1));\r\n            uint256 amount1 = onSwap(poolId, IVault.SwapKind.GIVEN_IN, token0, token1, amount0ToSwap);\r\n            amount0ToSwap = (amount0Total * reserve1) / (reserve0 * amount1 / amount0ToSwap + reserve1);\r\n        }\r\n\r\n        return amount0ToSwap;\r\n    }\r\n\r\n    /**\r\n     * Get amount of lp tokens where amount0Total is total getting amount nominated in token0\r\n     *\r\n     * precision: 0 - no correction, 1 - one correction (recommended value), 2 or more - several corrections\r\n     */\r\n    function _getAmountLpTokensToWithdraw(\r\n        uint256 amount0Total,\r\n        uint256 reserve0,\r\n        uint256 reserve1,\r\n        uint256 totalLpBalance,\r\n        uint256 denominator0,\r\n        uint256 denominator1,\r\n        bytes32 poolId,\r\n        IERC20 token0,\r\n        IERC20 token1\r\n    ) internal view returns (uint256) {\r\n        uint256 lpBalance = (totalLpBalance * amount0Total * denominator1) / (reserve0 * denominator1 + reserve1 * denominator0);\r\n        for (uint i = 0; i < 1; i++) {\r\n            uint256 amount1 = reserve1 * lpBalance / totalLpBalance;\r\n            uint256 amount0 = onSwap(poolId, IVault.SwapKind.GIVEN_IN, token1, token0, amount1);\r\n            lpBalance = (totalLpBalance * amount0Total * amount1) / (reserve0 * amount1 + reserve1 * amount0);\r\n        }\r\n        return lpBalance;\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}"
    },
    "contracts/interfaces/balancer/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAsset.sol\";\n\ninterface IVault {\n\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user's Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n    external\n    view\n    returns (\n        uint256 cash,\n        uint256 managed,\n        uint256 lastChangeBlock,\n        address assetManager\n    );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n    external\n    view\n    returns (\n        IERC20[] memory tokens,\n        uint256[] memory balances,\n        uint256 lastChangeBlock\n    );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IGeneralPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IBasePool.sol\";\n\n/**\n * @dev IPools with the General specialization setting should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will\n * grant to the pool in a 'given out' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IGeneralPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external view returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IMinimalSwapInfoPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IBasePool.sol\";\n\n/**\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\n *\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\n * to the pool in a 'given out' swap.\n *\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\n * indeed the Vault.\n */\ninterface IMinimalSwapInfoPool is IBasePool {\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external view returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IVault.sol\";\n\ninterface IPoolSwapStructs {\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\n    // IMinimalSwapInfoPool.\n    //\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\n    //\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\n    //\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\n    // some Pools.\n    //\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\n    // one Pool.\n    //\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\n    //    balance.\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\n    //\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\n    // where the Pool sends the outgoing tokens.\n    //\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IBasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IVault.sol\";\nimport \"./IPoolSwapStructs.sol\";\n\n/**\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\n * either IGeneralPool or IMinimalSwapInfoPool\n */\ninterface IBasePool is IPoolSwapStructs {\n    /**\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\n     *\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\n     * designated to receive any benefits (typically pool shares). `balances` contains the total balances\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as minting pool shares.\n     */\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\n\n    /**\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\n     * `protocolSwapFeePercentage`.\n     *\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\n     *\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\n     * to which the Vault will send the proceeds. `balances` contains the total token balances for each token\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\n     *\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\n     * balance.\n     *\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\n     *\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\n     * state-changing operations, such as burning pool shares.\n     */\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\n\n    function getPoolId() external view returns (bytes32);\n}\n"
    },
    "contracts/strategies/SynapseStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Synapse Strategy\r\n * @notice Investment strategy for investing stablecoins via Synapse\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nimport { IPool } from \"./../connectors/synapse/IPool.sol\";\r\nimport { IStakerPool } from \"./../connectors/synapse/IStakerPool.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { DystopiaExchange } from \"./DystopiaExchange.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport { OvnMath } from \"../utils/OvnMath.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\n\r\ncontract SynapseStrategy is InitializableAbstractStrategy, DystopiaExchange {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using OvnMath for uint256;\r\n\r\n    uint256 internal constant maxSlippage = 1e16; // 1%\r\n    address internal pTokenAddress;\r\n\r\n    IERC20 public primaryStable;\r\n    IERC20 public synToken;\r\n    IERC20 public intermediateToken; // USDPlus\r\n\r\n    IPool public synapsePool;\r\n    IStakerPool public synapseStakerPool;\r\n    uint256 public synapseStakerPoolId;\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as Synapse strategies don't fit\r\n     * well within that abstraction.\r\n     * @param _platformAddress Address of the nUSD\r\n     * @param _vaultAddress Address of the vault\r\n     * @param _rewardTokenAddresses Address of USDC\r\n     * @param _assets Addresses of supported assets. MUST be passed in the same\r\n     *                order as returned by coins on the pool contract, i.e.\r\n     *                USDC\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // nUSD Token address\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses, // USDC\r\n        address[] calldata _assets, // USDC\r\n        address[] calldata _pTokens, // nUSD Token address\r\n        address _synToken,\r\n        address _synapsePool,\r\n        address _synapseStakerPool,\r\n        uint256 _synapseStakerPoolId\r\n    ) external onlyGovernor initializer {\r\n        // Should be set prior to abstract initialize call otherwise\r\n        // abstractSetPToken calls will fail\r\n        pTokenAddress = _pTokens[0];\r\n\r\n        synToken = IERC20(_synToken);\r\n        synapsePool = IPool(_synapsePool);\r\n        synapseStakerPool = IStakerPool(_synapseStakerPool);\r\n        synapseStakerPoolId = _synapseStakerPoolId;\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n    function _setRouterAndPrimaryStable(address _dystRouter, address _intermediateToken, address _primaryStable) external onlyGovernor {\r\n        require(_dystRouter != address(0), \"Zero address not allowed\");\r\n        require(_intermediateToken != address(0), \"Zero address not allowed\");\r\n        intermediateToken = IERC20(_intermediateToken);\r\n        _setDystopiaRouter(_dystRouter);\r\n        primaryStable = IERC20(_primaryStable);\r\n    }\r\n    function stakeLP() internal  {\r\n        IERC20(pTokenAddress).approve(address(synapseStakerPool), IERC20(pTokenAddress).balanceOf(address(this)));\r\n        synapseStakerPool.deposit(synapseStakerPoolId, IERC20(pTokenAddress).balanceOf(address(this)), address(this));\r\n    }\r\n\r\n    function unstakeLP(uint256 _amount) internal  {\r\n        synapseStakerPool.withdraw(synapseStakerPoolId, _amount, address(this));\r\n\r\n    }\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        override\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        require(_amount >= IERC20(_asset).balanceOf(address(this)), \"Not enough assets\");\r\n        require(_amount > 0, \"Must deposit something\");\r\n        // console.log(\"Depositing \", _amount, \" primaryStable tokens to Synapse\");\r\n        emit TransferLog(\"Depositing to Synapse: \", _asset, _amount);\r\n\r\n\r\n        emit Deposit(_asset, address(platformAddress), _amount);\r\n        uint256 tokenIndex = synapsePool.getTokenIndex(_asset);\r\n        uint256[] memory _amounts = new uint256[](4);\r\n        _amounts[tokenIndex] = _amount.subBasisPoints(4);\r\n        uint256 minToMint = synapsePool.calculateTokenAmount(_amounts, true);\r\n        _amounts[tokenIndex] = _amount;\r\n        IERC20(_asset).approve(address(synapsePool), _amount);\r\n        synapsePool.addLiquidity(_amounts, minToMint, block.timestamp);\r\n        stakeLP();\r\n    }\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        uint256[] memory _amounts = new uint256[](4);\r\n        uint256[] memory _amounts_to_deposit = new uint256[](4);\r\n        uint256 tokenIndex;\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            tokenIndex = synapsePool.getTokenIndex(assetsMapped[i]);\r\n            address assetAddress = assetsMapped[i];\r\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\r\n            emit TransferLog(\"Depositing all to Synapse: \", assetAddress, balance);\r\n            if (balance > 0) {\r\n                _amounts[tokenIndex] = balance.subBasisPoints(4);\r\n                _amounts_to_deposit[tokenIndex] = balance;\r\n                IERC20(assetsMapped[i]).approve(address(synapsePool), balance);\r\n\r\n            }\r\n        }\r\n        uint256 minToMint = synapsePool.calculateTokenAmount(_amounts, true);\r\n        synapsePool.addLiquidity(_amounts_to_deposit, minToMint, block.timestamp);\r\n        stakeLP();\r\n    }\r\n\r\n    \r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n\r\n        uint256[] memory _amounts = new uint256[](4);\r\n        uint256 tokenIndex = synapsePool.getTokenIndex(_asset);\r\n        _amounts[tokenIndex] = _amount.addBasisPoints(4) + 1;\r\n\r\n        uint256 balanceLP = synapsePool.calculateTokenAmount(_amounts, false);\r\n        (uint256 amount,) = synapseStakerPool.userInfo(synapseStakerPoolId, address(this));\r\n        if (balanceLP > amount) {\r\n            balanceLP = amount;\r\n        }\r\n\r\n        unstakeLP(balanceLP);\r\n        IERC20(pTokenAddress).approve(address(synapsePool), balanceLP);\r\n        synapsePool.removeLiquidityOneToken(balanceLP, uint8(tokenIndex), _amount, block.timestamp);\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdrawing from the Synapse: \", primaryStableBalance);\r\n        if (primaryStableBalance > 0) {\r\n            primaryStable.safeTransfer(_beneficiary, primaryStableBalance);\r\n        }\r\n\r\n    }\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\r\n\r\n        (uint256 amount,) = synapseStakerPool.userInfo(synapseStakerPoolId, address(this));\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        uint256 tokenIndex = synapsePool.getTokenIndex(address(primaryStable));\r\n        synapseStakerPool.withdraw(synapseStakerPoolId, amount, address(this));\r\n        uint256 assetBalance = synapsePool.calculateRemoveLiquidityOneToken(amount, uint8(tokenIndex));\r\n        IERC20(platformAddress).approve(address(synapsePool), amount);\r\n        synapsePool.removeLiquidityOneToken(amount, uint8(tokenIndex), assetBalance, block.timestamp);\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdrawing everthing from the Synapse: \", primaryStableBalance);\r\n        if (primaryStableBalance > 0) {\r\n            primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        }\r\n\r\n    }\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        (uint256 amount,) = synapseStakerPool.userInfo(synapseStakerPoolId, address(this));\r\n        // console.log(\"synapseStakerPool.userInfo - Collecting reward tokens: \", amount);\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        synapseStakerPool.harvest(synapseStakerPoolId, address(this));\r\n\r\n        // sell rewards\r\n        uint256 totalPrimaryStable;\r\n        uint256 synBalance = synToken.balanceOf(address(this));\r\n        // console.log(\"Synapse balance: \", synBalance);\r\n        if (synBalance > 0) {\r\n            uint256 synToPrimaryStable = _swapExactTokensForTokens(\r\n                address(synToken),\r\n                address(intermediateToken),\r\n                address(primaryStable),\r\n                false,\r\n                true,\r\n                synBalance,\r\n                address(this)\r\n            );\r\n            // console.log( \"USDP: \" , intermediateToken.balanceOf(address(this)) );\r\n            // console.log( \"USDC: \" , primaryStable.balanceOf(address(this)) );\r\n            // console.log(\"Synapse usdc: \", synToPrimaryStable);\r\n            totalPrimaryStable += synToPrimaryStable;\r\n        }\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        if (primaryStableBalance > 0) {\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                address(primaryStable),\r\n                primaryStableBalance\r\n            );\r\n            primaryStable.transfer(harvesterAddress, primaryStableBalance);\r\n        }\r\n    }\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 tokenIndex = synapsePool.getTokenIndex(address(primaryStable));\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n\r\n        (uint256 amount,) = synapseStakerPool.userInfo(synapseStakerPoolId, address(this));\r\n        if (amount > 0) {\r\n            primaryStableBalance += synapsePool.calculateRemoveLiquidityOneToken(amount, uint8(tokenIndex));\r\n        }\r\n        return primaryStableBalance;\r\n    }\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _asset == address(primaryStable);\r\n    }\r\n    /* NOT NEEDED */\r\n    function safeApproveAllTokens() external override  {}\r\n    function _abstractSetPToken(address _asset, address _cToken)internal override {}\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/connectors/synapse/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ninterface IPool {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getAdminBalance(uint256 index) external view returns (uint256);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n    external\r\n    view\r\n    returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function initialize(\r\n        IERC20[] memory pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 a,\r\n        uint256 fee,\r\n        uint256 adminFee,\r\n        address lpTokenTargetAddress\r\n    ) external;\r\n\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n}"
    },
    "contracts/connectors/synapse/IStakerPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IStakerPool {\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint128 accSynapsePerShare;\r\n        uint64 lastRewardTime;\r\n        uint64 allocPoint;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256);\r\n\r\n    function updatePool(uint256 pid) external returns (IStakerPool.PoolInfo memory);\r\n\r\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    function withdraw(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    function harvest(uint256 pid, address to) external;\r\n\r\n    function withdrawAndHarvest(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    function emergencyWithdraw(uint256 pid, address to) external;\r\n}"
    },
    "contracts/strategies/DystopiaExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/IDystopiaRouter.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\nabstract contract DystopiaExchange {\r\n\r\n    uint256 public constant BASIS_POINTS_FOR_SLIPPAGE = 4;\r\n\r\n    IDystopiaRouter private dystRouter;\r\n\r\n    function _setDystopiaRouter(address _dystRouter) internal {\r\n        dystRouter = IDystopiaRouter(_dystRouter);\r\n    }\r\n\r\n    function _swapExactTokensForTokens(\r\n        address inputToken,\r\n        address middleToken,\r\n        address outputToken,\r\n        bool isStablePair0,\r\n        bool isStablePair1,\r\n        uint256 amountInput,\r\n        address recipient\r\n    ) internal returns (uint256) {\r\n\r\n        IERC20(inputToken).approve(address(dystRouter), amountInput);\r\n\r\n        uint256 amountOutMin = _getAmountsOut(address(inputToken), address(middleToken), address(outputToken), isStablePair0, isStablePair1, amountInput);\r\n        // console.log(\"amountOutMin: \", amountOutMin);\r\n        if (amountOutMin == 0) {\r\n            return 0;\r\n        }\r\n\r\n        IDystopiaRouter.Route[] memory route = new IDystopiaRouter.Route[](2);\r\n        route[0].from = inputToken;\r\n        route[0].to = middleToken;\r\n        route[0].stable = isStablePair0;\r\n        route[1].from = middleToken;\r\n        route[1].to = outputToken;\r\n        route[1].stable = isStablePair1;\r\n\r\n        uint[] memory amounts = dystRouter.swapExactTokensForTokens(\r\n            amountInput,\r\n            0,\r\n            route,\r\n            recipient,\r\n            block.timestamp + 600\r\n        );\r\n    \r\n        return amounts[2];\r\n    }\r\n\r\n    function _getAmountsOut(\r\n        address inputToken,\r\n        address middleToken,\r\n        address outputToken,\r\n        bool isStablePair0,\r\n        bool isStablePair1,\r\n        uint256 amountInput\r\n    ) internal view returns (uint256) {\r\n\r\n        IDystopiaRouter.Route[] memory route = new IDystopiaRouter.Route[](2);\r\n        route[0].from = inputToken;\r\n        route[0].to = middleToken;\r\n        route[0].stable = isStablePair0;\r\n        route[1].from = middleToken;\r\n        route[1].to = outputToken;\r\n        route[1].stable = isStablePair1;\r\n\r\n        uint[] memory amounts = dystRouter.getAmountsOut(amountInput, route);\r\n\r\n        return amounts[2];\r\n    }\r\n\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to\r\n    ) internal returns (uint amountA, uint amountB, uint liquidity) {\r\n\r\n        IERC20(tokenA).approve(address(dystRouter), amountADesired);\r\n        IERC20(tokenB).approve(address(dystRouter), amountBDesired);\r\n\r\n        return dystRouter.addLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            true,\r\n            amountADesired,\r\n            amountBDesired,\r\n            amountAMin,\r\n            amountBMin,\r\n            to,\r\n            block.timestamp + 600\r\n        );\r\n\r\n    }\r\n\r\n    function _removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        address lpToken,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to\r\n    ) internal returns (uint amountA, uint amountB) {\r\n\r\n        IERC20(lpToken).approve(address(dystRouter), liquidity);\r\n\r\n        return dystRouter.removeLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            true,\r\n            liquidity,\r\n            amountAMin,\r\n            amountBMin,\r\n            to,\r\n            block.timestamp + 600\r\n        );\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport { Initializable } from \"../utils/Initializable.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\n\r\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    event PTokenAdded(address indexed _asset, address _pToken);\r\n    event PTokenRemoved(address indexed _asset, address _pToken);\r\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\r\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\r\n    event RewardTokenCollected(\r\n        address recipient,\r\n        address rewardToken,\r\n        uint256 amount\r\n    );\r\n    event RewardTokenAddressesUpdated(\r\n        address[] _oldAddresses,\r\n        address[] _newAddresses\r\n    );\r\n    event HarvesterAddressesUpdated(\r\n        address _oldHarvesterAddress,\r\n        address _newHarvesterAddress\r\n    );\r\n    event TransferLog (\r\n        string _message,\r\n        address _asset,\r\n        uint256 _number\r\n    );\r\n\r\n    // Core address for the given platform\r\n    address public platformAddress;\r\n\r\n    address public vaultAddress;\r\n\r\n    // asset => pToken (Platform Specific Token Address)\r\n    mapping(address => address) public assetToPToken;\r\n\r\n    // Full list of all assets supported here\r\n    address[] internal assetsMapped;\r\n\r\n    // Deprecated: Reward token address\r\n    // slither-disable-next-line constable-states\r\n    address public _deprecated_rewardTokenAddress;\r\n\r\n    // Deprecated: now resides in Harvester's rewardTokenConfigs\r\n    // slither-disable-next-line constable-states\r\n    uint256 public _deprecated_rewardLiquidationThreshold;\r\n\r\n    // Address of the one address allowed to collect reward tokens\r\n    address public harvesterAddress;\r\n\r\n    // Reward token addresses\r\n    address[] public rewardTokenAddresses;\r\n    // Reserved for future expansion\r\n    int256[98] private _reserved;\r\n\r\n    /**\r\n     * @dev Internal initialize function, to set up initial internal state\r\n     * @param _platformAddress Generic platform address\r\n     * @param _vaultAddress Address of the Vault\r\n     * @param _rewardTokenAddresses Address of reward token for platform\r\n     * @param _assets Addresses of initial supported assets\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress,\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses,\r\n        address[] calldata _assets,\r\n        address[] calldata _pTokens\r\n    ) external onlyGovernor initializer {\r\n        InitializableAbstractStrategy._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n\r\n    function _initialize(\r\n        address _platformAddress,\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses,\r\n        address[] memory _assets,\r\n        address[] memory _pTokens\r\n    ) internal {\r\n        platformAddress = _platformAddress;\r\n        vaultAddress = _vaultAddress;\r\n        rewardTokenAddresses = _rewardTokenAddresses;\r\n\r\n        uint256 assetCount = _assets.length;\r\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            _setPTokenAddress(_assets[i], _pTokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Collect accumulated reward token and send to Vault.\r\n     */\r\n    function collectRewardTokens() external virtual onlyHarvester nonReentrant {\r\n        _collectRewardTokens();\r\n    }\r\n\r\n    function _collectRewardTokens() internal {\r\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\r\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\r\n            uint256 balance = rewardToken.balanceOf(address(this));\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                rewardTokenAddresses[i],\r\n                balance\r\n            );\r\n            rewardToken.safeTransfer(harvesterAddress, balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault.\r\n     */\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Harvester.\r\n     */\r\n    modifier onlyHarvester() {\r\n        require(msg.sender == harvesterAddress, \"Caller is not the Harvester\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault or Governor.\r\n     */\r\n    modifier onlyVaultOrGovernor() {\r\n        require(\r\n            msg.sender == vaultAddress || msg.sender == governor(),\r\n            \"Caller is not the Vault or Governor\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the reward token addresses.\r\n     * @param _rewardTokenAddresses Address array of the reward token\r\n     */\r\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        for (uint256 i = 0; i < _rewardTokenAddresses.length; i++) {\r\n            require(\r\n                _rewardTokenAddresses[i] != address(0),\r\n                \"Can not set an empty address as a reward token\"\r\n            );\r\n        }\r\n\r\n        emit RewardTokenAddressesUpdated(\r\n            rewardTokenAddresses,\r\n            _rewardTokenAddresses\r\n        );\r\n        rewardTokenAddresses = _rewardTokenAddresses;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the reward token addresses.\r\n     * @return address[] the reward token addresses.\r\n     */\r\n    function getRewardTokenAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return rewardTokenAddresses;\r\n    }\r\n\r\n    /**\r\n     * @dev Provide support for asset by passing its pToken address.\r\n     *      This method can only be called by the system Governor\r\n     * @param _asset    Address for the asset\r\n     * @param _pToken   Address for the corresponding platform token\r\n     */\r\n    function setPTokenAddress(address _asset, address _pToken)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        _setPTokenAddress(_asset, _pToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a supported asset by passing its index.\r\n     *      This method can only be called by the system Governor\r\n     * @param _assetIndex Index of the asset to be removed\r\n     */\r\n    function removePToken(uint256 _assetIndex) external onlyGovernor {\r\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\r\n        address asset = assetsMapped[_assetIndex];\r\n        address pToken = assetToPToken[asset];\r\n\r\n        if (_assetIndex < assetsMapped.length - 1) {\r\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\r\n        }\r\n        assetsMapped.pop();\r\n        assetToPToken[asset] = address(0);\r\n\r\n        emit PTokenRemoved(asset, pToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Provide support for asset by passing its pToken address.\r\n     *      Add to internal mappings and execute the platform specific,\r\n     * abstract method `_abstractSetPToken`\r\n     * @param _asset    Address for the asset\r\n     * @param _pToken   Address for the corresponding platform token\r\n     */\r\n    function _setPTokenAddress(address _asset, address _pToken) internal {\r\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\r\n        require(\r\n            _asset != address(0) && _pToken != address(0),\r\n            \"Invalid addresses\"\r\n        );\r\n\r\n        assetToPToken[_asset] = _pToken;\r\n        assetsMapped.push(_asset);\r\n\r\n        emit PTokenAdded(_asset, _pToken);\r\n\r\n        _abstractSetPToken(_asset, _pToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\r\n     *      strategy contracts, i.e. mistaken sends.\r\n     * @param _asset Address for the asset\r\n     * @param _amount Amount of the asset to transfer\r\n     */\r\n    function transferToken(address _asset, uint256 _amount)\r\n        public\r\n        onlyGovernor\r\n    {\r\n        IERC20(_asset).safeTransfer(governor(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the reward token addresses.\r\n     * @param _harvesterAddress Address of the harvester\r\n     */\r\n    function setHarvesterAddress(address _harvesterAddress)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        harvesterAddress = _harvesterAddress;\r\n        emit HarvesterAddressesUpdated(harvesterAddress, _harvesterAddress);\r\n    }\r\n\r\n    /***************************************\r\n                 Abstract\r\n    ****************************************/\r\n\r\n    function _abstractSetPToken(address _asset, address _pToken)\r\n        internal\r\n        virtual;\r\n\r\n    function safeApproveAllTokens() external virtual;\r\n\r\n    /**\r\n     * @dev Deposit an amount of asset into the platform\r\n     * @param _asset               Address for the asset\r\n     * @param _amount              Units of asset to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount) external virtual;\r\n\r\n    /**\r\n     * @dev Deposit balance of all supported assets into the platform\r\n     */\r\n    function depositAll() external virtual;\r\n\r\n    /**\r\n     * @dev Withdraw an amount of asset from the platform.\r\n     * @param _recipient         Address to which the asset should be sent\r\n     * @param _asset             Address of the asset\r\n     * @param _amount            Units of asset to withdraw\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @dev Withdraw all assets from strategy sending assets to Vault.\r\n     */\r\n    function withdrawAll() external virtual;\r\n\r\n    /**\r\n     * @dev Get the total primary stable value held in the platform.\r\n     *      This includes any interest that was generated since depositing.\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function checkBalance()\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Check if an asset is supported.\r\n     * @param _asset    Address of the asset\r\n     * @return bool     Whether asset is supported\r\n     */\r\n    function supportsAsset(address _asset) external view virtual returns (bool);\r\n}\r\n"
    },
    "contracts/utils/OvnMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary OvnMath {\r\n\r\n    uint256 constant BASIS_DENOMINATOR = 10 ** 4;\r\n\r\n    function abs(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return (x > y) ? (x - y) : (y - x);\r\n    }\r\n\r\n    function addBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\r\n        return amount * (BASIS_DENOMINATOR + basisPoints) / BASIS_DENOMINATOR;\r\n    }\r\n\r\n    function reverseAddBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\r\n        return amount * BASIS_DENOMINATOR / (BASIS_DENOMINATOR + basisPoints);\r\n    }\r\n\r\n    function subBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\r\n        return amount * (BASIS_DENOMINATOR - basisPoints) / BASIS_DENOMINATOR;\r\n    }\r\n\r\n    function reverseSubBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\r\n        return amount * BASIS_DENOMINATOR / (BASIS_DENOMINATOR - basisPoints);\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IDystopiaRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.2;\r\n\r\ninterface IDystopiaRouter {\r\n    \r\n    struct Route {\r\n        address from;\r\n        address to;\r\n        bool stable;\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool stable,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        Route[] calldata routes,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable);\r\n    function getAmountsOut(uint amountIn, Route[] memory routes) external view returns (uint[] memory amounts);\r\n    function getReserves(address tokenA, address tokenB, bool stable) external view returns (uint reserveA, uint reserveB);\r\n}"
    },
    "contracts/strategies/MeshSwapStrategyDual.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title MeshSwap Strategy\r\n * @notice Investment strategy for investing stablecoins via NeshSwap Strategy\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"  ;\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { OvnMath } from \"../utils/OvnMath.sol\";\r\n\r\nimport \"../exchanges/UniswapV2Exchange.sol\";\r\nimport { AaveBorrowLibrary } from \"../utils/AaveBorrowLibrary.sol\";\r\nimport \"../interfaces/IPriceFeed.sol\";\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport \"../interfaces/IMeshSwapLP.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract MeshSwapStrategyDual is InitializableAbstractStrategy, UniswapV2Exchange, BalancerExchange   {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using OvnMath for uint256;\r\n\r\n\r\n    IERC20 public token0;\r\n    IERC20 public token1;\r\n    IERC20 public primaryStable;\r\n    IERC20 public meshToken;\r\n\r\n    IMeshSwapLP public meshSwapPair;\r\n    bytes32 public poolId;\r\n\r\n    mapping(address => address) public assetToChainlink;\r\n    mapping(address => uint256 ) public assetToDenominator;\r\n\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as MeshSwap strategies don't fit\r\n     * well within that abstraction.\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // MeshToken address\r\n        address _vaultAddress,    // VaultProxy address\r\n        address[] calldata _rewardTokenAddresses, // USDC - as in end USDC will be sent to Harvester\r\n        address[] calldata _assets, // token0 + token1 (Ex. USDT)\r\n        address[] calldata _pTokens, //  MeshSwapPair (Ex: meshSwapUsdcUsdt)\r\n        address _router, // meshSwapRouter\r\n        address _primaryStable, // USDC\r\n        address[] calldata _chainLinks // chainlink, 0: primaryStable, 1: token0, 2: token1\r\n    ) external onlyGovernor initializer {\r\n        token0 = IERC20(_assets[0]);\r\n        token1 = IERC20(_assets[1]);\r\n\r\n        primaryStable = IERC20(_primaryStable);\r\n        meshToken = IERC20(_platformAddress);\r\n\r\n        uint256 assetCount = _assets.length;\r\n        assetToChainlink[_primaryStable] = _chainLinks[0];\r\n        assetToDenominator[_primaryStable] = 10 ** IERC20Metadata(_primaryStable).decimals();\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            assetToChainlink[_assets[i]] = _chainLinks[i+1];\r\n            assetToDenominator[_assets[i]] = 10 ** IERC20Metadata(_assets[i]).decimals();\r\n        }\r\n        meshSwapPair = IMeshSwapLP(_pTokens[0]);\r\n        _setUniswapRouter(_router);\r\n        _abstractSetPToken(_assets[0],_pTokens[0]);\r\n        _abstractSetPToken(_assets[1],_pTokens[1]);\r\n\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n\r\n    function setBalancer(address _balancerVault, bytes32 _balancerPoolIdUsdcTusdDaiUsdt) external onlyGovernor {\r\n        require(_balancerVault != address(0), \"Zero address not allowed\");\r\n        require(_balancerPoolIdUsdcTusdDaiUsdt != \"\", \"Empty pool id not allowed\");\r\n\r\n        setBalancerVault(_balancerVault);\r\n        poolId = _balancerPoolIdUsdcTusdDaiUsdt;\r\n    }\r\n\r\n    function getReserves() internal view returns (uint256,uint256,uint256) {\r\n        (uint256 reserve0, uint256  reserve1,) = meshSwapPair.getReserves();\r\n        require(reserve0 > (10 ** (IERC20Metadata(address(token0) ).decimals() - 3))  && reserve1 > (10 ** (IERC20Metadata(address(token1) ).decimals() - 3)), \"Reserves too low\");\r\n        return (reserve0, reserve1, meshSwapPair.totalSupply()) ;\r\n\r\n    }\r\n\r\n    function _deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )  internal {\r\n\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1, uint256 totalSupply) = getReserves();\r\n        _swapPrimaryStableToToken0();\r\n        // count amount token1 to swap\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n        uint256 amountToken0FromToken1;\r\n        if (token1Balance > 0) {\r\n            amountToken0FromToken1 = onSwap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                token1,\r\n                token0,\r\n                token1Balance\r\n            );\r\n        }\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        //TODO add parameter to _getAmountToSwap() second token amount\r\n        uint256 amountUsdcToSwap = _getAmountToSwap(\r\n            token0Balance - (amountToken0FromToken1 / 2),\r\n            reserve0,\r\n            reserve1,\r\n            assetToDenominator[address(token0)],\r\n            assetToDenominator[address(token1)],\r\n            1,\r\n            poolId,\r\n            token0,\r\n            token1\r\n        );\r\n\r\n        // swap token0 to other token\r\n        swap(\r\n            poolId,\r\n            IVault.SwapKind.GIVEN_IN,\r\n            IAsset(address(token0)),\r\n            IAsset(address(token1)),\r\n            address(this),\r\n            address(this),\r\n            amountUsdcToSwap,\r\n            0\r\n        );\r\n\r\n        // add liquidity\r\n        token0Balance = token0.balanceOf(address(this));\r\n        token1Balance = token1.balanceOf(address(this));\r\n        \r\n        _addLiquidity(\r\n            address(token0),\r\n            address(token1),\r\n            token0Balance,\r\n            token1Balance,\r\n            OvnMath.subBasisPoints(token0Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            OvnMath.subBasisPoints(token1Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            address(this)\r\n        );\r\n        uint256 lpTokenBalance = meshSwapPair.balanceOf(address(this));\r\n    }\r\n    function deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )   external\r\n        override\r\n        onlyVault\r\n        nonReentrant {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        _deposit(_asset, _amount);\r\n    }\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        _deposit(address(primaryStable), primaryStable.balanceOf(address(this)));\r\n    }\r\n    \r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1,) = meshSwapPair.getReserves();\r\n\r\n        uint256 lpTokenBalance = meshSwapPair.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            // count amount to unstake\r\n            uint256 totalLpBalance = meshSwapPair.totalSupply();\r\n            uint256 lpTokensToWithdraw = _getAmountLpTokensToWithdraw(\r\n                OvnMath.addBasisPoints(_amount, BASIS_POINTS_FOR_SLIPPAGE),\r\n                reserve0,\r\n                reserve1,\r\n                totalLpBalance,\r\n                assetToDenominator[address(token0)],\r\n                assetToDenominator[address(token1)],\r\n                poolId,\r\n                token0,\r\n                token1\r\n            );\r\n            if (lpTokensToWithdraw > lpTokenBalance) {\r\n                lpTokensToWithdraw = lpTokenBalance;\r\n            }\r\n            uint256 amountOutToken0Min = reserve0 * lpTokensToWithdraw / totalLpBalance;\r\n            uint256 amountOutToken1Min = reserve1 * lpTokensToWithdraw / totalLpBalance;\r\n             // console.log(\"lpTokensToWithdraw: \", lpTokensToWithdraw);\r\n\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(meshSwapPair),\r\n                lpTokensToWithdraw,\r\n                OvnMath.subBasisPoints(amountOutToken0Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(amountOutToken1Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n\r\n        _swapAssetsToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n         // console.log(\"Withdraw USDC: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(_beneficiary, primaryStableBalance);\r\n    }\r\n\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant  {\r\n         // console.log(\"withdrawAll\");\r\n        (uint256 reserve0, uint256 reserve1,) = meshSwapPair.getReserves();\r\n        uint256 lpTokenBalance = meshSwapPair.balanceOf(address(this));\r\n         // console.log(\"Token0 Balance: \", token0.balanceOf(address(this)));\r\n         // console.log(\"Token1 Balance: \", token1.balanceOf(address(this)));\r\n         // console.log(\"LP Token Balance: \", meshSwapPair.balanceOf(address(this)));\r\n        if (lpTokenBalance > 0) {\r\n            uint256 totalLpBalance = meshSwapPair.totalSupply();\r\n            uint256 amountOutToken0Min = reserve0 * lpTokenBalance / totalLpBalance;\r\n            uint256 amountOutToken1Min = reserve1 * lpTokenBalance / totalLpBalance;\r\n\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(meshSwapPair),\r\n                lpTokenBalance,\r\n                OvnMath.subBasisPoints(amountOutToken0Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(amountOutToken1Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n         // console.log(\"Token0 Balance: \", token0.balanceOf(address(this)));\r\n         // console.log(\"Token1 Balance: \", token1.balanceOf(address(this)));\r\n         // console.log(\"LP Token Balance: \", meshSwapPair.balanceOf(address(this)));\r\n        _swapAssetsToPrimaryStable();\r\n\r\n         // console.log(\"After removing liquidity  primaryStableBalance:\",primaryStable.balanceOf(address(this)));\r\n         // console.log(\"After removing liquidity token0Balance:\", token0.balanceOf(address(this)));\r\n         // console.log(\"After removing liquidity token1Balance:\", token1.balanceOf(address(this)) );\r\n         // console.log(\"After removing liquidity meshSwapPair:\", meshSwapPair.balanceOf(address(this)));\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n         // console.log(\"Withdraw Primary Stable: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        _collectRewards();\r\n    }\r\n    function _totalValue(bool nav) internal view returns (uint256) {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n         // console.log(\"primaryStableBalance: \", primaryStableBalance);\r\n        uint256 lpTokenBalance = meshSwapPair.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            uint256 totalLpBalance = meshSwapPair.totalSupply();\r\n            (uint256 reserve0, uint256 reserve1,) = meshSwapPair.getReserves();\r\n            token0Balance += reserve0 * lpTokenBalance / totalLpBalance;\r\n            token1Balance += reserve1 * lpTokenBalance / totalLpBalance;\r\n        }\r\n         // console.log(\"token0Balance: \", token0Balance);\r\n         // console.log(\"token1Balance: \", token1Balance);\r\n        uint256 primaryStableBalanceFromToken0;\r\n        if ( (address(token0) != address(primaryStable))  ) {\r\n            if (token0Balance > 0) {\r\n                if (nav) {\r\n                    uint256 pricePrimaryStable = uint256(IPriceFeed(assetToChainlink[address(primaryStable)]).latestAnswer());\r\n                     // console.log(\"Token0 oracle -  pricePrimaryStable \", pricePrimaryStable);\r\n                    uint256 pricetoken0 = uint256(IPriceFeed(assetToChainlink[address(token0)]).latestAnswer());\r\n                     // console.log(\"Token0 oracle -  pricetoken0 \", pricetoken0);\r\n                    primaryStableBalanceFromToken0 = (token0Balance * assetToDenominator[address(primaryStable)] * pricetoken0) / (assetToDenominator[address(token0)] * pricePrimaryStable);\r\n                     // console.log(\"Token0 oracle -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken0);\r\n                } else {\r\n                     // console.log(\"Token0 swap -  token0Balance \", token0Balance);\r\n\r\n                    primaryStableBalanceFromToken0 = onSwap(\r\n                        poolId,\r\n                        IVault.SwapKind.GIVEN_IN,\r\n                        token0,\r\n                        primaryStable,\r\n                        token0Balance\r\n                    );\r\n                     // console.log(\"Token0 swap -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken0);\r\n\r\n                }\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken0 += token0Balance;\r\n        }\r\n\r\n        uint256 primaryStableBalanceFromToken1;\r\n        if ( (address(token1) != address(primaryStable))  ) {\r\n            if (token1Balance > 0) {\r\n                if (nav) {\r\n                    uint256 pricePrimaryStable = uint256(IPriceFeed(assetToChainlink[address(primaryStable)]).latestAnswer());\r\n                     // console.log(\"Token1 oracle -  pricePrimaryStable \", pricePrimaryStable);\r\n                    uint256 pricetoken1 = uint256(IPriceFeed(assetToChainlink[address(token1)]).latestAnswer());\r\n                     // console.log(\"Token1 oracle -  pricetoken0 \", pricetoken1);\r\n                    primaryStableBalanceFromToken1 = (token1Balance * assetToDenominator[address(primaryStable)] * pricetoken1) / (assetToDenominator[address(token1)] * pricePrimaryStable);\r\n                     // console.log(\"Token1 oracle -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken1);\r\n                } else {\r\n                     // console.log(\"Token1 swap -  token1Balance \", token1Balance);\r\n                    primaryStableBalanceFromToken1 = onSwap(\r\n                        poolId,\r\n                        IVault.SwapKind.GIVEN_IN,\r\n                        token1,\r\n                        primaryStable,\r\n                        token1Balance\r\n                    );\r\n                     // console.log(\"Token1 swap -  primaryStableBalanceFromToken1 \", primaryStableBalanceFromToken1);\r\n                }\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken1 += token1Balance;\r\n        }\r\n         // console.log(\"primaryStableBalanceFromToken0: \", primaryStableBalanceFromToken0);\r\n         // console.log(\"primaryStableBalanceFromToken1: \", primaryStableBalanceFromToken1);\r\n        return primaryStableBalanceFromToken0 + primaryStableBalanceFromToken1 + primaryStableBalance;\r\n    }\r\n    function netAssetValue() external view  returns (uint256) {\r\n        return _totalValue(true);\r\n    }\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _totalValue(false);\r\n    }\r\n\r\n    function _collectRewards() internal {\r\n         // console.log(\"Starting collection of rewards\");\r\n        // claim rewards\r\n        meshSwapPair.claimReward();\r\n         // console.log(\"claimStakingRewards called\");\r\n        // sell rewards\r\n        uint256 totalUsdc;\r\n        uint256 meshBalance = meshToken.balanceOf(address(this));\r\n        if (meshBalance > 10 ** 13) {\r\n            uint256 meshUsdc = _swapExactTokensForTokens(\r\n                address(meshToken),\r\n                address(primaryStable),\r\n                meshBalance,\r\n                address(this)\r\n            );\r\n            totalUsdc += meshUsdc;\r\n        } else {\r\n             // console.log(\"Not enough mesh tokens to sell\");\r\n        }\r\n        uint256 balance = primaryStable.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                address(primaryStable),\r\n                balance\r\n            );\r\n            primaryStable.transfer(harvesterAddress, balance);\r\n        }\r\n    }\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        _collectRewards();\r\n    }\r\n    function _swapAssetsToPrimaryStable() internal {\r\n        if ( (address(token0) != address(primaryStable)) && (token0.balanceOf(address(this)) > 0) )  {\r\n             // console.log(\"Swapping token0\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token0)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token0.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n        if ( (address(token1) != address(primaryStable)) && (token1.balanceOf(address(this)) > 0) )  {\r\n             // console.log(\"Swapping token1\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token1)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token1.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n    }\r\n    function _swapPrimaryStableToToken0() internal {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        if (address(primaryStable) != address(token0)) {\r\n            swap(\r\n                poolId, \r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(primaryStable)),\r\n                IAsset(address(token0)),\r\n                address(this),\r\n                address(this),\r\n                primaryStableBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _asset == address(primaryStable);\r\n    }\r\n    function safeApproveAllTokens() external override {\r\n        // NOT NEEDED\r\n    }\r\n    function _abstractSetPToken(address _asset, address _cToken) internal override\r\n    {\r\n        // NOT NEEDED\r\n    }\r\n}\r\n"
    },
    "contracts/exchanges/UniswapV2Exchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../connectors/uniswap/v2/interfaces/IUniswapV2Router02.sol\";\nimport \"../utils/OvnMath.sol\";\nabstract contract UniswapV2Exchange {\n\n    uint256 public constant BASIS_POINTS_FOR_SLIPPAGE = 4;\n\n    IUniswapV2Router02 private uniswapRouter;\n\n    function _setUniswapRouter(address _uniswapRouter) internal {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    function _swapExactTokensForTokens(\n        address inputToken,\n        address outputToken,\n        uint256 amountInput,\n        address recipient\n    ) internal returns (uint256) {\n\n        IERC20(inputToken).approve(address(uniswapRouter), amountInput);\n\n        uint256 amountOutMin = _getAmountsOut(inputToken, outputToken, amountInput);\n        if (amountOutMin == 0) {\n            return 0;\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = inputToken;\n        path[1] = outputToken;\n\n        uint[] memory amounts = uniswapRouter.swapExactTokensForTokens(\n            amountInput,\n            OvnMath.subBasisPoints(amountOutMin, BASIS_POINTS_FOR_SLIPPAGE),\n            path,\n            recipient,\n            block.timestamp + 600\n        );\n\n        return amounts[1];\n    }\n\n    function _getAmountsOut(\n        address inputToken,\n        address outputToken,\n        uint256 amountInput\n    ) internal view returns (uint256) {\n\n        address[] memory path = new address[](2);\n        path[0] = inputToken;\n        path[1] = outputToken;\n        uint[] memory amounts = uniswapRouter.getAmountsOut(amountInput, path);\n        return amounts[1];\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to\n    ) internal returns (uint amountA, uint amountB, uint liquidity) {\n\n        IERC20(tokenA).approve(address(uniswapRouter), amountADesired);\n        IERC20(tokenB).approve(address(uniswapRouter), amountBDesired);\n\n        return uniswapRouter.addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin,\n            to,\n            block.timestamp + 600\n        );\n    }\n\n    function _removeLiquidity(\n        address tokenA,\n        address tokenB,\n        address lpToken,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to\n    ) internal returns (uint amountA, uint amountB) {\n\n        IERC20(lpToken).approve(address(uniswapRouter), liquidity);\n\n        return uniswapRouter.removeLiquidity(\n            tokenA,\n            tokenB,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            block.timestamp + 600\n        );\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/utils/AaveBorrowLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../connectors/aave/interfaces/IPoolAddressesProvider.sol\";\nimport \"../connectors/aave/interfaces/IPriceFeed.sol\";\nimport \"../connectors/aave/interfaces/IPool.sol\";\nimport '../connectors/uniswap/v3/libraries/FullMath.sol';\nimport \"hardhat/console.sol\";\n\n\nlibrary AaveBorrowLibrary {\n\n    function getAavePool(\n        address aavePoolAddressesProvider,\n        uint8 eModeCategoryId\n    ) internal returns (address aavePool) {\n        aavePool = IPoolAddressesProvider(aavePoolAddressesProvider).getPool();\n        IPool(aavePool).setUserEMode(eModeCategoryId);\n    }\n\n    function getAavePool(\n        address aavePoolAddressesProvider\n    ) internal view returns (address aavePool) {\n        aavePool = IPoolAddressesProvider(aavePoolAddressesProvider).getPool();\n    }\n\n    function getCollateralAndBorrowForSupplyAndBorrow(\n        uint256 amount0,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 LT,\n        uint256 HF,\n        uint256 token0Denominator,\n        uint256 token1Denominator,\n        uint256 price0,\n        uint256 price1\n    ) internal pure returns (uint256 collateral0, uint256 borrow1) {\n        uint256 reserve1InToken0 = convertTokenAmountToTokenAmount(reserve1, token1Denominator, token0Denominator, price1, price0);\n        collateral0 = amount0 * HF / (HF + LT * reserve0 / reserve1InToken0);\n        uint256 collateral1 = convertTokenAmountToTokenAmount(collateral0, token0Denominator, token1Denominator, price0, price1);\n        borrow1 = collateral1 * LT / HF;\n    }\n\n    function getBorrowForWithdraw(\n        uint256 collateral0,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 LT,\n        uint256 HF,\n        uint256 token0Denominator,\n        uint256 token1Denominator,\n        uint256 price0,\n        uint256 price1\n    ) internal pure returns (uint256 borrow1) {\n        uint256 collateral1 = convertTokenAmountToTokenAmount(collateral0, token0Denominator, token1Denominator, price0, price1);\n        //usdc to usdt\n        uint256 reserve1InToken0 = convertTokenAmountToTokenAmount(reserve1, token1Denominator, token0Denominator, price1, price0);\n        //usdt to usdc\n        borrow1 = (collateral1 * LT * reserve1InToken0) / (HF * reserve1InToken0 + LT * reserve0);\n    }\n\n    // function getBorrowForWithdraw(\n    //     uint256 collateral0,\n    //     uint256 totalCollateralUsd,\n    //     uint256 totalBorrowUsd,\n    //     uint256 reserve0,\n    //     uint256 reserve1,\n    //     uint256 LT,\n    //     uint256 HF,\n    //     uint256 token0Denominator,\n    //     uint256 token1Denominator,\n    //     uint256 price0,\n    //     uint256 price1\n    // ) internal pure returns (uint256 borrow1) {\n    //     uint256 totalBorrowUsd1 = convertUsdToTokenAmount(totalBorrowUsd, token1Denominator, price1);   //usd to usdt\n    //     uint256 totalCollateralUsd1 = convertUsdToTokenAmount(totalCollateralUsd, token1Denominator, price1); //usd to usdt\n    //     uint256 collateral1 = convertTokenAmountToTokenAmount(collateral0, token0Denominator, token1Denominator, price0, price1); //usdc to usdt\n    //     uint256 reserve1InToken0 = convertTokenAmountToTokenAmount(reserve1, token1Denominator, token0Denominator, price1, price0); //usdt to usdc\n    //     borrow1 = (totalBorrowUsd1 * HF + collateral1 * LT - totalCollateralUsd1 * LT) / (HF + LT * reserve0 / reserve1InToken0);\n    // }\n\n    // function getLpTokensForWithdraw(\n    //     uint256 totalLpBalance,\n    //     uint256 borrow1,\n    //     uint256 reserve0,\n    //     uint256 reserve1,\n    //     uint256 token0Denominator,\n    //     uint256 token1Denominator,\n    //     uint256 price0,\n    //     uint256 price1\n    // ) internal pure returns (uint256 lpTokensToWithdraw) {\n    //     uint256 borrow0 = convertTokenAmountToTokenAmount(borrow1, token1Denominator, token0Denominator, price1, price0);\n    //     uint256 reserve1InToken0 = convertTokenAmountToTokenAmount(reserve1, token1Denominator, token0Denominator, price1, price0);\n    //     lpTokensToWithdraw = totalLpBalance * (borrow0 + borrow1 * reserve0 / reserve1) / (reserve0 + reserve1InToken0);\n    // }\n\n    struct GetWithdrawAmountForBalanceParams {\n        uint256 totalCollateralUsd;\n        uint256 totalBorrowUsd;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 LT;\n        uint256 HF;\n        uint256 token0Denominator;\n        uint256 token1Denominator;\n        uint256 price0;\n        uint256 price1;\n    }\n\n    function getWithdrawAmountForBalance(\n        GetWithdrawAmountForBalanceParams memory params\n    ) internal pure returns (uint256 withdrawAmount) {\n        uint256 reserve1InUsd = convertTokenAmountToUsd(params.reserve1, params.token1Denominator, params.price1);\n        uint256 reserve0InUsd = convertTokenAmountToUsd(params.reserve0, params.token0Denominator, params.price0);\n        withdrawAmount = FullMath.mulDivRoundingUp(\n            params.reserve0, \n            params.totalCollateralUsd * params.LT - params.totalBorrowUsd * params.HF, \n            reserve1InUsd * params.HF + reserve0InUsd * params.LT\n        );\n    }\n\n    function getBorrowIfZeroAmountForBalance(\n        GetWithdrawAmountForBalanceParams memory params\n    ) internal pure returns (uint256 withdrawAmount) {\n        withdrawAmount = (params.totalCollateralUsd * params.LT - params.totalBorrowUsd * params.HF) / (params.HF);\n        withdrawAmount = convertUsdToTokenAmount(withdrawAmount, params.token1Denominator, params.price1);\n    }\n\n    struct GetLpTokensForBalanceParams {\n        uint256 totalCollateralUsd;\n        uint256 totalBorrowUsd;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 LT;\n        uint256 HF;\n        uint256 token0Denominator;\n        uint256 token1Denominator;\n        uint256 price0;\n        uint256 price1;\n        uint256 totalSuply;\n    }\n\n    function getLpTokensForBalance(\n        GetLpTokensForBalanceParams memory params\n    ) internal pure returns (uint256 lpTokens) {\n        uint256 reserve1InUsd = convertTokenAmountToUsd(params.reserve1, params.token1Denominator, params.price1);\n        uint256 reserve0InUsd = convertTokenAmountToUsd(params.reserve0, params.token0Denominator, params.price0);\n        lpTokens = FullMath.mulDivRoundingUp(\n            params.totalSuply, \n            params.totalBorrowUsd * params.HF - params.totalCollateralUsd * params.LT, \n            reserve1InUsd * params.HF + reserve0InUsd * params.LT\n        );\n    }\n\n    function convertTokenAmountToTokenAmount(\n        uint256 amount0,\n        uint256 token0Denominator,\n        uint256 token1Denominator,\n        uint256 price0,\n        uint256 price1\n    ) internal pure returns (uint256 amount1) {\n        amount1 = (amount0 * token1Denominator * price0) / (token0Denominator * price1);\n    }\n\n    function convertTokenAmountToUsd(\n        uint256 amount,\n        uint256 tokenDenominator,\n        uint256 price\n    ) internal pure returns (uint256 amountUsd) {\n        amountUsd = amount * price / tokenDenominator;\n    }\n\n    function convertUsdToTokenAmount(\n        uint256 amountUsd,\n        uint256 tokenDenominator,\n        uint256 price\n    ) internal pure returns (uint256 amount) {\n        amount = amountUsd * tokenDenominator / price;\n    }\n\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPriceFeed {\r\n  function latestAnswer() external view returns (int256);\r\n}"
    },
    "contracts/interfaces/IMeshSwapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5 <0.9.0;\r\n\r\nimport \"../connectors/uniswap/v2/interfaces/IUniswapV2Pair.sol\";\r\n\r\ninterface IMeshSwapLP is IUniswapV2Pair {\r\n\r\n    function depositToken(uint256 _amount) external;\r\n\r\n    function withdrawToken(uint256 withdrawAmount) external;\r\n    function withdrawTokenByAmount(uint256 withdrawAmount) external;\r\n\r\n    function claimReward() external;\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n}"
    },
    "contracts/connectors/uniswap/v2/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\npragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\n/**\n * IUniswapV2Router02.sol is copy of https://github.com/Uniswap/v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\n */\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function pairFor(address factoryC, address tokenA, address tokenB) external view returns (address pair) ;\n\n}\n"
    },
    "contracts/connectors/uniswap/v2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\npragma solidity >=0.6.2;\n\n/**\n * IUniswapV2Router01.sol is copy of https://github.com/Uniswap/v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\n */\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n\n}\n"
    },
    "contracts/connectors/aave/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title IPoolAddressesProvider\r\n * @author Aave\r\n * @notice Defines the basic interface for a Pool Addresses Provider.\r\n **/\r\ninterface IPoolAddressesProvider {\r\n  /**\r\n   * @dev Emitted when the market identifier is updated.\r\n   * @param oldMarketId The old id of the market\r\n   * @param newMarketId The new id of the market\r\n   */\r\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\r\n\r\n  /**\r\n   * @dev Emitted when the pool is updated.\r\n   * @param oldAddress The old address of the Pool\r\n   * @param newAddress The new address of the Pool\r\n   */\r\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the pool configurator is updated.\r\n   * @param oldAddress The old address of the PoolConfigurator\r\n   * @param newAddress The new address of the PoolConfigurator\r\n   */\r\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the price oracle is updated.\r\n   * @param oldAddress The old address of the PriceOracle\r\n   * @param newAddress The new address of the PriceOracle\r\n   */\r\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the ACL manager is updated.\r\n   * @param oldAddress The old address of the ACLManager\r\n   * @param newAddress The new address of the ACLManager\r\n   */\r\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the ACL admin is updated.\r\n   * @param oldAddress The old address of the ACLAdmin\r\n   * @param newAddress The new address of the ACLAdmin\r\n   */\r\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the price oracle sentinel is updated.\r\n   * @param oldAddress The old address of the PriceOracleSentinel\r\n   * @param newAddress The new address of the PriceOracleSentinel\r\n   */\r\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the pool data provider is updated.\r\n   * @param oldAddress The old address of the PoolDataProvider\r\n   * @param newAddress The new address of the PoolDataProvider\r\n   */\r\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when a new proxy is created.\r\n   * @param id The identifier of the proxy\r\n   * @param proxyAddress The address of the created proxy contract\r\n   * @param implementationAddress The address of the implementation contract\r\n   */\r\n  event ProxyCreated(\r\n    bytes32 indexed id,\r\n    address indexed proxyAddress,\r\n    address indexed implementationAddress\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a new non-proxied contract address is registered.\r\n   * @param id The identifier of the contract\r\n   * @param oldAddress The address of the old contract\r\n   * @param newAddress The address of the new contract\r\n   */\r\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\r\n\r\n  /**\r\n   * @dev Emitted when the implementation of the proxy registered with id is updated\r\n   * @param id The identifier of the contract\r\n   * @param proxyAddress The address of the proxy contract\r\n   * @param oldImplementationAddress The address of the old implementation contract\r\n   * @param newImplementationAddress The address of the new implementation contract\r\n   */\r\n  event AddressSetAsProxy(\r\n    bytes32 indexed id,\r\n    address indexed proxyAddress,\r\n    address oldImplementationAddress,\r\n    address indexed newImplementationAddress\r\n  );\r\n\r\n  /**\r\n   * @notice Returns the id of the Aave market to which this contract points to.\r\n   * @return The market id\r\n   **/\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  /**\r\n   * @notice Associates an id with a specific PoolAddressesProvider.\r\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\r\n   * identify and validate multiple Aave markets.\r\n   * @param newMarketId The market id\r\n   */\r\n  function setMarketId(string calldata newMarketId) external;\r\n\r\n  /**\r\n   * @notice Returns an address by its identifier.\r\n   * @dev The returned address might be an EOA or a contract, potentially proxied\r\n   * @dev It returns ZERO if there is no registered address with the given id\r\n   * @param id The id\r\n   * @return The address of the registered for the specified id\r\n   */\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  /**\r\n   * @notice General function to update the implementation of a proxy registered with\r\n   * certain `id`. If there is no proxy registered, it will instantiate one and\r\n   * set as implementation the `newImplementationAddress`.\r\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n   * setter function, in order to avoid unexpected consequences\r\n   * @param id The id\r\n   * @param newImplementationAddress The address of the new implementation\r\n   */\r\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\r\n\r\n  /**\r\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\r\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\r\n   * @param id The id\r\n   * @param newAddress The address to set\r\n   */\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the Pool proxy.\r\n   * @return The Pool proxy address\r\n   **/\r\n  function getPool() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the implementation of the Pool, or creates a proxy\r\n   * setting the new `pool` implementation when the function is called for the first time.\r\n   * @param newPoolImpl The new Pool implementation\r\n   **/\r\n  function setPoolImpl(address newPoolImpl) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the PoolConfigurator proxy.\r\n   * @return The PoolConfigurator proxy address\r\n   **/\r\n  function getPoolConfigurator() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\r\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\r\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\r\n   **/\r\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the price oracle.\r\n   * @return The address of the PriceOracle\r\n   */\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the price oracle.\r\n   * @param newPriceOracle The address of the new PriceOracle\r\n   */\r\n  function setPriceOracle(address newPriceOracle) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the ACL manager.\r\n   * @return The address of the ACLManager\r\n   */\r\n  function getACLManager() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the ACL manager.\r\n   * @param newAclManager The address of the new ACLManager\r\n   **/\r\n  function setACLManager(address newAclManager) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the ACL admin.\r\n   * @return The address of the ACL admin\r\n   */\r\n  function getACLAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the ACL admin.\r\n   * @param newAclAdmin The address of the new ACL admin\r\n   */\r\n  function setACLAdmin(address newAclAdmin) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the price oracle sentinel.\r\n   * @return The address of the PriceOracleSentinel\r\n   */\r\n  function getPriceOracleSentinel() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the price oracle sentinel.\r\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\r\n   **/\r\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\r\n\r\n  /**\r\n   * @notice Returns the address of the data provider.\r\n   * @return The address of the DataProvider\r\n   */\r\n  function getPoolDataProvider() external view returns (address);\r\n\r\n  /**\r\n   * @notice Updates the address of the data provider.\r\n   * @param newDataProvider The address of the new DataProvider\r\n   **/\r\n  function setPoolDataProvider(address newDataProvider) external;\r\n}"
    },
    "contracts/connectors/aave/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IPriceFeed {\n  function latestAnswer() external view returns (int256);\n}"
    },
    "contracts/connectors/aave/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\r\nimport {DataTypes} from '../protocol/DataTypes.sol';\r\n\r\n/**\r\n * @title IPool\r\n * @author Aave\r\n * @notice Defines the basic interface for an Aave Pool.\r\n **/\r\ninterface IPool {\r\n  /**\r\n   * @dev Emitted on mintUnbacked()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the supply\r\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\r\n   * @param amount The amount of supplied assets\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event MintUnbacked(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on backUnbacked()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param backer The address paying for the backing\r\n   * @param amount The amount added as backing\r\n   * @param fee The amount paid in fees\r\n   **/\r\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\r\n\r\n  /**\r\n   * @dev Emitted on supply()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the supply\r\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\r\n   * @param amount The amount supplied\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event Supply(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlying asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to The address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   **/\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    DataTypes.InterestRateMode interestRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\r\n   **/\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount,\r\n    bool useATokens\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on swapBorrowRateMode()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user swapping his rate mode\r\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n   **/\r\n  event SwapBorrowRateMode(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    DataTypes.InterestRateMode interestRateMode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param totalDebt The total isolation mode debt for the reserve\r\n   */\r\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\r\n\r\n  /**\r\n   * @dev Emitted when the user selects a certain asset category for eMode\r\n   * @param user The address of the user\r\n   * @param categoryId The category id\r\n   **/\r\n  event UserEModeSet(address indexed user, uint8 categoryId);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on rebalanceStableBorrowRate()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user for which the rebalance has been executed\r\n   **/\r\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    DataTypes.InterestRateMode interestRateMode,\r\n    uint256 premium,\r\n    uint16 indexed referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated.\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The next liquidity rate\r\n   * @param stableBorrowRate The next stable borrow rate\r\n   * @param variableBorrowRate The next variable borrow rate\r\n   * @param liquidityIndex The next liquidity index\r\n   * @param variableBorrowIndex The next variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\r\n   * @param reserve The address of the reserve\r\n   * @param amountMinted The amount minted to the treasury\r\n   **/\r\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\r\n\r\n  /**\r\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\r\n   * @param asset The address of the underlying asset to mint\r\n   * @param amount The amount to mint\r\n   * @param onBehalfOf The address that will receive the aTokens\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function mintUnbacked(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\r\n   * @param asset The address of the underlying asset to back\r\n   * @param amount The amount to back\r\n   * @param fee The amount paid in fees\r\n   **/\r\n  function backUnbacked(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 fee\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function supply(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\r\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param deadline The deadline timestamp that the permit is valid\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param permitV The V parameter of ERC712 permit sig\r\n   * @param permitR The R parameter of ERC712 permit sig\r\n   * @param permitS The S parameter of ERC712 permit sig\r\n   **/\r\n  function supplyWithPermit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode,\r\n    uint256 deadline,\r\n    uint8 permitV,\r\n    bytes32 permitR,\r\n    bytes32 permitS\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to The address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\r\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @param deadline The deadline timestamp that the permit is valid\r\n   * @param permitV The V parameter of ERC712 permit sig\r\n   * @param permitR The R parameter of ERC712 permit sig\r\n   * @param permitS The S parameter of ERC712 permit sig\r\n   * @return The final amount repaid\r\n   **/\r\n  function repayWithPermit(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    address onBehalfOf,\r\n    uint256 deadline,\r\n    uint8 permitV,\r\n    bytes32 permitR,\r\n    bytes32 permitS\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\r\n   * equivalent debt tokens\r\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\r\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\r\n   * balance is not enough to cover the whole debt\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @return The final amount repaid\r\n   **/\r\n  function repayWithATokens(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n   **/\r\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\r\n\r\n  /**\r\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\r\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   **/\r\n  function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n  /**\r\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\r\n   * @param asset The address of the underlying asset supplied\r\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n   * into consideration. For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts of the assets being flash-borrowed\r\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata interestRateModes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n   * into consideration. For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\r\n   * @param asset The address of the asset being flash-borrowed\r\n   * @param amount The amount of the asset being flash-borrowed\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoanSimple(\r\n    address receiverAddress,\r\n    address asset,\r\n    uint256 amount,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\r\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\r\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\r\n   * @return currentLiquidationThreshold The liquidation threshold of the user\r\n   * @return ltv The loan to value of The user\r\n   * @return healthFactor The current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n  external\r\n  view\r\n  returns (\r\n    uint256 totalCollateralBase,\r\n    uint256 totalDebtBase,\r\n    uint256 availableBorrowsBase,\r\n    uint256 currentLiquidationThreshold,\r\n    uint256 ltv,\r\n    uint256 healthFactor\r\n  );\r\n\r\n  /**\r\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n   * interest rate strategy\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function initReserve(\r\n    address asset,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Drop a reserve\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   **/\r\n  function dropReserve(address asset) external;\r\n\r\n  /**\r\n   * @notice Updates the address of the interest rate strategy contract\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\r\n  external;\r\n\r\n  /**\r\n   * @notice Sets the configuration bitmap of the reserve as a whole\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param configuration The new configuration bitmap\r\n   **/\r\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\r\n  external;\r\n\r\n  /**\r\n   * @notice Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n  external\r\n  view\r\n  returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @notice Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n  external\r\n  view\r\n  returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @notice Returns the normalized income normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state and configuration data of the reserve\r\n   **/\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  /**\r\n   * @notice Validates and finalizes an aToken transfer\r\n   * @dev Only callable by the overlying aToken of the `asset`\r\n   * @param asset The address of the underlying asset of the aToken\r\n   * @param from The user from which the aTokens are transferred\r\n   * @param to The user receiving the aTokens\r\n   * @param amount The amount being transferred/withdrawn\r\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n   */\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromBefore,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Returns the list of the underlying assets of all the initialized reserves\r\n   * @dev It does not include dropped reserves\r\n   * @return The addresses of the underlying assets of the initialized reserves\r\n   **/\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  /**\r\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\r\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\r\n   * @return The address of the reserve associated with id\r\n   **/\r\n  function getReserveAddressById(uint16 id) external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the PoolAddressesProvider connected to this contract\r\n   * @return The address of the PoolAddressesProvider\r\n   **/\r\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\r\n\r\n  /**\r\n   * @notice Updates the protocol fee on the bridging\r\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\r\n   */\r\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\r\n\r\n  /**\r\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\r\n   * - A part is sent to aToken holders as extra, one time accumulated interest\r\n   * - A part is collected by the protocol treasury\r\n   * @dev The total premium is calculated on the total borrowed amount\r\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\r\n   * @dev Only callable by the PoolConfigurator contract\r\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\r\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\r\n   */\r\n  function updateFlashloanPremiums(\r\n    uint128 flashLoanPremiumTotal,\r\n    uint128 flashLoanPremiumToProtocol\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Configures a new category for the eMode.\r\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\r\n   * The category 0 is reserved as it's the default for volatile assets\r\n   * @param id The id of the category\r\n   * @param config The configuration of the category\r\n   */\r\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\r\n\r\n  /**\r\n   * @notice Returns the data of an eMode category\r\n   * @param id The id of the category\r\n   * @return The configuration data of the category\r\n   */\r\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\r\n\r\n  /**\r\n   * @notice Allows a user to use the protocol in eMode\r\n   * @param categoryId The id of the category\r\n   */\r\n  function setUserEMode(uint8 categoryId) external;\r\n\r\n  /**\r\n   * @notice Returns the eMode the user is using\r\n   * @param user The address of the user\r\n   * @return The eMode id\r\n   */\r\n  function getUserEMode(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Resets the isolation mode total debt of the given asset to zero\r\n   * @dev It requires the given asset has zero debt ceiling\r\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\r\n   */\r\n  function resetIsolationModeTotalDebt(address asset) external;\r\n\r\n  /**\r\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n   * @return The percentage of available liquidity to borrow, expressed in bps\r\n   */\r\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the total fee on flash loans\r\n   * @return The total fee on flashloans\r\n   */\r\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\r\n\r\n  /**\r\n   * @notice Returns the part of the bridge fees sent to protocol\r\n   * @return The bridge fee sent to the protocol treasury\r\n   */\r\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the part of the flashloan fees sent to protocol\r\n   * @return The flashloan fee sent to the protocol treasury\r\n   */\r\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\r\n\r\n  /**\r\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\r\n   * @return The maximum number of reserves supported\r\n   */\r\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\r\n\r\n  /**\r\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\r\n   * @param assets The list of reserves for which the minting needs to be executed\r\n   **/\r\n  function mintToTreasury(address[] calldata assets) external;\r\n\r\n  /**\r\n   * @notice Rescue and transfer tokens locked in this contract\r\n   * @param token The address of the token\r\n   * @param to The address of the recipient\r\n   * @param amount The amount of token to transfer\r\n   */\r\n  function rescueTokens(\r\n    address token,\r\n    address to,\r\n    uint256 amount\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n   * @dev Deprecated: Use the `supply` function instead\r\n   * @param asset The address of the underlying asset to supply\r\n   * @param amount The amount to be supplied\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n}"
    },
    "contracts/connectors/uniswap/v3/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/connectors/aave/protocol/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}"
    },
    "contracts/connectors/uniswap/v2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/strategies/QuickSwapStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title QuickSwap Strategy\r\n * @notice Investment strategy for investing stablecoins via QuickSwap Strategy\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"  ;\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport \"../exchanges/UniswapV2Exchange.sol\";\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport \"../connectors/uniswap/v2/interfaces/IUniswapV2Router02.sol\";\r\nimport \"../connectors/quickswap/IStakingRewards.sol\";\r\nimport \"../connectors/uniswap/v2/interfaces/IUniswapV2Pair.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract QuickSwapStrategy is InitializableAbstractStrategy, UniswapV2Exchange, BalancerExchange   {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n\r\n    IERC20 public token0;\r\n    IERC20 public token1;\r\n    IERC20 public primaryStable;\r\n    IERC20 public quickTokenNew;\r\n    IERC20 public quickDragon;\r\n\r\n    IUniswapV2Pair public quickSwapPair;\r\n    bytes32 public poolId;\r\n\r\n    mapping(address => uint256 ) public assetToDenominator;\r\n    IStakingRewards public quickSwapPairStaker;\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as QuickSwap strategies don't fit\r\n     * well within that abstraction.\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // QuickToken address\r\n        address _vaultAddress,    // VaultProxy address\r\n        address[] calldata _rewardTokenAddresses, // USDC - as in end USDC will be sent to Harvester\r\n        address[] calldata _assets, // USDC + DAI\r\n        address[] calldata _pTokens, //  quickSwapUSDCDAIPair\r\n        address _primaryStable, // USDC address\r\n        address _router, // quickSwapRouter02\r\n        address _staker, // quickSwapStakingReward\r\n        address _rewardToken // quickSwapDragonQuick\r\n    ) external onlyGovernor initializer {\r\n        require(_rewardTokenAddresses[0] != address(0), \"Zero address not allowed\");\r\n        require(_pTokens[0] != address(0), \"Zero address not allowed\");\r\n        require(_platformAddress != address(0), \"Zero address not allowed\");\r\n        require(_router != address(0), \"Zero address not allowed\");\r\n        require(_staker != address(0), \"Zero address not allowed\");\r\n        require(_rewardToken != address(0), \"Zero address not allowed\");\r\n       \r\n\r\n        token0 = IERC20(_assets[0]);\r\n        token1 = IERC20(_assets[1]);\r\n        primaryStable = IERC20(_primaryStable);\r\n        quickTokenNew = IERC20(_platformAddress);\r\n        quickDragon = IERC20(_rewardToken);\r\n\r\n        uint256 assetCount = _assets.length;\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            assetToDenominator[_assets[i]] = 10 ** IERC20Metadata(_assets[i]).decimals();\r\n        }\r\n        quickSwapPair = IUniswapV2Pair(_pTokens[0]);\r\n        quickSwapPairStaker = IStakingRewards(_staker);\r\n        _setUniswapRouter(_router);\r\n\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n        _abstractSetPToken(_assets[0],_pTokens[0]);\r\n        _abstractSetPToken(_assets[1],_pTokens[1]);\r\n    }\r\n    function setBalancer(address _balancerVault, bytes32 _balancerPoolId) external onlyGovernor {\r\n        require(_balancerVault != address(0), \"Zero address not allowed\");\r\n        require(_balancerPoolId != \"\", \"Empty pool id not allowed\");\r\n\r\n        setBalancerVault(_balancerVault);\r\n        poolId = _balancerPoolId;\r\n    }\r\n    function getReserves() internal view returns (uint256,uint256) {\r\n        ( uint256 reserve0, uint256  reserve1,) = quickSwapPair.getReserves();\r\n        require(reserve0 > (10 ** (IERC20Metadata(address(token0) ).decimals() - 3))  && reserve1 > (10 ** (IERC20Metadata(address(token1) ).decimals() - 3)), \"Reserves too low\");\r\n        return (reserve0, reserve1) ;\r\n\r\n    }\r\n    function _deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )  internal {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1) = getReserves();\r\n\r\n        _swapPrimaryStableToToken0();\r\n\r\n        // count amount token1 to swap\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n        uint256 amount0From1;\r\n        if (token1Balance > 0) {\r\n            amount0From1 = onSwap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                token1,\r\n                token0,\r\n                token1Balance\r\n            );\r\n        }\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        //TODO add parameter to _getAmountToSwap() second token amount\r\n        uint256 amount0ToSwap = _getAmountToSwap(\r\n            token0Balance - (amount0From1 / 2),\r\n            reserve0,\r\n            reserve1,\r\n            assetToDenominator[address(token0)],\r\n            assetToDenominator[address(token1)],\r\n            1,\r\n            poolId,\r\n            token0,\r\n            token1\r\n        );\r\n\r\n        // swap token0 to other token\r\n        swap(\r\n            poolId,\r\n            IVault.SwapKind.GIVEN_IN,\r\n            IAsset(address(token0)),\r\n            IAsset(address(token1)),\r\n            address(this),\r\n            address(this),\r\n            amount0ToSwap,\r\n            0\r\n        );\r\n\r\n        // add liquidity\r\n        token0Balance = token0.balanceOf(address(this));\r\n        token1Balance = token1.balanceOf(address(this));\r\n        _addLiquidity(\r\n            address(token0),\r\n            address(token1),\r\n            token0Balance,\r\n            token1Balance,\r\n            OvnMath.subBasisPoints(token0Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            OvnMath.subBasisPoints(token1Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            address(this)\r\n        );\r\n        // console.log(\"LP: \", quickSwapPair.balanceOf(address(this)) );\r\n        stakeLPForDragon();\r\n    }\r\n    function deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )   external\r\n        override\r\n        onlyVault\r\n        nonReentrant {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        _deposit(_asset, _amount);\r\n    }\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        _deposit(address(primaryStable), primaryStable.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1,) = quickSwapPair.getReserves();\r\n        uint256 lpTokenBalance = quickSwapPairStaker.balanceOf(address(this)); //quickSwapPair.balanceOf(address(this));\r\n        // console.log(\"lpTokenBalance: \", lpTokenBalance);\r\n\r\n        if (lpTokenBalance > 0) {\r\n            // count amount to unstake\r\n            uint256 totalLpBalance = quickSwapPair.totalSupply();\r\n            uint256 lpTokensToWithdraw = _getAmountLpTokensToWithdraw(\r\n                OvnMath.addBasisPoints(_amount, BASIS_POINTS_FOR_SLIPPAGE),\r\n                reserve0,\r\n                reserve1,\r\n                totalLpBalance,\r\n                assetToDenominator[address(token0)],\r\n                assetToDenominator[address(token1)],\r\n                poolId,\r\n                token0,\r\n                token1\r\n            );\r\n            if (lpTokensToWithdraw > lpTokenBalance) {\r\n                lpTokensToWithdraw = lpTokenBalance;\r\n            }\r\n            uint256 amountOut0Min = reserve0 * lpTokensToWithdraw / totalLpBalance;\r\n            uint256 amountOut1Min = reserve1 * lpTokensToWithdraw / totalLpBalance;\r\n            // console.log(\"lpTokensToWithdraw: \", lpTokensToWithdraw);\r\n            unstakeDragonForLP(lpTokensToWithdraw);\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(quickSwapPair),\r\n                lpTokensToWithdraw,\r\n                OvnMath.subBasisPoints(amountOut0Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(amountOut1Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n        _swapAssetsToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdraw USDC: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(_beneficiary, primaryStableBalance);\r\n    }\r\n\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant  {\r\n        (uint256 reserve0, uint256 reserve1,) = quickSwapPair.getReserves();\r\n\r\n        unstakeDragonForLP();\r\n        uint256 lpTokenBalance = quickSwapPair.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            uint256 totalLpBalance = quickSwapPair.totalSupply();\r\n            uint256 amountOut0Min = reserve0 * lpTokenBalance / totalLpBalance;\r\n            uint256 amountOut1Min = reserve1 * lpTokenBalance / totalLpBalance;\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(quickSwapPair),\r\n                lpTokenBalance,\r\n                OvnMath.subBasisPoints(amountOut0Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(amountOut1Min, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n        _swapAssetsToPrimaryStable();\r\n\r\n        lpTokenBalance = quickSwapPair.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            stakeLPForDragon();\r\n        }\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdraw Primary Stable: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        _collectRewards();\r\n    }\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n\r\n        uint256 lpTokenBalance = quickSwapPairStaker.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            uint256 totalLpBalance = quickSwapPair.totalSupply();\r\n            (uint256 reserve0, uint256 reserve1,) = quickSwapPair.getReserves();\r\n            token0Balance += reserve0 * lpTokenBalance / totalLpBalance;\r\n            token1Balance += reserve1 * lpTokenBalance / totalLpBalance;\r\n        }\r\n\r\n        uint256 primaryStableBalanceFromToken0;\r\n        if ( (address(token0) != address(primaryStable))  ) {\r\n            if (token0Balance > 0) {\r\n                primaryStableBalanceFromToken0 = onSwap(\r\n                    poolId,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    token0,\r\n                    primaryStable,\r\n                    token0Balance\r\n                );\r\n                // console.log(\"Token0 swap -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken0);\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken0 += token0Balance;\r\n        }\r\n\r\n        uint256 primaryStableBalanceFromToken1;\r\n        if ( (address(token1) != address(primaryStable))  ) {\r\n            if (token1Balance > 0) {\r\n                primaryStableBalanceFromToken1 = onSwap(\r\n                    poolId,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    token1,\r\n                    primaryStable,\r\n                    token1Balance\r\n                );\r\n                // console.log(\"Token1 swap -  primaryStableBalanceFromToken1 \", primaryStableBalanceFromToken1);\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken1 += token1Balance;\r\n        }\r\n        // console.log(\"primaryStableBalanceFromToken0: \", primaryStableBalanceFromToken0);\r\n        // console.log(\"primaryStableBalanceFromToken1: \", primaryStableBalanceFromToken1);\r\n        return primaryStableBalanceFromToken0 + primaryStableBalanceFromToken1;\r\n    }\r\n    function stakeLPForDragon() internal {\r\n        uint256 lpTokenBalance = quickSwapPair.balanceOf(address(this));\r\n        // console.log(\"Staking lpTokenBalance\", lpTokenBalance);\r\n        IUniswapV2Pair(quickSwapPair).approve(address(quickSwapPairStaker), lpTokenBalance);\r\n        quickSwapPairStaker.stake(lpTokenBalance);\r\n        // console.log(\"LP Balance staked: \", quickSwapPairStaker.balanceOf(address(this)));\r\n    }\r\n    function unstakeDragonForLP(uint256 _amount)  internal{\r\n        quickSwapPairStaker.withdraw(_amount);\r\n    }\r\n    function unstakeDragonForLP()  internal {\r\n        quickSwapPairStaker.exit();\r\n    }\r\n    function _collectRewards() internal {\r\n        // claim rewards\r\n        quickSwapPairStaker.getReward();\r\n        // sell rewards\r\n        uint256 totalRewards = 0;\r\n        uint256 quickDragonBalance = quickDragon.balanceOf(address(this));\r\n        if (quickDragonBalance > 0) {\r\n            uint256 quickReward = _swapExactTokensForTokens(\r\n                address(quickDragon),\r\n                address(primaryStable),\r\n                quickDragonBalance,\r\n                address(this)\r\n            );\r\n            totalRewards += quickReward;\r\n        }\r\n        uint256 balance = primaryStable.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                address(primaryStable),\r\n                balance\r\n            );\r\n            primaryStable.transfer(harvesterAddress, balance);\r\n        }\r\n    }\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        _collectRewards();\r\n    }\r\n    function _swapAssetsToPrimaryStable() internal {\r\n        if ( (address(token0) != address(primaryStable)) && (token0.balanceOf(address(this)) > 0) )  {\r\n            // console.log(\"Swapping token0\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token0)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token0.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n        if ( (address(token1) != address(primaryStable)) && (token1.balanceOf(address(this)) > 0) )  {\r\n            // console.log(\"Swapping token1\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token1)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token1.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n    }\r\n    function _swapPrimaryStableToToken0() internal {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        if (address(primaryStable) != address(token0)) {\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(primaryStable)),\r\n                IAsset(address(token0)),\r\n                address(this),\r\n                address(this),\r\n                primaryStableBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n     /**\r\n     * @dev Retuns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _asset == address(primaryStable);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding cToken,\r\n     *      if for some reason is it necessary.\r\n     */\r\n    function safeApproveAllTokens() external override {\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to respond to the addition of new asset / cTokens\r\n     *      We need to approve the cToken and give it permission to spend the asset\r\n     * @param _asset Address of the asset to approve\r\n     * @param _cToken The cToken for the approval\r\n     */\r\n    function _abstractSetPToken(address _asset, address _cToken)\r\n        internal\r\n        override\r\n    {\r\n    }\r\n   \r\n}\r\n"
    },
    "contracts/connectors/quickswap/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GNU-3\r\n\r\npragma solidity >=0.6.2;\r\n\r\n\r\ninterface IStakingRewards {\r\n    // Views\r\n    function lastTimeRewardApplicable() external view returns (uint256);\r\n\r\n    function rewardPerToken() external view returns (uint256);\r\n\r\n    function earned(address account) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Mutative\r\n\r\n    function stake(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function getReward() external;\r\n\r\n    function exit() external;\r\n}"
    },
    "contracts/strategies/MeshSwapStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title MeshSwap Strategy\r\n * @notice Investment strategy for investing stablecoins via NeshSwap Strategy\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"  ;\r\n\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport \"../exchanges/UniswapV2Exchange.sol\";\r\nimport \"../interfaces/IMeshSwapLP.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract MeshSwapStrategy is InitializableAbstractStrategy, UniswapV2Exchange, BalancerExchange   {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using OvnMath for uint256;\r\n\r\n\r\n    IERC20 public token0;\r\n    IERC20 public primaryStable;\r\n    IERC20 public meshToken;\r\n\r\n    IMeshSwapLP public meshSwapToken0;\r\n\r\n\r\n    bytes32 poolId;\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as MeshSwap strategies don't fit\r\n     * well within that abstraction.\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // MeshToken address\r\n        address _vaultAddress,    // VaultProxy address\r\n        address[] calldata _rewardTokenAddresses, // USDC - as in end USDC will be sent to Harvester\r\n        address[] calldata _assets, // USDC\r\n        address[] calldata _pTokens, // meshSwapToken0\r\n        address _router,  // meshSwapRouter\r\n        address _primaryStable\r\n    ) external onlyGovernor initializer {\r\n        require(_rewardTokenAddresses[0] != address(0), \"Zero address not allowed\");\r\n        require(_pTokens[0] != address(0), \"Zero address not allowed\");\r\n        require(_platformAddress != address(0), \"Zero address not allowed\");\r\n        require(_router != address(0), \"Zero address not allowed\");\r\n        require(_primaryStable != address(0), \"Zero address not allowed\");\r\n\r\n        token0 = IERC20(_assets[0]);\r\n        primaryStable = IERC20(_primaryStable);\r\n        meshToken = IERC20(_platformAddress);\r\n        meshSwapToken0 = IMeshSwapLP(_pTokens[0]);\r\n        _setUniswapRouter(_router);\r\n        _abstractSetPToken(_assets[0],_pTokens[0]);\r\n\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n\r\n    function setBalancer(address _balancerVault, bytes32 _balancerPoolIdUsdcTusdDaiUsdt) external onlyGovernor {\r\n        require(_balancerVault != address(0), \"Zero address not allowed\");\r\n        require(_balancerPoolIdUsdcTusdDaiUsdt != \"\", \"Empty pool id not allowed\");\r\n\r\n        setBalancerVault(_balancerVault);\r\n        poolId = _balancerPoolIdUsdcTusdDaiUsdt;\r\n    }\r\n\r\n    function _deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )  internal {\r\n        require(_asset == address(primaryStable), \"Token not compatible.\");\r\n        _swapPrimaryStableToToken0();\r\n        // console.log(\"primaryStable Balance:\", primaryStable.balanceOf(address(this)));\r\n        // console.log(\"Token0 Balance:\", token0.balanceOf(address(this)));\r\n        token0.approve(address(meshSwapToken0), token0.balanceOf(address(this)) );\r\n        // console.log(\"Depositing \", token0.balanceOf(address(this)));\r\n        meshSwapToken0.depositToken(token0.balanceOf(address(this)));\r\n    }\r\n\r\n    function deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )   external\r\n        override\r\n        onlyVault\r\n        nonReentrant {\r\n        require(_asset == address(primaryStable), \"Token not compatible.\");\r\n        _deposit(_asset, _amount);\r\n    }\r\n\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        _deposit(address(token0), token0.balanceOf(address(this)));\r\n    }\r\n\r\n\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n        require(_asset == address(primaryStable), \"Token not compatible.\");\r\n        meshSwapToken0.withdrawToken(_amount);\r\n        console.log(\"MeshSwapStrategy - withdraw - token0: \", token0.balanceOf(address(this)));\r\n\r\n        _swapAssetToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        console.log(\"MeshSwapStrategy - withdraw - PrimaryStable: \",primaryStableBalance);\r\n        primaryStable.safeTransfer(_beneficiary, primaryStableBalance);\r\n    }\r\n\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant  {\r\n        meshSwapToken0.withdrawTokenByAmount(meshSwapToken0.balanceOf(address(this)));\r\n        _swapAssetToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"withdraw - PrimaryStable\",primaryStableBalance);\r\n        primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        _collectRewards();\r\n    }\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        uint256 token0Balance;\r\n        uint256 lpTokenBalance = meshSwapToken0.balanceOf(address(this));\r\n        // console.log(\"lpTokenBalance:\", lpTokenBalance);\r\n\r\n        // TODO: MoreClean workground for handling non-six decimal token0\r\n        // Fix for handling token0 with 18 decimals\r\n        if (IERC20Metadata(address(token0)).decimals() != IERC20Metadata(address(primaryStable)).decimals()) {\r\n            lpTokenBalance = lpTokenBalance.div(10 ** (IERC20Metadata(address(token0)).decimals() - IERC20Metadata(address(primaryStable)).decimals())); // e12 = e18 - e6\r\n        }\r\n        // console.log(\"lpTokenBalance:\", lpTokenBalance);\r\n        if (lpTokenBalance > 0) {\r\n            uint256 exchangeRateStored = meshSwapToken0.exchangeRateStored();\r\n            // console.log(\"exchangeRateStored:\", exchangeRateStored);\r\n            token0Balance = exchangeRateStored.mul(lpTokenBalance).div(1e18);\r\n        }\r\n        // console.log(\"token0Balance:\", token0Balance.scaleBy(IERC20Metadata(address(token0)).decimals() , 6 ));\r\n        uint256 primaryStableBalanceFromToken0;\r\n        if ( (address(token0) != address(primaryStable))  ) {\r\n            if (token0Balance > 0) {\r\n                primaryStableBalanceFromToken0 = onSwap(\r\n                    poolId,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    token0,\r\n                    primaryStable,\r\n                    token0Balance.scaleBy(IERC20Metadata(address(token0)).decimals() , 6 )\r\n                );\r\n                // console.log(\"Token0 swap -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken0);\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken0 += token0Balance;\r\n        }\r\n        return primaryStableBalanceFromToken0 + primaryStableBalance;\r\n    }\r\n\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        _collectRewards();\r\n    }\r\n    function _collectRewards() internal {\r\n        // console.log(\"Starting collection of rewards\");\r\n        // claim rewards\r\n        meshSwapToken0.claimReward();\r\n        // console.log(\"claimStakingRewards called\");\r\n        // sell rewards\r\n        uint256 totalUsdc = 0;\r\n        uint256 meshBalance = meshToken.balanceOf(address(this));\r\n        // console.log(\"meshBalance: \", meshBalance);\r\n        if (meshBalance > 10 ** 13) {\r\n            // console.log(\"Swapping MeshToken for USDC\");\r\n            uint256 meshUsdc = _swapExactTokensForTokens(\r\n                address(meshToken),\r\n                address(primaryStable),\r\n                meshBalance,\r\n                address(this)\r\n            );\r\n            // console.log(\"Mesh USDC\", meshUsdc);\r\n            totalUsdc += meshUsdc;\r\n        }\r\n        // console.log(\"totalUsdc\", totalUsdc);\r\n        uint256 balance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"balance\", balance);\r\n        if (balance > 0) {\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                address(primaryStable),\r\n                balance\r\n            );\r\n            primaryStable.transfer(harvesterAddress, balance);\r\n        }\r\n    }\r\n    function _swapAssetToPrimaryStable() internal {\r\n        if ( (address(token0) != address(primaryStable)) && (token0.balanceOf(address(this)) > 0) )  {\r\n            // console.log(\"Swapping token0\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token0)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token0.balanceOf(address(this)),\r\n                0\r\n            );\r\n            if(token0.balanceOf(address(this)) > 0) {\r\n                revert(\"MeshSwap Strategy - Token0 to PrimarySwap failed\");\r\n            }\r\n        }\r\n    }\r\n    function _swapPrimaryStableToToken0() internal {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        if (address(primaryStable) != address(token0)) {\r\n            swap(\r\n                poolId, \r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(primaryStable)),\r\n                IAsset(address(token0)),\r\n                address(this),\r\n                address(this),\r\n                primaryStableBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n     /**\r\n     * @dev Retuns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _asset == address(primaryStable);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding cToken,\r\n     *      if for some reason is it necessary.\r\n     */\r\n    function safeApproveAllTokens() external override {\r\n        // Not needed\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to respond to the addition of new asset / cTokens\r\n     *      We need to approve the cToken and give it permission to spend the asset\r\n     * @param _asset Address of the asset to approve\r\n     * @param _cToken The cToken for the approval\r\n     */\r\n    function _abstractSetPToken(address _asset, address _cToken)\r\n        internal\r\n        override\r\n    {\r\n        // Not needed\r\n    }\r\n   \r\n}\r\n"
    },
    "contracts/strategies/DystopiaStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Dystopia Strategy\r\n * @notice Investment strategy for investing stablecoins via Dystopia Strategy\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"  ;\r\n\r\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\r\nimport { DystopiaExchange } from \"./DystopiaExchange.sol\";\r\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\r\nimport { IERC20, BaseCurveStrategy } from \"./BaseCurveStrategy.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { AaveBorrowLibrary } from \"../utils/AaveBorrowLibrary.sol\";\r\nimport \"../interfaces/IPriceFeed.sol\";\r\nimport \"../interfaces/IDystopiaLP.sol\";\r\nimport \"../interfaces/ISwapper.sol\";\r\nimport \"../connectors/IUserProxy.sol\";\r\nimport \"../connectors/IPenLens.sol\";\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport { OvnMath } from \"../utils/OvnMath.sol\";\r\nimport \"hardhat/console.sol\";\r\ncontract DystopiaStrategy is InitializableAbstractStrategy, DystopiaExchange, BalancerExchange  {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    mapping(address => uint256 ) public assetToDenominator;\r\n\r\n    IDystopiaLP  public  gauge;\r\n    IDystopiaLP  public  dystPair;\r\n\r\n    address public  dystRouter;\r\n\r\n    bytes32 public poolId;\r\n\r\n\r\n    IERC20 public primaryStable;\r\n    IERC20 public middleToken;\r\n    IERC20 public token0;\r\n    IERC20 public token1;\r\n\r\n    IERC20 public dystToken;\r\n\r\n\r\n\r\n    IERC20 public penToken;\r\n    IUserProxy public userProxy;\r\n    IPenLens public penLens;\r\n\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as Dystopia strategies don't fit\r\n     * well within that abstraction.\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // dystToken address\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses, // USDC\r\n        address[] calldata _assets, // USDC & DAI etc\r\n        address[] calldata _pTokens, // DystPair\r\n        address _primaryStable, // USDC\r\n        address _intermediatory_token // wMATIC\r\n    ) external onlyGovernor initializer {\r\n\r\n        token0 = IERC20(_assets[0]);\r\n        token1 = IERC20(_assets[1]);\r\n        primaryStable = IERC20(_primaryStable);\r\n        middleToken = IERC20(_intermediatory_token);\r\n\r\n        dystToken = IERC20(_platformAddress);\r\n\r\n        uint256 assetCount = _assets.length;\r\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            assetToDenominator[_assets[i]] = 10 ** IERC20Metadata(_assets[i]).decimals();\r\n        }\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n    function setParams(\r\n        address _gauge,\r\n        address _dystPair,\r\n        address _dystRouter,\r\n        address _balancerVault, \r\n        bytes32 _poolId,// _poolIdUsdcTusdDaiUsdt\r\n        address _userProxy,\r\n        address _penLens,\r\n        address _penToken\r\n    ) external onlyGovernor {\r\n        setBalancerVault(_balancerVault);\r\n        poolId = _poolId;\r\n        gauge = IDystopiaLP(_gauge);\r\n        dystPair = IDystopiaLP(_dystPair);\r\n        _setDystopiaRouter(_dystRouter);\r\n        userProxy = IUserProxy(_userProxy);\r\n        penLens = IPenLens(_penLens);\r\n        penToken = IERC20(_penToken);\r\n    }\r\n\r\n    function getReserves() internal view returns (uint256,uint256) {\r\n        (uint256 reserve0, uint256 reserve1,) = dystPair.getReserves();\r\n        require(reserve0 > (10 ** (IERC20Metadata(address(token0) ).decimals() - 3))  && reserve1 > (10 ** (IERC20Metadata(address(token1) ).decimals() - 3)), \"Reserves too low\");\r\n        return (reserve0, reserve1) ;\r\n    }\r\n\r\n    function _deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )  internal {\r\n\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1) = getReserves();\r\n        _swapPrimaryStableToToken0();\r\n\r\n        // count amount token1 to swap\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n        uint256 amount0From1;\r\n        if (token1Balance > 0) {\r\n            amount0From1 = onSwap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                token1,\r\n                token0,\r\n                token1Balance\r\n            );\r\n        }\r\n\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        // console.log(\"token0\", address(token0));\r\n        // console.log(\"token1\", address(token1));\r\n        // console.log(\"token0Balance\", token0Balance);\r\n        // console.log(\"token1Balance\", token1Balance);\r\n        // console.log(\"reserve0\", reserve0);\r\n        // console.log(\"reserve1\", reserve1);\r\n        uint256 amountToken0ToSwap = _getAmountToSwap(\r\n            token0Balance,\r\n            reserve0,\r\n            reserve1,\r\n            assetToDenominator[address(token0)],\r\n            assetToDenominator[address(token1)],\r\n            1,\r\n            poolId,\r\n            token0,\r\n            token1\r\n        );\r\n        // console.log(\"amountToken0ToSwap\", amountToken0ToSwap);\r\n        // swap some of token0 to token1\r\n        swap(\r\n            poolId,\r\n            IVault.SwapKind.GIVEN_IN,\r\n            IAsset(address(token0)),\r\n            IAsset(address(token1)),\r\n            address(this),\r\n            address(this),\r\n            amountToken0ToSwap,\r\n            0\r\n        );\r\n\r\n        // add liquidity\r\n        token0Balance = token0.balanceOf(address(this));\r\n        token1Balance = token1.balanceOf(address(this));\r\n\r\n        _addLiquidity(\r\n            address(token0),\r\n            address(token1),\r\n            token0Balance,\r\n            token1Balance,\r\n            OvnMath.subBasisPoints(token0Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            OvnMath.subBasisPoints(token1Balance, BASIS_POINTS_FOR_SLIPPAGE),\r\n            address(this)\r\n        );\r\n\r\n        uint256 lpTokenBalance = dystPair.balanceOf(address(this));\r\n         // console.log(\"Dyst LP Token Balance: \", lpTokenBalance);\r\n        _stakeToPenrose(lpTokenBalance);\r\n\r\n    }\r\n\r\n    function deposit(\r\n        address _asset,\r\n        uint256 _amount\r\n    )   external\r\n        override\r\n        onlyVault\r\n        nonReentrant {\r\n\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        _deposit(_asset, _amount);\r\n    }\r\n\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        _deposit(address(primaryStable), primaryStable.balanceOf(address(this)));\r\n    }\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        (uint256 reserve0, uint256 reserve1) = getReserves();\r\n\r\n        // Fetch amount of penPool LP currently staked\r\n        address userProxyThis = penLens.userProxyByAccount(address(this));\r\n        address stakingAddress = penLens.stakingRewardsByDystPool(address(dystPair));\r\n        uint256 lpTokenBalance = IERC20(stakingAddress).balanceOf(userProxyThis);\r\n\r\n        if (lpTokenBalance > 0) {\r\n            // count amount to unstake\r\n            uint256 totalLpBalance = dystPair.totalSupply();\r\n            uint256 lpTokensToWithdraw = _getAmountLpTokensToWithdraw(\r\n                OvnMath.addBasisPoints(_amount, BASIS_POINTS_FOR_SLIPPAGE),\r\n                reserve0,\r\n                reserve1,\r\n                totalLpBalance,\r\n                assetToDenominator[address(token0)],\r\n                assetToDenominator[address(token1)],\r\n                poolId,\r\n                token0,\r\n                token1\r\n            );\r\n\r\n            if (lpTokensToWithdraw > lpTokenBalance) {\r\n                lpTokensToWithdraw = lpTokenBalance;\r\n            }\r\n\r\n            userProxy.unstakeLpAndWithdraw(address(dystPair), lpTokensToWithdraw);\r\n            uint256 unstakedLPTokenBalance = dystPair.balanceOf(address(this));\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(dystPair),\r\n                unstakedLPTokenBalance,\r\n                OvnMath.subBasisPoints(reserve0 * unstakedLPTokenBalance / totalLpBalance, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(reserve1 * unstakedLPTokenBalance / totalLpBalance, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n        _swapAssetsToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n         // console.log(\"Withdraw USDC: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(_beneficiary, primaryStableBalance);\r\n       \r\n    }\r\n\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant  {\r\n        (uint256 reserve0, uint256 reserve1) = getReserves();\r\n        _withdrawFromDystopiaAndStakeToPenrose();\r\n        // Fetch amount of penPool LP currently staked\r\n        address userProxyThis = penLens.userProxyByAccount(address(this));\r\n        address stakingAddress = penLens.stakingRewardsByDystPool(address(dystPair));\r\n        uint256 lpTokenBalance = IERC20(stakingAddress).balanceOf(userProxyThis);\r\n        if (lpTokenBalance == 0) {\r\n            return;\r\n        }\r\n        userProxy.unstakeLpAndWithdraw(address(dystPair), lpTokenBalance);\r\n        uint256 unstakedLPTokenBalance = dystPair.balanceOf(address(this));\r\n        if (unstakedLPTokenBalance > 0) {\r\n            uint256 totalLpBalance = dystPair.totalSupply();\r\n            uint256 amountOutUsdcMin = reserve0 * unstakedLPTokenBalance / totalLpBalance;\r\n            uint256 amountOutOtherMin = reserve1 * unstakedLPTokenBalance / totalLpBalance;\r\n            // remove liquidity\r\n            _removeLiquidity(\r\n                address(token0),\r\n                address(token1),\r\n                address(dystPair),\r\n                unstakedLPTokenBalance,\r\n                OvnMath.subBasisPoints(amountOutUsdcMin, BASIS_POINTS_FOR_SLIPPAGE),\r\n                OvnMath.subBasisPoints(amountOutOtherMin, BASIS_POINTS_FOR_SLIPPAGE),\r\n                address(this)\r\n            );\r\n        }\r\n\r\n        _swapAssetsToPrimaryStable();\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n         // console.log(\"Withdraw Primary Stable: \", primaryStableBalance);\r\n        primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        _collectRewards();\r\n    }\r\n\r\n\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        uint256 token0Balance = token0.balanceOf(address(this));\r\n        uint256 token1Balance = token1.balanceOf(address(this));\r\n\r\n        // Fetch amount of penPool LP currently staked\r\n        address userProxyThis = penLens.userProxyByAccount(address(this));\r\n         // console.log(\"dystPair\", address(dystPair));\r\n        address stakingAddress = penLens.stakingRewardsByDystPool(address(dystPair));\r\n         // console.log(\"stakingAddress: \", stakingAddress);\r\n        uint256 lpTokenBalance = IERC20(stakingAddress).balanceOf(userProxyThis);\r\n        lpTokenBalance += gauge.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            uint256 totalLpBalance = dystPair.totalSupply();\r\n            (uint256 reserve0, uint256 reserve1) = getReserves();\r\n            token0Balance += reserve0 * lpTokenBalance / totalLpBalance;\r\n            token1Balance += reserve1 * lpTokenBalance / totalLpBalance;\r\n        }\r\n        // console.log(\"tokenBalance\", token0Balance, token1Balance);\r\n\r\n        uint256 primaryStableBalanceFromToken0;\r\n        if ( (address(token0) != address(primaryStable))  ) {\r\n            if (token0Balance > 0) {\r\n                primaryStableBalanceFromToken0 = onSwap(\r\n                    poolId,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    token0,\r\n                    primaryStable,\r\n                    token0Balance\r\n                );\r\n                // console.log(\"Token0 swap -  primaryStableBalanceFromToken0 \", primaryStableBalanceFromToken0);\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken0 += token0Balance;\r\n        }\r\n\r\n        uint256 primaryStableBalanceFromToken1;\r\n        if ( (address(token1) != address(primaryStable))  ) {\r\n            if (token1Balance > 0) {\r\n                primaryStableBalanceFromToken1 = onSwap(\r\n                    poolId,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    token1,\r\n                    primaryStable,\r\n                    token1Balance\r\n                );\r\n                // console.log(\"Token1 swap -  primaryStableBalanceFromToken1 \", primaryStableBalanceFromToken1);\r\n            }\r\n        } else {\r\n            primaryStableBalanceFromToken1 += token1Balance;\r\n        }\r\n         // console.log(\"primaryStableBalanceFromToken0: \", primaryStableBalanceFromToken0);\r\n         // console.log(\"primaryStableBalanceFromToken1: \", primaryStableBalanceFromToken1);\r\n        return primaryStableBalanceFromToken0 + primaryStableBalanceFromToken1 + primaryStableBalance;\r\n    }\r\n\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        _collectRewards();\r\n    }\r\n    function _collectRewards() internal {\r\n         console.log(\"Starting collection of rewards\");\r\n        _withdrawFromDystopiaAndStakeToPenrose();\r\n\r\n         console.log(\"_withdrawFromDystopiaAndStakeToPenrose called\");\r\n        // claim rewards\r\n        userProxy.claimStakingRewards();\r\n         console.log(\"claimStakingRewards called\");\r\n        // sell rewards\r\n        uint256 totalUsdc;\r\n\r\n        uint256 dystBalance = dystToken.balanceOf(address(this));\r\n         console.log(\"dystBalance: \", dystBalance);\r\n        if (dystBalance > 0) {\r\n            uint256 dystUsdc = _swapExactTokensForTokens(\r\n                address(dystToken),\r\n                address(middleToken),\r\n                address(token0),\r\n                false,\r\n                false,\r\n                dystBalance,\r\n                address(this)\r\n            );\r\n            totalUsdc += dystUsdc;\r\n        }\r\n         console.log(\"totalUsdc=\",totalUsdc);\r\n        uint256 penBalance = penToken.balanceOf(address(this));\r\n        console.log(\"penBalance: \", penBalance);\r\n        if (penBalance > 0) {\r\n            uint256 penUsdc = _swapExactTokensForTokens(\r\n                address(penToken),\r\n                address(middleToken),\r\n                address(primaryStable),\r\n                false,\r\n                false,\r\n                penBalance,\r\n                address(this)\r\n            );\r\n            console.log(\"penUsdc\",penUsdc);\r\n            totalUsdc += penUsdc;\r\n        }\r\n        uint256 balance = primaryStable.balanceOf(address(this));\r\n        console.log(\"balance: \", balance);\r\n        emit RewardTokenCollected(\r\n            harvesterAddress,\r\n            address(primaryStable),\r\n            balance\r\n        );\r\n        primaryStable.transfer(harvesterAddress, balance);\r\n    }\r\n    function _withdrawFromDystopiaAndStakeToPenrose() internal {\r\n        uint256 lpTokenBalance = gauge.balanceOf(address(this));\r\n        if (lpTokenBalance > 0) {\r\n            // claim rewards\r\n            address[] memory token = new address[](1);\r\n            token[0] = address(dystToken);\r\n            gauge.getReward(address(this), token);\r\n\r\n            // withdraw LP tokens and stake\r\n            gauge.withdrawAll();\r\n            uint256 lpTokenBalance = dystPair.balanceOf(address(this));\r\n            dystPair.approve(address(userProxy), lpTokenBalance);\r\n            userProxy.depositLpAndStake(address(dystPair), lpTokenBalance);\r\n        }\r\n    }\r\n    function _stakeToPenrose(uint256 _lpTokenAmount) internal {\r\n        dystPair.approve(address(userProxy), _lpTokenAmount);\r\n        userProxy.depositLpAndStake(address(dystPair), _lpTokenAmount);\r\n        uint256 penBalance = penToken.balanceOf(address(this));\r\n         // console.log(\"penBalance: \", penBalance);\r\n    }\r\n\r\n    function _swapAssetsToPrimaryStable() internal {\r\n        if ( (address(token0) != address(primaryStable)) && (token0.balanceOf(address(this)) > 0) )  {\r\n             // console.log(\"Swapping token0\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token0)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token0.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n        if ( (address(token1) != address(primaryStable)) && (token1.balanceOf(address(this)) > 0) )  {\r\n             // console.log(\"Swapping token1\");\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(token1)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                token1.balanceOf(address(this)),\r\n                0\r\n            );\r\n        }\r\n    }\r\n    function _swapPrimaryStableToToken0() internal {\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        if (address(primaryStable) != address(token0)) {\r\n            swap(\r\n                poolId,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(primaryStable)),\r\n                IAsset(address(token0)),\r\n                address(this),\r\n                address(this),\r\n                primaryStableBalance,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Retuns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _asset == address(primaryStable);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding cToken,\r\n     *      if for some reason is it necessary.\r\n     */\r\n    function safeApproveAllTokens() external override {\r\n        // NOT NEEDED\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to respond to the addition of new asset / cTokens\r\n     *      We need to approve the cToken and give it permission to spend the asset\r\n     * @param _asset Address of the asset to approve\r\n     * @param _cToken The cToken for the approval\r\n     */\r\n    function _abstractSetPToken(address _asset, address _cToken)\r\n        internal\r\n        override\r\n    {\r\n        // NOT NEEDED\r\n    }\r\n   \r\n}\r\n"
    },
    "contracts/strategies/IRewardStaking.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRewardStaking {\r\n    function stakeFor(address, uint256) external;\r\n\r\n    function stake(uint256) external;\r\n\r\n    function withdraw(uint256 amount, bool claim) external;\r\n\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external;\r\n\r\n    function earned(address account) external view returns (uint256);\r\n\r\n    function getReward() external;\r\n\r\n    function getReward(address _account, bool _claimExtras) external;\r\n\r\n    function extraRewardsLength() external returns (uint256);\r\n\r\n    function extraRewards(uint256 _pid) external returns (address);\r\n\r\n    function rewardToken() external returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/IConvexDeposits.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IConvexDeposits {\r\n    function deposit(\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        bool _stake\r\n    ) external returns (bool);\r\n\r\n    function deposit(\r\n        uint256 _amount,\r\n        bool _lock,\r\n        address _stakeAddress\r\n    ) external;\r\n}\r\n"
    },
    "contracts/strategies/BaseCurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Curve 3Pool Strategy\r\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { ICurvePool } from \"./ICurvePool.sol\";\r\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\n\r\nabstract contract BaseCurveStrategy is InitializableAbstractStrategy {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 internal constant maxSlippage = 1e16; // 1%, same as the Curve UI\r\n    address internal pTokenAddress;\r\n\r\n    /**\r\n     * @dev Deposit asset into the Curve 3Pool\r\n     * @param _asset Address of asset to deposit\r\n     * @param _amount Amount of asset to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        override\r\n        virtual\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        require(_amount > 0, \"Must deposit something\");\r\n        emit Deposit(_asset, address(platformAddress), _amount);\r\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\r\n        // all\r\n        uint256[3] memory _amounts;\r\n        uint256 poolCoinIndex = _getCoinIndex(_asset);\r\n        // Set the amount on the asset we want to deposit\r\n        _amounts[poolCoinIndex] = _amount;\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\r\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\r\n            curvePool.get_virtual_price()\r\n        );\r\n        uint256 minMintAmount = depositValue.mulTruncate(\r\n            uint256(1e18) - maxSlippage\r\n        );\r\n        // Do the deposit to 3pool\r\n        curvePool.add_liquidity(_amounts, minMintAmount);\r\n        _lpDepositAll();\r\n    }\r\n\r\n    function _lpDepositAll() internal virtual;\r\n\r\n    /**\r\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\r\n     */\r\n    function depositAll() external override virtual onlyVault nonReentrant {\r\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\r\n        uint256 depositValue = 0;\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\r\n\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            address assetAddress = assetsMapped[i];\r\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\r\n            if (balance > 0) {\r\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\r\n                // Set the amount on the asset we want to deposit\r\n                _amounts[poolCoinIndex] = balance;\r\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\r\n                // Get value of deposit in Curve LP token to later determine\r\n                // the minMintAmount argument for add_liquidity\r\n                depositValue =\r\n                    depositValue +\r\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\r\n                        curveVirtualPrice\r\n                    );\r\n                emit Deposit(assetAddress, address(platformAddress), balance);\r\n            }\r\n        }\r\n\r\n        uint256 minMintAmount = depositValue.mulTruncate(\r\n            uint256(1e18) - maxSlippage\r\n        );\r\n        // Do the deposit to 3pool\r\n        curvePool.add_liquidity(_amounts, minMintAmount);\r\n        // Deposit into Gauge, the PToken is the same (3Crv) for all mapped\r\n        // assets, so just get the address from the first one\r\n        _lpDepositAll();\r\n    }\r\n\r\n    function _lpWithdraw(uint256 numPTokens) internal virtual;\r\n\r\n    /**\r\n     * @dev Withdraw asset from Curve 3Pool\r\n     * @param _recipient Address to receive withdrawn asset\r\n     * @param _asset Address of asset to withdraw\r\n     * @param _amount Amount of asset to withdraw\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override virtual onlyVault nonReentrant {\r\n        require(_amount > 0, \"Invalid amount\");\r\n\r\n        emit Withdrawal(_asset, address(assetToPToken[_asset]), _amount);\r\n\r\n        (uint256 contractPTokens, , uint256 totalPTokens) = _getTotalPTokens();\r\n\r\n        uint256 coinIndex = _getCoinIndex(_asset);\r\n        int128 curveCoinIndex = int128(uint128(coinIndex));\r\n        // Calculate the max amount of the asset we'd get if we withdrew all the\r\n        // platform tokens\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        // Calculate how many platform tokens we need to withdraw the asset\r\n        // amount in the worst case (i.e withdrawing all LP tokens)\r\n        uint256 maxAmount = curvePool.calc_withdraw_one_coin(\r\n            totalPTokens,\r\n            curveCoinIndex\r\n        );\r\n        uint256 maxBurnedPTokens = (totalPTokens * _amount) / maxAmount;\r\n\r\n        // Not enough in this contract or in the Gauge, can't proceed\r\n        require(totalPTokens > maxBurnedPTokens, \"Insufficient 3CRV balance\");\r\n        // We have enough LP tokens, make sure they are all on this contract\r\n        if (contractPTokens < maxBurnedPTokens) {\r\n            _lpWithdraw(maxBurnedPTokens - contractPTokens);\r\n        }\r\n\r\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\r\n        _amounts[coinIndex] = _amount;\r\n        curvePool.remove_liquidity_imbalance(_amounts, maxBurnedPTokens);\r\n\r\n        IERC20(_asset).safeTransfer(_recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function withdrawAll() external override virtual onlyVaultOrGovernor nonReentrant {\r\n        // Withdraw all from Gauge\r\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\r\n        _lpWithdraw(gaugePTokens);\r\n        // Withdraws are proportional to assets held by 3Pool\r\n        uint256[3] memory minWithdrawAmounts = [\r\n            uint256(0),\r\n            uint256(0),\r\n            uint256(0)\r\n        ];\r\n        // Remove liquidity\r\n        ICurvePool threePool = ICurvePool(platformAddress);\r\n        threePool.remove_liquidity(totalPTokens, minWithdrawAmounts);\r\n        // Transfer assets out of Vault\r\n        // Note that Curve will provide all 3 of the assets in 3pool even if\r\n        // we have not set PToken addresses for all of them in this strategy\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            IERC20 asset = IERC20(threePool.coins(i));\r\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the total asset value held in the platform\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function checkBalance()\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Retuns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return assetToPToken[_asset] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\r\n     *      if for some reason is it necessary.\r\n     */\r\n    function safeApproveAllTokens()\r\n        external\r\n        override\r\n        onlyGovernor\r\n        nonReentrant\r\n    {\r\n        _approveBase();\r\n        // This strategy is a special case since it only supports one asset\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            _approveAsset(assetsMapped[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the total platform token balance (i.e. 3CRV) that exist in\r\n     * this contract or is staked in the Gauge (or in other words, the total\r\n     * amount platform tokens we own).\r\n     * @return contractPTokens Amount of platform tokens in this contract\r\n     * @return gaugePTokens Amount of platform tokens staked in gauge\r\n     * @return totalPTokens Total amount of platform tokens in native decimals\r\n     */\r\n    function _getTotalPTokens()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256 contractPTokens,\r\n            uint256 gaugePTokens,\r\n            uint256 totalPTokens\r\n        );\r\n\r\n    /**\r\n     * @dev Call the necessary approvals for the Curve pool and gauge\r\n     * @param _asset Address of the asset\r\n     */\r\n    function _abstractSetPToken(address _asset, address _pToken)\r\n        internal\r\n        override\r\n    {\r\n        _approveAsset(_asset);\r\n    }\r\n\r\n    function _approveAsset(address _asset) internal {\r\n        IERC20 asset = IERC20(_asset);\r\n        // 3Pool for asset (required for adding liquidity)\r\n        asset.safeApprove(platformAddress, 0);\r\n        asset.safeApprove(platformAddress, type(uint256).max);\r\n    }\r\n\r\n    function _approveBase() internal virtual;\r\n\r\n    /**\r\n     * @dev Get the index of the coin\r\n     */\r\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            if (assetsMapped[i] == _asset) return i;\r\n        }\r\n        revert(\"Invalid 3pool asset\");\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IDystopiaLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5 <0.9.0;\r\n\r\nimport \"./uniswap/IUniswapV2Pair.sol\";\r\n\r\nabstract contract IDystopiaLP is IUniswapV2Pair {\r\n    \r\n    mapping(address => uint) public override balanceOf;\r\n\r\n    function deposit(uint amount, uint tokenId) external virtual;\r\n    \r\n    function withdraw(uint amount) external virtual;\r\n    \r\n    function withdrawAll() external virtual;\r\n\r\n    function getReward(address account, address[] memory tokens) external virtual;\r\n\r\n    function token0() external virtual view returns (address);\r\n\r\n}"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Structures.sol\";\n\n\ninterface ISwapper is Structures {\n\n    // --- events\n\n    event SwapPlaceInfoRegistered(\n        address indexed token0,\n        address indexed token1,\n        address pool,\n        string swapPlaceType\n    );\n\n    event SwapPlaceInfoRemoved(\n        address indexed token0,\n        address indexed token1,\n        address pool\n    );\n\n    event SwapPlaceRegistered(\n        string swapPlaceType,\n        address swapPlace\n    );\n\n    event SwapPlaceRemoved(\n        string swapPlaceType\n    );\n\n    \n    // ---  structures\n\n    struct SwapPlaceInfo {\n        address pool;\n        string swapPlaceType;\n    }\n\n    struct SwapParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        uint256 partsAmount;\n    }\n\n\n    // ---  logic\n\n    function swap(SwapParams calldata params) external returns (uint256);\n\n    function getAmountOut(SwapParams calldata params) external view returns (uint256);\n\n    function swapPath(SwapParams calldata params) external view returns (SwapRoute[] memory);\n\n}\n"
    },
    "contracts/connectors/IUserProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IUserProxy {\n    struct PositionStakingPool {\n        address stakingPoolAddress;\n        address penPoolAddress;\n        address dystPoolAddress;\n        uint256 balanceOf;\n        RewardToken[] rewardTokens;\n    }\n\n    struct RewardToken {\n        address rewardTokenAddress;\n        uint256 rewardRate;\n        uint256 rewardPerToken;\n        uint256 getRewardForDuration;\n        uint256 earned;\n    }\n\n    struct Vote {\n        address poolAddress;\n        int256 weight;\n    }\n\n    function convertNftToPenDyst(uint256) external;\n\n    function convertDystToPenDyst(uint256) external;\n\n    function depositLpAndStake(address, uint256) external;\n\n    function depositLp(address, uint256) external;\n\n    function stakingAddresses() external view returns (address[] memory);\n\n    function initialize(address, address) external;\n\n    function stakingPoolsLength() external view returns (uint256);\n\n    function unstakeLpAndWithdraw(\n        address,\n        uint256,\n        bool\n    ) external;\n\n    function unstakeLpAndWithdraw(address, uint256) external;\n\n    function unstakeLpWithdrawAndClaim(address) external;\n\n    function unstakeLpWithdrawAndClaim(address, uint256) external;\n\n    function withdrawLp(address, uint256) external;\n\n    function stakePenLp(address, uint256) external;\n\n    function unstakePenLp(address, uint256) external;\n\n    function ownerAddress() external view returns (address);\n\n    function stakingPoolsPositions()\n    external\n    view\n    returns (PositionStakingPool[] memory);\n\n    function stakePenDyst(uint256) external;\n\n    function unstakePenDyst(uint256) external;\n\n    function unstakePenDyst(address, uint256) external;\n\n    function convertDystToPenDystAndStake(uint256) external;\n\n    function convertNftToPenDystAndStake(uint256) external;\n\n    function claimPenDystStakingRewards() external;\n\n    function claimPartnerStakingRewards() external;\n\n    function claimStakingRewards(address) external;\n\n    function claimStakingRewards(address[] memory) external;\n\n    function claimStakingRewards() external;\n\n    function claimVlPenRewards() external;\n\n    function depositPen(uint256, uint256) external;\n\n    function withdrawPen(bool, uint256) external;\n\n    function voteLockPen(uint256, uint256) external;\n\n    function withdrawVoteLockedPen(uint256, bool) external;\n\n    function relockVoteLockedPen(uint256) external;\n\n    function removeVote(address) external;\n\n    function registerStake(address) external;\n\n    function registerUnstake(address) external;\n\n    function resetVotes() external;\n\n    function setVoteDelegate(address) external;\n\n    function clearVoteDelegate() external;\n\n    function vote(address, int256) external;\n\n    function vote(Vote[] memory) external;\n\n    function votesByAccount(address) external view returns (Vote[] memory);\n\n    function migratePenDystToPartner() external;\n\n    function stakePenDystInPenV1(uint256) external;\n\n    function unstakePenDystInPenV1(uint256) external;\n\n    function redeemPenV1(uint256) external;\n\n    function redeemAndStakePenV1(uint256) external;\n\n    function whitelist(address) external;\n\n    function implementationsAddresses()\n    external\n    view\n    returns (address[] memory);\n}"
    },
    "contracts/connectors/IPenLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IPenLens {\n\n    /* ========== PUBLIC VARS ========== */\n\n    function penPoolFactoryAddress() external view returns (address);\n\n    function rewardsDistributorAddress() external view returns (address);\n\n    function userProxyFactoryAddress() external view returns (address);\n\n    function dystopiaLensAddress() external view returns (address);\n\n    function penAddress() external view returns (address);\n\n    function vlPenAddress() external view returns (address);\n\n    function penDystAddress() external view returns (address);\n\n    function voterProxyAddress() external view returns (address);\n\n    function veAddress() external view returns (address);\n\n    function dystAddress() external view returns (address);\n\n    function penDystRewardsPoolAddress() external view returns (address);\n\n    function partnersRewardsPoolAddress() external view returns (address);\n\n    function treasuryAddress() external view returns (address);\n\n    function cvlPenAddress() external view returns (address);\n\n    function penV1RewardsAddress() external view returns (address);\n\n    function penV1RedeemAddress() external view returns (address);\n\n    function penV1Address() external view returns (address);\n\n    function tokensAllowlistAddress() external view returns (address);\n\n    /* ========== PUBLIC VIEW FUNCTIONS ========== */\n\n    function voterAddress() external view returns (address);\n\n    function poolsFactoryAddress() external view returns (address);\n\n    function gaugesFactoryAddress() external view returns (address);\n\n    function minterAddress() external view returns (address);\n\n    function penPoolsLength() external view returns (uint256);\n\n    function userProxiesLength() external view returns (uint256);\n\n    function userProxyByAccount(address accountAddress)\n    external\n    view\n    returns (address);\n\n    function userProxyByIndex(uint256 index) external view returns (address);\n\n    function gaugeByDystPool(address) external view returns (address);\n\n    function dystPoolByPenPool(address penPoolAddress)\n    external\n    view\n    returns (address);\n\n    function penPoolByDystPool(address dystPoolAddress)\n    external\n    view\n    returns (address);\n\n    function stakingRewardsByDystPool(address dystPoolAddress)\n    external\n    view\n    returns (address);\n\n    function stakingRewardsByPenPool(address dystPoolAddress)\n    external\n    view\n    returns (address);\n\n    function isPenPool(address penPoolAddress) external view returns (bool);\n\n    function penPoolsAddresses() external view returns (address[] memory);\n\n    function isPartner(address userProxyAddress) external view returns (bool);\n\n    function stakedPenDystBalanceOf(address accountAddress)\n    external\n    view\n    returns (uint256 stakedBalance);\n\n    function dystInflationSinceInception() external view returns (uint256);\n}"
    },
    "contracts/strategies/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _min) external;\r\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _min, bool _use_underlying) external;\r\n\r\n    function balances(uint256) external view returns (uint256);\r\n\r\n    function calc_token_amount(uint256[3] calldata _amounts, bool _deposit)\r\n        external\r\n        returns (uint256);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 _amount,\r\n        int128 _index,\r\n        uint256 _minAmount\r\n    ) external;\r\n    function remove_liquidity_one_coin(\r\n        uint256 _amount,\r\n        int128 _index,\r\n        uint256 _minAmount,\r\n        bool _use_underlying\r\n\r\n    ) external;\r\n\r\n    function remove_liquidity(\r\n        uint256 _amount,\r\n        uint256[3] calldata _minWithdrawAmounts\r\n    ) external;\r\n\r\n    function remove_liquidity(\r\n        uint256 _amount,\r\n        uint256[3] calldata _minWithdrawAmounts,\r\n        bool _use_underlying\r\n    ) external;\r\n\r\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function coins(uint256 _index) external view returns (address);\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[3] calldata _amounts,\r\n        uint256 maxBurnAmount\r\n    ) external;\r\n}\r\n"
    },
    "contracts/strategies/ICRVMinter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICRVMinter {\r\n    function mint(address gaugeAddress) external;\r\n}\r\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function sync() external;\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n\r\n}"
    },
    "contracts/interfaces/Structures.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\n\ninterface Structures {\n\n    struct SwapRoute {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOut;\n        address swapPlace;\n        address pool;\n        //        string swapPlaceType;\n    }\n\n}\n"
    },
    "contracts/connectors/uniswap/v3/libraries/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\nimport './FullMath.sol';\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                sqrtRatioBX96\n            ) / sqrtRatioAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/connectors/aave/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/DataTypes.sol';\n\n/**\n * @title ILendingPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n **/\ninterface ILendingPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   **/\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   **/\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   **/\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   **/\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   **/\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   **/\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   **/\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   **/\n  function getUserAccountData(address user)\n  external\n  view\n  returns (\n    uint256 totalCollateralBase,\n    uint256 totalDebtBase,\n    uint256 availableBorrowsBase,\n    uint256 currentLiquidationThreshold,\n    uint256 ltv,\n    uint256 healthFactor\n  );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n  external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n  external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n  external\n  view\n  returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n  external\n  view\n  returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   **/\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   **/\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   **/\n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   **/\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}"
    },
    "contracts/connectors/aave/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider  {\r\n  event MarketIdSet(string newMarketId);\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  function setMarketId(string calldata marketId) external;\r\n\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external;\r\n}"
    },
    "contracts/strategies/Am3CurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Am3Curve Strategy\r\n * @notice Investment strategy for investing stablecoins via Am3Curve\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nimport { IAsset } from \"../interfaces/balancer/interfaces/IAsset.sol\";\r\nimport { IVault } from \"../interfaces/balancer/interfaces/IVault.sol\";\r\nimport { ICurvePool } from \"./ICurvePool.sol\";\r\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\r\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\r\nimport { IERC20, BaseCurveStrategy } from \"./BaseCurveStrategy.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { UniswapV2Exchange } from \"../exchanges/UniswapV2Exchange.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { ILendingPoolAddressesProvider } from \"../connectors/aave/interfaces/ILendingPoolAddressesProvider.sol\";\r\nimport { ILendingPool } from \"../connectors/aave/interfaces/ILendingPool.sol\";\r\nimport { IProtocolDataProvider } from \"../connectors/aave/interfaces/IProtocolDataProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Am3CurveStrategy is BaseCurveStrategy, UniswapV2Exchange {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n\r\n    IERC20 public primaryStable;\r\n    IERC20 public crvToken;\r\n\r\n\r\n    mapping(address => address) public stableToAmStable;\r\n    mapping(address => address) public amStableToAmDebt;\r\n\r\n    ICurveGauge crvGauge;\r\n    ICRVMinter crvMinter;\r\n\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\r\n     * well within that abstraction.\r\n     * @param _platformAddress Address of the am3Crv\r\n     * @param _vaultAddress Address of the vault\r\n     * @param _rewardTokenAddresses Address of CRV\r\n     * @param _assets Addresses of supported assets. MUST be passed in the same\r\n     *                order as returned by coins on the pool contract, i.e.\r\n     *                USDC\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // a3crv Token address\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses, // USDC\r\n        address[] calldata _assets, // USDC\r\n        address[] calldata _pTokens, // am3CRV Token address\r\n        address _primaryStable,\r\n        address _crvToken,\r\n        address _crvGauge,\r\n        address _crvMinter\r\n    ) external onlyGovernor initializer {\r\n        // Should be set prior to abstract initialize call otherwise\r\n        // abstractSetPToken calls will fail\r\n        pTokenAddress = _pTokens[0];\r\n        primaryStable = IERC20(_primaryStable);\r\n        crvToken = IERC20(_crvToken);\r\n        crvGauge = ICurveGauge(_crvGauge);\r\n        crvMinter = ICRVMinter(_crvMinter);\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n    function _setAmAssets(address[] calldata _amAssets) external onlyGovernor {\r\n        uint256 assetCount = assetsMapped.length;\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            stableToAmStable[assetsMapped[i]] = _amAssets[i];\r\n        }\r\n    }\r\n    function _setRouter(address _router) external onlyGovernor {\r\n        require(_router != address(0), \"Zero address not allowed\");\r\n        _setUniswapRouter(_router);\r\n    }\r\n\r\n\r\n\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        override\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        // console.log(\"Depositing to Am3Curve\");\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        require(_amount >= primaryStable.balanceOf(address(this)), \"Not enough assets\");\r\n        require(_amount > 0, \"Must deposit something\");\r\n        emit Deposit(_asset, address(platformAddress), _amount);\r\n\r\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for        // all\r\n        uint256[3] memory _amounts;\r\n        uint256 poolCoinIndex = _getCoinIndex(_asset); // DAI:0, USDC:1, USDT:2\r\n        // Set the amount on the asset we want to deposit\r\n        _amounts[poolCoinIndex] = _amount;\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        uint256 assetDecimals = Helpers.getDecimals(stableToAmStable[_asset]);\r\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\r\n            curvePool.get_virtual_price()\r\n        );\r\n        uint256 minMintAmount = depositValue.mulTruncate(\r\n            uint256(1e18) - maxSlippage\r\n        );\r\n        // Do the deposit to 3pool\r\n        curvePool.add_liquidity(_amounts, minMintAmount, true);\r\n        // console.log(\"Am3Curve: \", IERC20(pTokenAddress).balanceOf(address(this)));\r\n        _lpDepositAll();\r\n        emit TransferLog(\"Depositing to Am3Curve: \",_asset , _amount);\r\n    }\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\r\n        uint256 depositValue = 0;\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\r\n\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            address assetAddress = assetsMapped[i];\r\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\r\n            emit TransferLog(\"Depositing All to Am3Curve: \",assetAddress , balance);\r\n            if (balance > 0) {\r\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\r\n                // Set the amount on the asset we want to deposit\r\n                _amounts[poolCoinIndex] = balance;\r\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\r\n                // Get value of deposit in Curve LP token to later determine\r\n                // the minMintAmount argument for add_liquidity\r\n                depositValue =\r\n                    depositValue +\r\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\r\n                        curveVirtualPrice\r\n                    );\r\n                emit Deposit(assetAddress, address(platformAddress), balance);\r\n            }\r\n        }\r\n\r\n        uint256 minMintAmount = depositValue.mulTruncate(\r\n            uint256(1e18) - maxSlippage\r\n        );\r\n        // Do the deposit to 3pool\r\n        curvePool.add_liquidity(_amounts, minMintAmount, true);\r\n        // console.log(\"Am3Curve: \", IERC20(pTokenAddress).balanceOf(address(this)));\r\n        // Deposit into Gauge, the PToken is the same (3Crv) for all mapped\r\n        // assets, so just get the address from the first one\r\n        _lpDepositAll();\r\n    }\r\n    function withdraw(address _recipient, address _asset, uint256 _amount) external override onlyVault nonReentrant  {\r\n        require(_asset == address(primaryStable), \"Token not supported.\");\r\n        // Withdraw all from Gauge\r\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\r\n        // Withdraw all from Gauge\r\n        _lpWithdraw(gaugePTokens);\r\n        // Remove liquidity\r\n        ICurvePool aaveCurvePool = ICurvePool(platformAddress);\r\n        uint256 totalAm3Crv = IERC20(pTokenAddress).balanceOf(address(this));\r\n\r\n        // console.log(\"am3CRV: \", totalAm3Crv);\r\n\r\n        uint256[3] memory _amounts;\r\n        uint256 poolCoinIndex = _getCoinIndex(_asset); // DAI:0, USDC:1, USDT:2\r\n        _amounts[poolCoinIndex] = _amount;\r\n\r\n        uint256 am3CrvTokenToWithdrawFrom = aaveCurvePool.calc_token_amount(_amounts, false);\r\n        // console.log(\"am3CrvTokenToWithdrawFrom\", am3CrvTokenToWithdrawFrom);\r\n\r\n        aaveCurvePool.remove_liquidity_one_coin(am3CrvTokenToWithdrawFrom, int128(uint128(_getCoinIndex(_asset))), 0, true);\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdrawing from the Synapse: \", primaryStableBalance);\r\n        if (primaryStableBalance > 0) {\r\n            primaryStable.safeTransfer(_recipient, primaryStableBalance);\r\n        }\r\n        _lpDepositAll();\r\n    }\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\r\n        // Withdraw all from Gauge\r\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\r\n        // Withdraw all from Gauge\r\n        _lpWithdraw(gaugePTokens);\r\n        // Remove liquidity\r\n        ICurvePool aaveCurvePool = ICurvePool(platformAddress);\r\n        aaveCurvePool.remove_liquidity_one_coin(totalPTokens, int128(uint128(_getCoinIndex(address(primaryStable)))), 0, true);\r\n        uint256 balance = 0;\r\n        // Transfer assets out of Vault\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Withdrawing from the Synapse: \", primaryStableBalance);\r\n        if (primaryStableBalance > 0) {\r\n            primaryStable.safeTransfer(vaultAddress, primaryStableBalance);\r\n        }\r\n        _collectRewards();\r\n    }\r\n    function checkBalance()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        // LP tokens in this contract. This should generally be nothing as we\r\n        // should always stake the full balance in the Gauge, but include for\r\n        // safety\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        uint256 balance;\r\n        (, , uint256 totalPTokens) = _getTotalPTokens();\r\n        // console.log(\"Am3Curve - checkBalance - totalPTokens: \", totalPTokens);\r\n        ICurvePool curvePool = ICurvePool(platformAddress);\r\n        if (totalPTokens > 0) {\r\n            balance = curvePool.calc_withdraw_one_coin(totalPTokens,int128(uint128(_getCoinIndex(address(primaryStable)))));\r\n            // console.log(\"Am3Curve - checkBalance - primaryToken: \", balance);\r\n        }\r\n        return primaryStableBalance + balance;\r\n    }\r\n\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        _collectRewards();\r\n    }\r\n    function _collectRewards() internal {\r\n        crvMinter.mint(address(crvGauge));\r\n        uint256 crvBalance = crvToken.balanceOf(address(this));\r\n        if (crvBalance != 0) {\r\n            _swapExactTokensForTokens(\r\n                address(crvToken),\r\n                address(primaryStable),\r\n                crvBalance,\r\n                address(this)\r\n            );\r\n        }\r\n        uint256 balance = primaryStable.balanceOf(address(this));\r\n        emit RewardTokenCollected(\r\n            harvesterAddress,\r\n            address(primaryStable),\r\n            balance\r\n        );\r\n        primaryStable.transfer(harvesterAddress, balance);\r\n    }\r\n    function _lpDepositAll() internal override {\r\n        uint256 am3crvBalance = IERC20(pTokenAddress).balanceOf(address(this));\r\n        if (am3crvBalance > 0) {\r\n            IERC20(pTokenAddress).safeApprove(address(crvGauge),am3crvBalance);\r\n            crvGauge.deposit(am3crvBalance, address(this), false);\r\n        }\r\n    }\r\n\r\n    function _lpWithdraw(uint256 numPTokens) internal override {\r\n        crvGauge.withdraw(numPTokens,address(this),true);\r\n    }\r\n    function _getTotalPTokens()\r\n        internal\r\n        view\r\n        override\r\n        returns (\r\n            uint256 contractPTokens,\r\n            uint256 gaugePTokens, // gauge is a misnomer here, need a better name\r\n            uint256 totalPTokens\r\n        )\r\n    {\r\n        contractPTokens = IERC20(pTokenAddress).balanceOf(address(this));\r\n        gaugePTokens = crvGauge.balanceOf(address(this));\r\n        totalPTokens = contractPTokens + gaugePTokens;\r\n    }\r\n    /* NOT NEEDED */\r\n    function _approveBase() internal override {\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/ICurveGauge.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICurveGauge {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function deposit(uint256 value, address account) external;\r\n    function deposit(uint256 value, address account, bool claimRewards) external;\r\n    function deposit(uint256 value) external;\r\n    \r\n    function withdraw(uint256 value) external;\r\n    function withdraw(uint256 value, bool claimRewards) external;\r\n    function withdraw(uint256 value, address _user, bool claimRewards) external;\r\n\r\n    function claim_rewards() external;\r\n    function claim_rewards(address account) external;\r\n}\r\n"
    },
    "contracts/connectors/aave/interfaces/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IProtocolDataProvider {\r\n  struct TokenData {\r\n    string symbol;\r\n    address tokenAddress;\r\n  }\r\n\r\n  function getReserveConfigurationData(address asset) external view returns (uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen);\r\n  function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp);\r\n  function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled);\r\n  function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\r\n}"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Aave Strategy\r\n * @notice Investment strategy for investing stablecoins via Aave\r\n * @author Stabl Protocol Inc\r\n */ \r\nimport { SafeERC20 } from     \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\nimport { IAsset } from \"../interfaces/balancer/interfaces/IAsset.sol\";\r\nimport { IVault } from \"../interfaces/balancer/interfaces/IVault.sol\";\r\nimport { ILendingPoolAddressesProvider } from \"../connectors/aave/interfaces/ILendingPoolAddressesProvider.sol\";\r\nimport { ILendingPool } from \"../connectors/aave/interfaces/ILendingPool.sol\";\r\nimport { BalancerExchange } from \"../exchanges/BalancerExchange.sol\";\r\nimport { IProtocolDataProvider } from \"../connectors/aave/interfaces/IProtocolDataProvider.sol\";\r\nimport { IAaveIncentivesController } from \"../connectors/aave/interfaces/IAaveIncentivesController.sol\";\r\n\r\n\r\n// TODO: Should be modified to work with primaryStable.\r\n// TODO: SHOULD NOT BE USED FOR ANYTHING IN CURRENT STATE.\r\n\r\ncontract AaveStrategy is InitializableAbstractStrategy, BalancerExchange {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // TODO: Set referral code\r\n    uint16 constant referralCode = 0;\r\n\r\n    ILendingPoolAddressesProvider  public poolProvider;\r\n    IProtocolDataProvider public dataProvider;\r\n    IAaveIncentivesController public incentivesController;\r\n    ILendingPool public pool;\r\n\r\n    IERC20 public token;\r\n    IERC20 public harvestingToken;\r\n    IERC20 public variableDebtToken;\r\n\r\n    bytes32 public poolId;\r\n\r\n    uint256 public borrowRate;\r\n    uint256 public borrowDepth = 6;\r\n    uint256 public BORROW_DEPTH_MAX = 8;\r\n    uint256 public minLeverage;\r\n    uint256 public BORROW_RATE_MAX;\r\n    uint256 public BORROW_RATE_MAX_HARD;\r\n    uint256 public constant BORROW_RATE_DIVISOR = 10000;\r\n    \r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\r\n     * addresses for the rewards program.\r\n     * @param _platformAddress Address of the AAVE pool\r\n     * @param _vaultAddress Address of the vault\r\n     * @param _rewardTokenAddresses Address of the AAVE token\r\n     * @param _assets Addresses of supported assets\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // AAVE pool\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses, // AAVE\r\n        address[] calldata _assets,\r\n        address[] calldata _pTokens,\r\n        address[] calldata aaveContracts // aavePoolProvider, aaveDataProvider, aaveIncentivesController, variableDebtToken (in order)\r\n    ) external onlyGovernor initializer {\r\n        // console.log(\"BorrowDepth:\",borrowDepth);\r\n\r\n        harvestingToken = IERC20(_rewardTokenAddresses[0]);\r\n        token = IERC20(_assets[0]);\r\n\r\n\r\n        poolProvider = ILendingPoolAddressesProvider(aaveContracts[0]);\r\n        dataProvider = IProtocolDataProvider(aaveContracts[1]);\r\n        incentivesController = IAaveIncentivesController(aaveContracts[2]);\r\n        variableDebtToken =  IERC20(aaveContracts[3]);\r\n        pool = ILendingPool(poolProvider.getLendingPool());\r\n        // console.log(\"Pool:\",address(pool));\r\n\r\n        (,uint256 ltv,uint256 threshold,,,bool collateral,bool borrow,,,) = dataProvider.getReserveConfigurationData(address(token));\r\n        BORROW_RATE_MAX = ltv.mul(99).div(100); // 1%\r\n        BORROW_RATE_MAX_HARD = ltv.mul(999).div(1000); // 0.1%\r\n        // At minimum, borrow rate always 10% lower than liquidation threshold\r\n        if (threshold.mul(9).div(10) > BORROW_RATE_MAX) {\r\n            borrowRate = BORROW_RATE_MAX;\r\n        } else {\r\n            borrowRate = threshold.mul(9).div(10);\r\n        }\r\n        // console.log(\"Borrow: \", borrow);\r\n        // console.log(\"Collateral: \", collateral);\r\n        // Only leverage if you can\r\n        if (!(collateral && borrow)) {\r\n            // console.log(\"Setting borrow depth to 0\");\r\n            borrowDepth = 0;\r\n            BORROW_DEPTH_MAX = 0;\r\n        } else  {\r\n            // console.log(\"Setting borrow depth to 6\");\r\n            borrowDepth = 6;\r\n            BORROW_DEPTH_MAX = 8;\r\n        }\r\n        // console.log(\"BorrowDepth:\",borrowDepth);\r\n        minLeverage = 10 ** IERC20Metadata(address(token)).decimals();\r\n\r\n\r\n        InitializableAbstractStrategy._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n    function setBalancer(address _balancerVault, bytes32 _balancerPoolId) external onlyGovernor {\r\n        require(_balancerVault != address(0), \"Zero address not allowed\");\r\n        require(_balancerPoolId != \"\", \"Empty pool id not allowed\");\r\n\r\n        setBalancerVault(_balancerVault);\r\n        poolId = _balancerPoolId;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit asset into Aave\r\n     * @param _asset Address of asset to deposit\r\n     * @param _amount Amount of asset to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        override\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        // _deposit(_asset, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit asset into Aave\r\n     * @param _asset Address of asset to deposit\r\n     * @param _amount Amount of asset to deposit\r\n     */\r\n    function _deposit(address _asset, uint256 _amount) internal {\r\n        // require(_asset == address(token), \"Asset not supported\");\r\n        // require(_amount > 0, \"Must deposit something\");\r\n\r\n        // // console.log(\"Depositing \", _amount, \" of \", _asset);\r\n\r\n        // // token.approve(address(pool), _amount);\r\n        // _leverage(_amount);\r\n        // emit Deposit(_asset, _getATokenFor(_asset), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit the entire balance of any supported asset into Aave\r\n     */\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        // // console.log(\"Depositing All\");\r\n\r\n        // for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n        //     uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\r\n        //     if (balance > 0) {\r\n        //         _deposit(assetsMapped[i], balance);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    function _supply(uint256 _amount) internal {\r\n        // console.log(\"Suppling: \", _amount);\r\n        pool.deposit(address(token), _amount, address(this), referralCode);\r\n    }\r\n    function _removeSupply(uint256 _amount) internal {\r\n        // console.log(\"Removing supply: \", _amount);\r\n        pool.withdraw(address(token), _amount, address(this));\r\n    }\r\n    function _borrow(uint256 _amount) internal {\r\n        // console.log(\"Borrowing: \", _amount);\r\n        pool.borrow(address(token), _amount, 2, referralCode, address(this));\r\n    }\r\n    function _repayBorrow(uint256 _amount) internal {\r\n        // console.log(\"Repay Borrow: \", _amount);\r\n        pool.repay(address(token), _amount, 2, address(this));\r\n    }\r\n    // function _leverage(uint256 _amount) internal {\r\n    //     // console.log(\"Calling leverage with borrowDepth\", borrowDepth);\r\n    //     if (_amount > minLeverage) {\r\n    //         for (uint256 i = 0; i < borrowDepth; i++) {\r\n    //             // console.log(\"Depositing\", _amount, \"at\", i);\r\n    //             _supply(_amount);\r\n    //             _amount = _amount.mul(borrowRate).div(BORROW_RATE_DIVISOR);\r\n    //             // console.log(\"Borrowing\", _amount, \"at\", i);\r\n    //             _borrow(_amount);\r\n    //         }\r\n    //     }\r\n    // }\r\n    // function _deleverage() internal {\r\n    //     uint256 wantBal = _tokenBalance();\r\n    //     // console.log(\"Deleveraging: \", wantBal, _debtTotal());\r\n\r\n    //     while (wantBal < _debtTotal()) {\r\n    //         // console.log(\"Deleveraging: \", wantBal, \" is less than \", _debtTotal());\r\n    //         _repayBorrow(wantBal);\r\n    //         _removeSupply(_checkBalance(address(token)).sub(_supplyBalMin()));\r\n    //         wantBal = _tokenBalance();\r\n    //     }\r\n    //     _repayBorrow(wantBal);\r\n    //     // console.log(_tokenBalance());\r\n    //     // console.log(_checkBalance(address(token)));\r\n    //     // console.log(_checkBalance(address(token)).sub(_supplyBalMin()));\r\n    //     _removeSupply(type(uint256).max);\r\n    // }\r\n    // function _debtTotal() internal returns (uint256) {\r\n    //     uint256 debt = variableDebtToken.balanceOf(address(this));\r\n    //     return debt;\r\n    // }\r\n    // function _supplyBalMin() internal returns (uint256) {\r\n    //     return _debtTotal().mul(BORROW_RATE_DIVISOR).div(BORROW_RATE_MAX_HARD);\r\n    // }\r\n    // function _tokenBalance() internal view returns (uint256) {\r\n    //     return IERC20(token).balanceOf(address(this));\r\n    // }\r\n    // function _assetLockedTotal() internal returns (uint256) {\r\n    //     return _tokenBalance()\r\n    //         .add(_checkBalance(address(token)))\r\n    //         .sub(_debtTotal());\r\n    // }\r\n\r\n\r\n    function _withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) internal  onlyVault  {\r\n        // require(_amount > 0, \"Must withdraw something\");\r\n        // require(_recipient != address(0), \"Must specify recipient\");\r\n        // require(_asset == address(token), \"Asset not supported\");\r\n        // emit Withdrawal(_asset, _getATokenFor(_asset), _amount);\r\n\r\n        // // console.log(\"_Withdrawing \", _amount, \" of \", _asset);\r\n\r\n        // uint256 tokenBalance = _tokenBalance();\r\n        // if (_amount >= tokenBalance) {\r\n        //     // Fully deleverage, cheap in Polygon\r\n        //     _deleverage();\r\n        //     tokenBalance = _tokenBalance();\r\n        // }\r\n        // if (_amount > tokenBalance) {\r\n        //     _amount = tokenBalance;\r\n        // }\r\n        // if (_amount > _assetLockedTotal()) {\r\n        //     _amount = _assetLockedTotal();\r\n        // }\r\n        // // console.log(\"Transferring \", _amount, \" to \", _recipient);\r\n        // IERC20(token).safeTransfer(_recipient, _amount);\r\n        // // console.log(\"Still there is token: \", _tokenBalance());\r\n        // _leverage(token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw asset from Aave\r\n     * @param _recipient Address to receive withdrawn asset\r\n     * @param _asset Address of asset to withdraw\r\n     * @param _amount Amount of asset to withdraw\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant {\r\n        // _withdraw(_recipient, _asset, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\r\n        // console.log(\"Withdrawing All\");\r\n        // _withdraw(vaultAddress, address(token),_tokenBalance().add(_checkBalance(address(token))));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the total asset value held in the platform\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n        // Balance is always with token aToken decimals\r\n        // address aToken = _getATokenFor(_asset);\r\n        // balance = IERC20(aToken).balanceOf(address(this));\r\n    }\r\n    function _checkBalance()\r\n        internal\r\n        returns (uint256 balance)\r\n    {\r\n        // Balance is always with token aToken decimals\r\n        // address aToken = _getATokenFor(_asset);\r\n        // balance = IERC20(aToken).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return assetToPToken[_asset] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding aToken,\r\n     *      if for some reason is it necessary.\r\n     */\r\n    function safeApproveAllTokens()\r\n        external\r\n        override\r\n        onlyGovernor\r\n        nonReentrant\r\n    {\r\n        // approve the pool to spend the Asset\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            address asset = assetsMapped[i];\r\n            // Safe approval\r\n            IERC20(asset).safeApprove(address(pool), 0);\r\n            IERC20(asset).safeApprove(address(pool), type(uint256).max);\r\n            IERC20(asset).safeApprove(address(incentivesController), 0);\r\n            IERC20(asset).safeApprove(address(incentivesController), type(uint256).max);\r\n            IERC20(_getATokenFor(asset)).safeApprove(address(incentivesController), 0);\r\n            IERC20(_getATokenFor(asset)).safeApprove(address(incentivesController), type(uint256).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to respond to the addition of new asset / aTokens\r\n            We need to give the AAVE lending pool approval to transfer the\r\n            asset.\r\n     * @param _asset Address of the asset to approve\r\n     * @param _aToken Address of the aToken\r\n     */\r\n    function _abstractSetPToken(address _asset, address _aToken)\r\n        internal\r\n        override\r\n    {\r\n        IERC20(_asset).safeApprove(address(pool), 0);\r\n        IERC20(_asset).safeApprove(address(pool), type(uint256).max);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Get the aToken wrapped in the IERC20 interface for this asset.\r\n     *      Fails if the pToken doesn't exist in our mappings.\r\n     * @param _asset Address of the asset\r\n     * @return Corresponding aToken to this asset\r\n     */\r\n    function _getATokenFor(address _asset) internal view returns (address) {\r\n        address aToken = assetToPToken[_asset];\r\n        require(aToken != address(0), \"aToken does not exist\");\r\n        return aToken;\r\n    }\r\n    function getRewardBalance() internal returns (uint256) {\r\n        return IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270).balanceOf(address(this)); //wMATIC\r\n    }\r\n\r\n    /**\r\n     * @dev Collect stkAave, convert it to AAVE send to Vault.\r\n     */\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        // uint256 preEarn = getRewardBalance();\r\n        // // console.log(\"Token Balance: \", preEarn);\r\n        // // console.log(\"aToken Balance: \", _checkBalance(address(token)));\r\n        // // console.log(\"DebtToken Balance: \", _debtTotal() );\r\n\r\n        // // Harvest farm tokens\r\n        // address[] memory deptTokens = new address[](1);\r\n        // deptTokens[0] = 0x1a13F4Ca1d028320A707D99520AbFefca3998b7F; // amUSDC\r\n        // // console.log(\"Claiming rewards\");\r\n        // // console.log(\"Rewards: \", IAaveIncentivesController(incentivesController).getUserUnclaimedRewards(address(this)));\r\n        // // console.log(\"Rewards: \", IAaveIncentivesController(incentivesController).getRewardsBalance(deptTokens, address(this)));\r\n\r\n        // IAaveIncentivesController(incentivesController).claimRewards(deptTokens, type(uint256).max, address(this));\r\n        // // Because we keep some tokens in this contract, we have to do this if earned is the same as want\r\n        // // console.log(\"New reward balance: \", getRewardBalance());\r\n        // // console.log(\"New token balance: \", _tokenBalance());\r\n        // // console.log(\"New aToken Balance: \", _checkBalance(address(token)));\r\n        // // console.log(\"New DebtToken Balance: \", _debtTotal() );\r\n        // uint256 earnedAmt = getRewardBalance().sub(preEarn);\r\n        // // console.log(\"Reward Balance: \", earnedAmt);\r\n\r\n\r\n        // if (earnedAmt > 0) {\r\n        //     if (address(token) != address(harvestingToken)) {\r\n        //         earnedAmt = swap(\r\n        //             poolId,\r\n        //             IVault.SwapKind.GIVEN_IN,\r\n        //             IAsset(address(token)),\r\n        //             IAsset(address(harvestingToken)),\r\n        //             address(this),\r\n        //             address(this),\r\n        //             earnedAmt,\r\n        //             0\r\n        //         );\r\n        //     }\r\n        //     emit RewardTokenCollected(\r\n        //         harvesterAddress,\r\n        //         address(harvestingToken),\r\n        //         earnedAmt\r\n        //     );\r\n        //     // console.log(\"Transferring \", earnedAmt, \" to Harvester\");\r\n        //     harvestingToken.transfer(harvesterAddress, earnedAmt);\r\n        //     // Releverage what is left in the startegy\r\n        //     // _leverage(_tokenBalance());\r\n        // }\r\n    }\r\n}\r\n"
    },
    "contracts/connectors/aave/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IAaveIncentivesController {\r\n  \r\n  event RewardsAccrued(address indexed user, uint256 amount);\r\n  \r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    address indexed to,\r\n    address indexed claimer,\r\n    uint256 amount\r\n  );\r\n\r\n  event ClaimerSet(address indexed user, address indexed claimer);\r\n\r\n  /**\r\n   * @dev Whitelists an address to claim the rewards on behalf of another address\r\n   * @param user The address of the user\r\n   * @param claimer The address of the claimer\r\n   */\r\n  function setClaimer(address user, address claimer) external;\r\n\r\n  /**\r\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\r\n   * @param user The address of the user\r\n   * @return The claimer address\r\n   */\r\n  function getClaimer(address user) external view returns (address);\r\n\r\n  /**\r\n   * @dev Configure assets for a certain rewards emission\r\n   * @param assets The assets to incentivize\r\n   * @param emissionsPerSecond The emission for each asset\r\n   */\r\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\r\n    external;\r\n\r\n\r\n  /**\r\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\r\n   * @param asset The address of the user\r\n   * @param userBalance The balance of the user of the asset in the lending pool\r\n   * @param totalSupply The total supply of the asset in the lending pool\r\n   **/\r\n  function handleAction(\r\n    address asset,\r\n    uint256 userBalance,\r\n    uint256 totalSupply\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n   * @param user The address of the user\r\n   * @return The rewards\r\n   **/\r\n  function getRewardsBalance(address[] calldata assets, address user)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n   * @param amount Amount of rewards to claim\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n   * @param amount Amount of rewards to claim\r\n   * @param user Address to check and claim rewards\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewardsOnBehalf(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address user,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @return the unclaimed user rewards\r\n   */\r\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\r\n\r\n  /**\r\n  * @dev for backward compatibility with previous implementation of the Incentives controller\r\n  */\r\n  function REWARD_TOKEN() external view returns (address);\r\n}"
    },
    "contracts/interfaces/balancer/MerkleOrchard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IDistributorCallback.sol\";\n\npragma solidity >=0.8.0 <0.9.0;\n\ncontract MerkleOrchard {\n    using SafeERC20 for IERC20;\n\n    // Recorded distributions\n    // channelId > distributionId\n    mapping(bytes32 => uint256) private _nextDistributionId;\n    // channelId > distributionId > root\n    mapping(bytes32 => mapping(uint256 => bytes32)) private _distributionRoot;\n    // channelId > claimer > distributionId / 256 (word index) -> bitmap\n    mapping(bytes32 => mapping(address => mapping(uint256 => uint256))) private _claimedBitmap;\n    // channelId > balance\n    mapping(bytes32 => uint256) private _remainingBalance;\n\n    event DistributionAdded(\n        address indexed distributor,\n        IERC20 indexed token,\n        uint256 distributionId,\n        bytes32 merkleRoot,\n        uint256 amount\n    );\n    event DistributionClaimed(\n        address indexed distributor,\n        IERC20 indexed token,\n        uint256 distributionId,\n        address indexed claimer,\n        address recipient,\n        uint256 amount\n    );\n\n    IVault private immutable _vault;\n\n    constructor(IVault vault) {\n        _vault = vault;\n    }\n\n    struct Claim {\n        uint256 distributionId;\n        uint256 balance;\n        address distributor;\n        uint256 tokenIndex;\n        bytes32[] merkleProof;\n    }\n\n    // Getters\n    function getVault() public view returns (IVault) {\n        return _vault;\n    }\n\n    function getDistributionRoot(\n        IERC20 token,\n        address distributor,\n        uint256 distributionId\n    ) external view returns (bytes32) {\n        bytes32 channelId = _getChannelId(token, distributor);\n        return _distributionRoot[channelId][distributionId];\n    }\n\n    function getRemainingBalance(IERC20 token, address distributor) external view returns (uint256) {\n        bytes32 channelId = _getChannelId(token, distributor);\n        return _remainingBalance[channelId];\n    }\n\n    /**\n     * @notice distribution ids must be sequential and can have an optional offset\n     */\n    function getNextDistributionId(IERC20 token, address distributor) external view returns (uint256) {\n        bytes32 channelId = _getChannelId(token, distributor);\n        return _nextDistributionId[channelId];\n    }\n\n    function isClaimed(\n        IERC20 token,\n        address distributor,\n        uint256 distributionId,\n        address claimer\n    ) public view returns (bool) {\n        (uint256 distributionWordIndex, uint256 distributionBitIndex) = _getIndices(distributionId);\n\n        bytes32 channelId = _getChannelId(token, distributor);\n        return (_claimedBitmap[channelId][claimer][distributionWordIndex] & (1 << distributionBitIndex)) != 0;\n    }\n\n    function verifyClaim(\n        IERC20 token,\n        address distributor,\n        uint256 distributionId,\n        address claimer,\n        uint256 claimedBalance,\n        bytes32[] memory merkleProof\n    ) external view returns (bool) {\n        bytes32 channelId = _getChannelId(token, distributor);\n        return _verifyClaim(channelId, distributionId, claimer, claimedBalance, merkleProof);\n    }\n\n    // Claim functions\n\n    /**\n     * @notice Allows anyone to claim multiple distributions for a claimer.\n     */\n    function claimDistributions(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens\n    ) external {\n        _processClaims(claimer, claimer, claims, tokens, false);\n    }\n\n    /**\n     * @notice Allows a user to claim their own multiple distributions to internal balance.\n     */\n    function claimDistributionsToInternalBalance(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, claimer, claims, tokens, true);\n    }\n\n    /**\n     * @notice Allows a user to claim their own several distributions to a callback.\n     */\n    function claimDistributionsWithCallback(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens,\n        IDistributorCallback callbackContract,\n        bytes calldata callbackData\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, address(callbackContract), claims, tokens, true);\n        callbackContract.distributorCallback(callbackData);\n    }\n\n    /**\n     * @notice Allows a distributor to add funds to the contract as a merkle tree.\n     */\n    function createDistribution(\n        IERC20 token,\n        bytes32 merkleRoot,\n        uint256 amount,\n        uint256 distributionId\n    ) external {\n        address distributor = msg.sender;\n\n        bytes32 channelId = _getChannelId(token, distributor);\n        require(\n            _nextDistributionId[channelId] == distributionId || _nextDistributionId[channelId] == 0,\n            \"invalid distribution ID\"\n        );\n        token.safeTransferFrom(distributor, address(this), amount);\n\n        token.approve(address(getVault()), amount);\n        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](1);\n\n        ops[0] = IVault.UserBalanceOp({\n            asset: IAsset(address(token)),\n            amount: amount,\n            sender: address(this),\n            recipient: payable(address(this)),\n            kind: IVault.UserBalanceOpKind.DEPOSIT_INTERNAL\n        });\n\n        getVault().manageUserBalance(ops);\n\n        _remainingBalance[channelId] += amount;\n        _distributionRoot[channelId][distributionId] = merkleRoot;\n        _nextDistributionId[channelId] = distributionId + 1;\n        emit DistributionAdded(distributor, token, distributionId, merkleRoot, amount);\n    }\n\n    // Helper functions\n\n    function _getChannelId(IERC20 token, address distributor) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(token, distributor));\n    }\n\n    function _processClaims(\n        address claimer,\n        address recipient,\n        Claim[] memory claims,\n        IERC20[] memory tokens,\n        bool asInternalBalance\n    ) internal {\n        uint256[] memory amounts = new uint256[](tokens.length);\n\n        // To save gas when setting claimed statuses in storage, we group claims for each channel and word index\n        // (referred to as a 'claims set'), aggregating the claim bits to set and total claimed amount, only committing\n        // to storage when changing claims sets (or when processing the last claim).\n        // This means that callers should sort claims by grouping distribution channels and distributions with the same\n        // word index in order to achieve reduced gas costs.\n\n        // Variables to support claims set aggregation\n        bytes32 currentChannelId; // Since channel ids are a hash, the initial zero id can be safely considered invalid\n        uint256 currentWordIndex;\n\n        uint256 currentBits; // The accumulated claimed bits to set in storage\n        uint256 currentClaimAmount; // The accumulated tokens to be claimed from the current channel (not claims set!)\n\n        Claim memory claim;\n        for (uint256 i = 0; i < claims.length; i++) {\n            claim = claims[i];\n\n            // New scope to avoid stack-too-deep issues\n            {\n                (uint256 distributionWordIndex, uint256 distributionBitIndex) = _getIndices(claim.distributionId);\n\n                if (currentChannelId == _getChannelId(tokens[claim.tokenIndex], claim.distributor)) {\n                    if (currentWordIndex == distributionWordIndex) {\n                        // Same claims set as the previous one: simply track the new bit to set.\n                        currentBits |= 1 << distributionBitIndex;\n                    } else {\n                        // This case is an odd exception: the claims set is not the same, but the channel id is. This\n                        // happens for example when there are so many distributions that they don't fit in a single 32\n                        // byte bitmap.\n                        // Since the channel is the same, we can continue accumulating the claim amount, but must commit\n                        // the previous claim bits as they correspond to a different word index.\n                        _setClaimedBits(currentChannelId, claimer, currentWordIndex, currentBits);\n\n                        // Start a new claims set, except channel id is the same as the previous one, and amount is not\n                        // reset.\n                        currentWordIndex = distributionWordIndex;\n                        currentBits = 1 << distributionBitIndex;\n                    }\n\n                    // Amounts are always accumulated for the same channel id\n                    currentClaimAmount += claim.balance;\n                } else {\n                    // Skip initial invalid claims set\n                    if (currentChannelId != bytes32(0)) {\n                        // Commit previous claims set\n                        _setClaimedBits(currentChannelId, claimer, currentWordIndex, currentBits);\n                        _deductClaimedBalance(currentChannelId, currentClaimAmount);\n                    }\n\n                    // Start a new claims set\n                    currentChannelId = _getChannelId(tokens[claim.tokenIndex], claim.distributor);\n                    currentWordIndex = distributionWordIndex;\n                    currentBits = 1 << distributionBitIndex;\n                    currentClaimAmount = claim.balance;\n                }\n            }\n\n            // Since a claims set is only committed if the next one is not part of the same set, the last claims set\n            // must be manually committed always.\n            if (i == claims.length - 1) {\n                _setClaimedBits(currentChannelId, claimer, currentWordIndex, currentBits);\n                _deductClaimedBalance(currentChannelId, currentClaimAmount);\n            }\n\n            require(\n                _verifyClaim(currentChannelId, claim.distributionId, claimer, claim.balance, claim.merkleProof),\n                \"incorrect merkle proof\"\n            );\n\n            // Note that balances to claim are here accumulated *per token*, independent of the distribution channel and\n            // claims set accounting.\n            amounts[claim.tokenIndex] += claim.balance;\n\n            emit DistributionClaimed(\n                claim.distributor,\n                tokens[claim.tokenIndex],\n                claim.distributionId,\n                claimer,\n                recipient,\n                claim.balance\n            );\n        }\n\n        IVault.UserBalanceOpKind kind = asInternalBalance\n            ? IVault.UserBalanceOpKind.TRANSFER_INTERNAL\n            : IVault.UserBalanceOpKind.WITHDRAW_INTERNAL;\n        IVault.UserBalanceOp[] memory ops = new IVault.UserBalanceOp[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ops[i] = IVault.UserBalanceOp({\n                asset: IAsset(address(tokens[i])),\n                amount: amounts[i],\n                sender: address(this),\n                recipient: payable(recipient),\n                kind: kind\n            });\n        }\n        getVault().manageUserBalance(ops);\n    }\n\n    /**\n     * @dev Sets the bits set in `newClaimsBitmap` for the corresponding distribution.\n     */\n    function _setClaimedBits(\n        bytes32 channelId,\n        address claimer,\n        uint256 wordIndex,\n        uint256 newClaimsBitmap\n    ) private {\n        uint256 currentBitmap = _claimedBitmap[channelId][claimer][wordIndex];\n\n        // All newly set bits must not have been previously set\n        require((newClaimsBitmap & currentBitmap) == 0, \"cannot claim twice\");\n\n        _claimedBitmap[channelId][claimer][wordIndex] = currentBitmap | newClaimsBitmap;\n    }\n\n    /**\n     * @dev Deducts `balanceBeingClaimed` from a distribution channel's allocation. This isolates tokens accross\n     * distribution channels, and prevents claims for one channel from using the tokens of another one.\n     */\n    function _deductClaimedBalance(bytes32 channelId, uint256 balanceBeingClaimed) private {\n        require(\n            _remainingBalance[channelId] >= balanceBeingClaimed,\n            \"distributor hasn't provided sufficient tokens for claim\"\n        );\n        _remainingBalance[channelId] -= balanceBeingClaimed;\n    }\n\n    function _verifyClaim(\n        bytes32 channelId,\n        uint256 distributionId,\n        address claimer,\n        uint256 claimedBalance,\n        bytes32[] memory merkleProof\n    ) internal view returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(claimer, claimedBalance));\n        return MerkleProof.verify(merkleProof, _distributionRoot[channelId][distributionId], leaf);\n    }\n\n    function _getIndices(uint256 distributionId)\n        private\n        pure\n        returns (uint256 distributionWordIndex, uint256 distributionBitIndex)\n    {\n        distributionWordIndex = distributionId / 256;\n        distributionBitIndex = distributionId % 256;\n    }\n}\n"
    },
    "contracts/interfaces/balancer/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/interfaces/balancer/interfaces/IDistributorCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDistributorCallback {\n    function distributorCallback(bytes calldata callbackData) external;\n}\n"
    },
    "contracts/strategies/DodoStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Synapse Strategy\r\n * @notice Investment strategy for investing stablecoins via Synapse\r\n */\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nimport { IPool } from \"./../connectors/synapse/IPool.sol\";\r\nimport { IStakerPool } from \"./../connectors/synapse/IStakerPool.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\r\n\r\nimport { OvnMath } from \"../utils/OvnMath.sol\";\r\nimport { StrategyDodoLibrary } from \"../utils/StrategyDodoLibrary.sol\";\r\nimport \"./../connectors/dodo/IDODOV1.sol\";\r\nimport \"./../connectors/dodo/IDODOV2.sol\";\r\nimport \"./../connectors/dodo/IDODOMine.sol\";\r\n\r\nimport \"../exchanges/BalancerExchange.sol\";\r\nimport \"../exchanges/DodoExchange.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\n\r\ncontract DodoStrategy is InitializableAbstractStrategy, BalancerExchange, DodoExchange {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using OvnMath for uint256;\r\n\r\n\r\n    IERC20 public usdtToken; // form intializers\r\n    IERC20 public dodoToken; // platform Address\r\n    IERC20 public wmaticToken; // intermediary Address\r\n    IERC20 public usdcLPToken; // pToken \r\n\r\n    IERC20 public primaryStable; \r\n\r\n\r\n    IDODOV1 public dodoV1UsdcUsdtPool;\r\n    IDODOV2 public dodoV2DodoUsdtPool;\r\n    IDODOMine public dodoMine;\r\n\r\n    bytes32 public balancerPoolIdUsdcTusdDaiUsdt;\r\n    bytes32 public balancerPoolIdWmaticUsdcWethBal;\r\n\r\n    /**\r\n     * Initializer for setting up strategy internal state. This overrides the\r\n     * InitializableAbstractStrategy initializer as Dodo strategies don't fit\r\n     * well within that abstraction.\r\n     * @param _platformAddress Address of the nUSD\r\n     * @param _vaultAddress Address of the vault\r\n     * @param _rewardTokenAddresses Address of USDC\r\n     * @param _assets Addresses of supported assets. MUST be passed in the same\r\n     *                order as returned by coins on the pool contract, i.e.\r\n     *                USDC\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress, // DODO Token address\r\n        address _vaultAddress,\r\n        address[] calldata _rewardTokenAddresses, // USDC\r\n        address[] calldata _assets, // USDC\r\n        address[] calldata _pTokens, // usdcLPToken Token address\r\n        address _usdtToken, // USDT\r\n        address _wMaticToken, // wMATIC\r\n        address[] calldata dodoAddresses // In ORDER: _dodoV1UsdcUsdtPool,  _dodoV2DodoUsdtPool,  _dodoMine,  _dodoV1Helper,  _dodoProxy,  _dodoApprove\r\n    ) external onlyGovernor initializer {\r\n        usdcLPToken = IERC20(_pTokens[0]);\r\n        usdtToken = IERC20(_usdtToken);\r\n        wmaticToken = IERC20(_wMaticToken);\r\n        dodoToken = IERC20(_platformAddress);\r\n        dodoV1UsdcUsdtPool = IDODOV1(dodoAddresses[0]);\r\n        dodoV2DodoUsdtPool = IDODOV2(dodoAddresses[1]);\r\n        dodoMine = IDODOMine(dodoAddresses[2]);\r\n        _setDodoParams(dodoAddresses[3], dodoAddresses[4], dodoAddresses[5]);\r\n\r\n        super._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddresses,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n    function setBalancerAndPrimaryStable(address _primaryStable, address _balancerVault, bytes32 _balancerPoolIdUsdcTusdDaiUsdt, bytes32 _balancerPoolIdWmaticUsdcWethBal) external onlyGovernor {\r\n        require(_primaryStable != address(0), \"Zero address not allowed\");\r\n        require(_balancerVault != address(0), \"Zero address not allowed\");\r\n        require(_balancerPoolIdUsdcTusdDaiUsdt != \"\", \"Empty pool id not allowed\");\r\n        require(_balancerPoolIdWmaticUsdcWethBal != \"\", \"Empty pool id not allowed\");\r\n        primaryStable = IERC20(_primaryStable);\r\n        setBalancerVault(_balancerVault);\r\n        balancerPoolIdUsdcTusdDaiUsdt = _balancerPoolIdUsdcTusdDaiUsdt;\r\n        balancerPoolIdWmaticUsdcWethBal = _balancerPoolIdWmaticUsdcWethBal;\r\n    }\r\n    function _deposit(address _asset, uint256 _amount)\r\n        internal\r\n    {\r\n        require(( (_asset == address(primaryStable)) && (_asset == assetsMapped[0] ) ), \"Token not supported.\");\r\n\r\n        // stake all usdc tokens\r\n        uint256 primaryStableAmount = primaryStable.balanceOf(address(this));\r\n        // console.log(\"Depositing \", primaryStableAmount, \" usdc tokens to DODO\");\r\n        emit TransferLog(\"Depositing into DODO : \", _asset, primaryStableAmount);\r\n\r\n        // add liquidity to pool\r\n        primaryStable.approve(address(dodoV1UsdcUsdtPool), primaryStableAmount);\r\n        dodoV1UsdcUsdtPool.depositBaseTo(address(this), primaryStableAmount);\r\n\r\n        // stake all lp tokens\r\n        uint256 usdcLPTokenBalance = usdcLPToken.balanceOf(address(this));\r\n        usdcLPToken.approve(address(dodoMine), usdcLPTokenBalance);\r\n        dodoMine.deposit(usdcLPTokenBalance);\r\n    }\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        override\r\n        onlyVault\r\n        nonReentrant\r\n    {\r\n        _deposit(_asset, _amount);\r\n    }\r\n    function depositAll() external override onlyVault nonReentrant {\r\n        _deposit(address(primaryStable), primaryStable.balanceOf(address(this)));\r\n    }\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external override onlyVault nonReentrant  {\r\n        require(( (_asset == address(primaryStable)) && (_asset == assetsMapped[0] ) ), \"Token not supported.\");\r\n        // console.log(\"Starting withdrawing from DODO of\",_asset, _amount);\r\n        uint256 amountToUnstake = StrategyDodoLibrary._getAmountIn(_amount, dodoV1UsdcUsdtPool);\r\n\r\n        // get lp tokens\r\n        uint256 usdcLPTokenTotalSupply = usdcLPToken.totalSupply();\r\n        (uint256 baseTarget,) = dodoV1UsdcUsdtPool.getExpectedTarget();\r\n        uint256 unstakeLpBalance = amountToUnstake * usdcLPTokenTotalSupply / baseTarget;\r\n        uint256 userLPBalance = dodoMine.balanceOf(address(this));\r\n        if (unstakeLpBalance > userLPBalance) {\r\n            unstakeLpBalance = userLPBalance;\r\n        }\r\n\r\n        // unstake lp tokens\r\n        dodoMine.withdraw(unstakeLpBalance);\r\n\r\n        // remove liquidity from pool\r\n        dodoV1UsdcUsdtPool.withdrawAllBase();\r\n\r\n        // return all usdc tokens\r\n        uint256 assetBalance = primaryStable.balanceOf(address(this));\r\n        if (assetBalance > 0) {\r\n            emit TransferLog(\"Withdrawing from the DODO: \",assetsMapped[0], assetBalance);\r\n            IERC20(assetsMapped[0]).safeTransfer(vaultAddress, assetBalance);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\r\n        // get all lp tokens\r\n        uint256 userLPBalance = dodoMine.balanceOf(address(this));\r\n        if (userLPBalance == 0) {\r\n            return;\r\n        }\r\n        // unstake lp tokens\r\n        dodoMine.withdraw(userLPBalance);\r\n        // remove liquidity from pool\r\n        dodoV1UsdcUsdtPool.withdrawAllBase();\r\n        uint256 assetBalance = primaryStable.balanceOf(address(this));\r\n\r\n        // console.log(\"Withdrawing  everthing from the DODO: \", assetBalance);\r\n        emit TransferLog(\"Withdrawing  everthing from the DODO: \",  assetsMapped[0], assetBalance);\r\n\r\n        if (assetBalance > 0) {\r\n            IERC20(assetsMapped[0]).safeTransfer(vaultAddress, assetBalance);\r\n        }\r\n    }\r\n    function collectRewardTokens()\r\n        external\r\n        override\r\n        onlyHarvester\r\n        nonReentrant\r\n    {\r\n        uint256 userLPBalance = dodoMine.balanceOf(address(this));\r\n        if (userLPBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        // claim rewards\r\n        dodoMine.claimAllRewards();\r\n\r\n        // sell rewards\r\n        uint256 totalPrimaryStable;\r\n\r\n        uint256 dodoBalance = dodoToken.balanceOf(address(this));\r\n        // console.log(\"dodoBalance\", dodoBalance);\r\n        if (dodoBalance > 0) {\r\n            // swap v2 dodo -> usdt\r\n            uint256 usdtTokenAmount = _useDodoSwapV2(\r\n                address(dodoV2DodoUsdtPool),\r\n                address(dodoToken),\r\n                address(usdtToken),\r\n                dodoBalance,\r\n                1,\r\n                0\r\n            );\r\n            // console.log(usdtTokenAmount);\r\n\r\n            uint256 primaryStableAmount;\r\n            if (usdtTokenAmount > 0) {\r\n                // swap v1 usdt -> PrimaryStable\r\n                primaryStableAmount = swap(\r\n                    balancerPoolIdUsdcTusdDaiUsdt,\r\n                    IVault.SwapKind.GIVEN_IN,\r\n                    IAsset(address(usdtToken)),\r\n                    IAsset(address(primaryStable)),\r\n                    address(this),\r\n                    address(this),\r\n                    usdtTokenAmount,\r\n                    0\r\n                );\r\n            }\r\n            // console.log(\"primaryStableAmount\", primaryStableAmount);\r\n            totalPrimaryStable += primaryStableAmount;\r\n        }\r\n\r\n        uint256 wmaticBalance = wmaticToken.balanceOf(address(this));\r\n        // console.log(\"wmaticBalance\", wmaticBalance);\r\n        if (wmaticBalance > 0) {\r\n            uint256 wmaticPrimaryStable = swap(\r\n                balancerPoolIdWmaticUsdcWethBal,\r\n                IVault.SwapKind.GIVEN_IN,\r\n                IAsset(address(wmaticToken)),\r\n                IAsset(address(primaryStable)),\r\n                address(this),\r\n                address(this),\r\n                wmaticBalance,\r\n                0\r\n            );\r\n            // console.log(\"wmaticPrimaryStable\", wmaticPrimaryStable);\r\n\r\n            totalPrimaryStable += wmaticPrimaryStable;\r\n        }\r\n        // console.log(\"totalPrimaryStable\", totalPrimaryStable);\r\n\r\n        if (totalPrimaryStable > 0) {\r\n            emit RewardTokenCollected(\r\n                harvesterAddress,\r\n                address(primaryStable),\r\n                totalPrimaryStable\r\n            );\r\n            primaryStable.transfer(harvesterAddress, totalPrimaryStable);\r\n        }\r\n        return;\r\n    }\r\n    function checkBalance()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n\r\n        uint256 primaryStableBalance = primaryStable.balanceOf(address(this));\r\n        // console.log(\"primaryStableBalance\", primaryStableBalance);\r\n        uint256 userLPBalance = dodoMine.balanceOf(address(this));\r\n        // console.log(\"userLPBalance\", userLPBalance);\r\n        if (userLPBalance > 0) {\r\n            uint256 usdcLPTokenTotalSupply = usdcLPToken.totalSupply();\r\n            // console.log(\"usdcLPTokenTotalSupply\", usdcLPTokenTotalSupply);\r\n            (uint256 baseTarget,) = dodoV1UsdcUsdtPool.getExpectedTarget();\r\n            // console.log(\"baseTarget\", baseTarget);\r\n            uint256 primaryStableAmount = baseTarget * userLPBalance / usdcLPTokenTotalSupply;\r\n            // console.log(\"primaryStableAmount\", primaryStableAmount);\r\n            primaryStableBalance += primaryStableAmount - (primaryStableAmount * 6 / 10000); // - 0.06 %\r\n        }\r\n        return primaryStableBalance;\r\n    }\r\n    function supportsAsset(address _asset)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return ( (_asset == address(primaryStable)) && (_asset == assetsMapped[0] ) );\r\n    }\r\n    /* NOT NEEDED */\r\n    function safeApproveAllTokens() external override  {}\r\n    function _abstractSetPToken(address _asset, address _cToken)internal override {}\r\n}\r\n"
    },
    "contracts/utils/StrategyDodoLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"../connectors/dodo/IDODOV1.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./DecimalMath.sol\";\r\nimport \"hardhat/console.sol\";\r\nlibrary StrategyDodoLibrary {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    struct Context {\r\n        IDODOV1 dodo;\r\n        uint256 amountOut;\r\n        uint256 fairAmount;\r\n        uint256 targetBase;\r\n        uint256 dd;\r\n        uint256 a;\r\n        uint256 b;\r\n        uint256 c;\r\n        uint256 d;\r\n        uint256 e;\r\n        uint256 g;\r\n        uint256 h;\r\n        uint256 i;\r\n    }\r\n\r\n    function _getAmountIn(uint256 amountOut, IDODOV1 dodo) internal view returns (uint256) {\r\n        if (dodo._R_STATUS_() != IDODOV1.RStatus.ABOVE_ONE) {\r\n            return amountOut;\r\n        }\r\n\r\n        Context memory ctx;\r\n        ctx.dodo = dodo;\r\n        ctx.amountOut = amountOut;\r\n\r\n        ctx.fairAmount = _fairAmount(ctx);\r\n        console.log(\"fairAmount:\",ctx.fairAmount);\r\n\r\n        ctx.targetBase = _solveQuadraticFunctionForTargetCeil(ctx);\r\n        console.log(\"targetBase:\", ctx.targetBase );\r\n        ctx.dd = getDD(ctx);\r\n        ctx.a = getA(ctx);\r\n        ctx.b = getB(ctx);\r\n        ctx.c = getC(ctx);\r\n        ctx.d = getD(ctx);\r\n        ctx.e = getE(ctx);\r\n        console.log(\"ctx.a: \" , ctx.a);\r\n        console.log(\"ctx.b: \" , ctx.b);\r\n        console.log(\"ctx.c: \" , ctx.c);\r\n        console.log(\"ctx.d: \" , ctx.d);\r\n        console.log(\"ctx.e: \" , ctx.e);\r\n        ctx.g = getG(ctx);\r\n        ctx.h = getH(ctx);\r\n        ctx.i = getI(ctx);\r\n        console.log(\"ctx.g: \" , ctx.g);\r\n        console.log(\"ctx.h: \" , ctx.h);\r\n        console.log(\"ctx.i: \" , ctx.i);\r\n        console.log(\"ctx.dd: \" , ctx.dd);\r\n\r\n        uint256 underSqrt = ctx.a.add(ctx.c).add(ctx.d).add(ctx.e).sub(ctx.b);\r\n        uint256 sqrt = underSqrt.sqrt();\r\n        uint256 t1 = ctx.g.add(sqrt);\r\n        uint256 t2 = t1.mul(1e18).div(ctx.i);\r\n        uint256 res = ctx.h.sub(t2);\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    function _fairAmount(Context memory ctx) internal view returns (uint256){\r\n        uint256 spareQuote = ctx.dodo._QUOTE_BALANCE_().sub(ctx.dodo._TARGET_QUOTE_TOKEN_AMOUNT_());\r\n        uint256 price = ctx.dodo.getOraclePrice();\r\n        uint256 fairAmount = DecimalMath.divFloor(spareQuote, price);\r\n        return fairAmount;\r\n    }\r\n\r\n    function getDD(Context memory ctx) internal view returns (uint256){\r\n        return ctx.dodo._BASE_BALANCE_().mul(2).sub(ctx.amountOut);\r\n    }\r\n\r\n    function getA(Context memory ctx) internal view returns (uint256){\r\n        return ctx.fairAmount.mul(ctx.fairAmount).add(ctx.targetBase.mul(ctx.targetBase));\r\n    }\r\n\r\n    function getB(Context memory ctx) internal view returns (uint256){\r\n\r\n        uint256 t1 = ctx.fairAmount.mul(ctx.dodo._K_()).mul(2).div(1e18);\r\n        uint256 t2 = ctx.dd.add(ctx.fairAmount).add(t1);\r\n        uint256 t3 = t2.mul(ctx.targetBase).mul(2);\r\n\r\n        return t3;\r\n    }\r\n\r\n    function getC(Context memory ctx) internal view returns (uint256){\r\n        return ctx.dd.mul(ctx.fairAmount).mul(2);\r\n    }\r\n\r\n    function getD(Context memory ctx) internal view returns (uint256){\r\n        return ctx.c.mul(ctx.dodo._K_()).mul(2).div(1e18);\r\n    }\r\n\r\n    function getE(Context memory ctx) internal view returns (uint256){\r\n        return ctx.dd.mul(ctx.dd);\r\n    }\r\n\r\n    function getG(Context memory ctx) internal view returns (uint256){\r\n        return ctx.targetBase.add(ctx.fairAmount).sub(ctx.dd);\r\n    }\r\n\r\n    function getH(Context memory ctx) internal view returns (uint256){\r\n        return ctx.targetBase.add(ctx.dodo._BASE_BALANCE_()).sub(ctx.dd);\r\n    }\r\n\r\n    function getI(Context memory ctx) internal view returns (uint256){\r\n        return ctx.dodo._K_().mul(2).add(uint256(2).mul(1e18));\r\n    }\r\n\r\n\r\n    function _solveQuadraticFunctionForTargetCeil(\r\n        Context memory ctx\r\n    ) internal view returns (uint256) {\r\n        uint256 V1 = ctx.dodo._BASE_BALANCE_();\r\n        uint256 k = ctx.dodo._K_();\r\n\r\n        // V0 = V1+V1*(sqrt-1)/2k\r\n        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mulCeil(k, ctx.fairAmount).mul(4), V1);\r\n        sqrt = sqrt.add(DecimalMath.ONE).mul(DecimalMath.ONE).sqrt();\r\n        uint256 premium = DecimalMath.divCeil(sqrt.sub(DecimalMath.ONE), k.mul(2));\r\n        // V0 is greater than or equal to V1 according to the solution\r\n        return DecimalMath.mul(V1, DecimalMath.ONE.add(premium));\r\n    }\r\n}"
    },
    "contracts/connectors/dodo/IDODOV1.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDODOV1 {\n    function init(\n        address owner,\n        address supervisor,\n        address maintainer,\n        address baseToken,\n        address quoteToken,\n        address oracle,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 k,\n        uint256 gasPriceLimit\n    ) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function claimOwnership() external;\n\n    function sellBaseToken(\n        uint256 amount,\n        uint256 minReceiveQuote,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function buyBaseToken(\n        uint256 amount,\n        uint256 maxPayQuote,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote);\n\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote);\n\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\n\n    function depositBaseTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawBase(uint256 amount) external returns (uint256);\n\n    function withdrawAllBase() external returns (uint256);\n\n    function depositQuoteTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawQuote(uint256 amount) external returns (uint256);\n\n    function withdrawAllQuote() external returns (uint256);\n\n    function _BASE_CAPITAL_TOKEN_() external view returns (address);\n\n    function _QUOTE_CAPITAL_TOKEN_() external view returns (address);\n\n    function _BASE_TOKEN_() external returns (address);\n\n    function _QUOTE_TOKEN_() external returns (address);\n\n    function _K_() external view returns (uint256);\n\n    function _R_STATUS_() external view returns (RStatus);\n\n    function _TARGET_BASE_TOKEN_AMOUNT_() external view returns (uint256);\n\n    function _TARGET_QUOTE_TOKEN_AMOUNT_() external view returns (uint256);\n\n    function _BASE_BALANCE_() external view returns (uint256);\n\n    function _QUOTE_BALANCE_() external view returns (uint256);\n\n    function getOraclePrice() external view returns (uint256);\n\n    enum RStatus {ONE, ABOVE_ONE, BELOW_ONE}\n\n}\n"
    },
    "contracts/connectors/dodo/IDODOV2.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDODOV2 {\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) external view returns (uint256 receiveQuoteAmount, uint256 mtFee);\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) external view returns (uint256 receiveBaseAmount, uint256 mtFee);\n}\n"
    },
    "contracts/connectors/dodo/IDODOMine.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDODOMine {\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function claimAllRewards() external;\n\n}\n"
    },
    "contracts/exchanges/DodoExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../connectors/dodo/IDODOV1Helper.sol\";\r\nimport \"../connectors/dodo/IDODOProxy.sol\";\r\nimport \"../connectors/dodo/IDODOV2.sol\";\r\n\r\n/*\r\n    There are six swap functions in DODOProxy. Which are executed for different sources or versions\r\n\r\n    - dodoSwapV1: Used for DODOV1 pools\r\n    - dodoSwapV2ETHToToken: Used for DODOV2 pools and specify ETH as fromToken\r\n    - dodoSwapV2TokenToETH: Used for DODOV2 pools and specify ETH as toToken\r\n    - dodoSwapV2TokenToToken:  Used for DODOV2 pools and both fromToken and toToken are ERC20\r\n    - externalSwap: Used for executing third-party protocols' aggregation algorithm\r\n    - mixSwap: Used for executing DODOs custom aggregation algorithm\r\n\r\n    Note: Best Trading path is calculated by off-chain program. DODOProxy's swap functions is only used for executing.\r\n*/\r\nabstract contract DodoExchange {\r\n\r\n    IDODOV1Helper private dodoV1Helper;\r\n    IDODOProxy private dodoProxy;\r\n    address private dodoApprove;\r\n\r\n    function _setDodoParams(\r\n        address _dodoV1Helper,\r\n        address _dodoProxy,\r\n        address _dodoApprove\r\n    ) internal {\r\n        dodoV1Helper = IDODOV1Helper(_dodoV1Helper);\r\n        dodoProxy = IDODOProxy(_dodoProxy);\r\n        dodoApprove = _dodoApprove;\r\n    }\r\n\r\n    /*\r\n        The code example assumes user wanting to use the specify DODOV1 pool for swapping\r\n\r\n        Note: Differentiate sellBaseToken or sellQuoteToken. If sellBaseToken represents 0, sellQuoteToken represents 1.\r\n        At the same time, dodoSwapV1 supports multi-hop linear routing, so here we use 0,1\r\n        combination to represent the multi-hop directions to save gas consumption\r\n        For example:\r\n            A - B - C (A - B sellBase and  B - C sellQuote)  Binary: 10, Decimal 2 (directions = 2)\r\n            D - E - F (D - E sellQuote and E - F sellBase) Binary: 01, Decimal 1 (directions = 1)\r\n    */\r\n    function _useDodoSwapV1(\r\n        address dodoV1Pool,\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 slippage,\r\n        uint256 directions\r\n    ) internal returns (uint256) {\r\n\r\n        uint256 minReturnAmount;\r\n        if (directions == 0) {\r\n            uint256 receivedQuoteAmount = dodoV1Helper.querySellBaseToken(dodoV1Pool, fromTokenAmount);\r\n            minReturnAmount = receivedQuoteAmount * (100 - slippage) / 100;\r\n        } else {\r\n            uint256 receivedBaseAmount = dodoV1Helper.querySellQuoteToken(dodoV1Pool, fromTokenAmount);\r\n            minReturnAmount = receivedBaseAmount * (100 - slippage) / 100;\r\n        }\r\n        if (minReturnAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        address[] memory dodoPairs = new address[](1); //one-hop\r\n        dodoPairs[0] = dodoV1Pool;\r\n\r\n        IERC20(fromToken).approve(dodoApprove, fromTokenAmount);\r\n\r\n        return dodoProxy.dodoSwapV1(\r\n            fromToken,\r\n            toToken,\r\n            fromTokenAmount,\r\n            minReturnAmount,\r\n            dodoPairs,\r\n            directions,\r\n            false,\r\n            block.timestamp + 600\r\n        );\r\n    }\r\n\r\n    /*\r\n        The code example assumes user wanting to use the specify DODOV2 pool for swapping\r\n\r\n        Note: Differentiate sellBaseToken or sellQuoteToken. If sellBaseToken represents 0, sellQuoteToken represents 1.\r\n        At the same time, dodoSwapV1 supports multi-hop linear routing, so here we use 0,1\r\n        combination to represent the multi-hop directions to save gas consumption\r\n        For example:\r\n            A - B - C (A - B sellBase and  B - C sellQuote)  Binary: 10, Decimal 2 (directions = 2)\r\n            D - E - F (D - E sellQuote and E - F sellBase) Binary: 01, Decimal 1 (directions = 1)\r\n    */\r\n    function _useDodoSwapV2(\r\n        address dodoV2Pool,\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 slippage,\r\n        uint256 directions\r\n    ) internal returns (uint256) {\r\n\r\n        uint256 minReturnAmount;\r\n        if (directions == 0) {\r\n            (uint256 receiveQuoteAmount,) = IDODOV2(dodoV2Pool).querySellBase(address(this), fromTokenAmount);\r\n            minReturnAmount = receiveQuoteAmount * (100 - slippage) / 100;\r\n        } else {\r\n            (uint256 receiveBaseAmount,) = IDODOV2(dodoV2Pool).querySellQuote(address(this), fromTokenAmount);\r\n            minReturnAmount = receiveBaseAmount * (100 - slippage) / 100;\r\n        }\r\n        if (minReturnAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        address[] memory dodoPairs = new address[](1); //one-hop\r\n        dodoPairs[0] = dodoV2Pool;\r\n\r\n        IERC20(fromToken).approve(dodoApprove, fromTokenAmount);\r\n\r\n        return dodoProxy.dodoSwapV2TokenToToken(\r\n            fromToken,\r\n            toToken,\r\n            fromTokenAmount,\r\n            minReturnAmount,\r\n            dodoPairs,\r\n            directions,\r\n            false,\r\n            block.timestamp + 600\r\n        );\r\n    }\r\n\r\n}"
    },
    "contracts/utils/SafeMath.sol": {
      "content": "/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}"
    },
    "contracts/utils/DecimalMath.sol": {
      "content": "/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant ONE = 10**18;\r\n\r\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / ONE;\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(ONE);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(ONE).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(ONE).divCeil(d);\r\n    }\r\n}"
    },
    "contracts/connectors/dodo/IDODOV1Helper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDODOV1Helper {\n    function querySellQuoteToken(\n        address dodoV1Pool,\n        uint256 quoteAmount\n    ) external view returns (uint256 receivedBaseAmount);\n\n    function querySellBaseToken(\n        address dodoV1Pool,\n        uint256 baseAmount\n    ) external view returns (uint256 receivedQuoteAmount);\n}\n"
    },
    "contracts/connectors/dodo/IDODOProxy.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IDODOProxy {\n    function dodoSwapV1(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool,\n        uint256 deadLine\n    ) external payable returns (uint256 returnAmount);\n\n    function dodoSwapV2TokenToToken(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external returns (uint256 returnAmount);\n}"
    },
    "contracts/mocks/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\n\r\ncontract MockUniswapRouter is IUniswapV2Router {\r\n    using StableMath for uint256;\r\n\r\n    mapping(address => address) public pairMaps;\r\n\r\n    function initialize(\r\n        address[] calldata _0tokens,\r\n        address[] calldata _1tokens\r\n    ) public {\r\n        require(\r\n            _0tokens.length == _1tokens.length,\r\n            \"Mock token pairs should be of the same length\"\r\n        );\r\n        for (uint256 i = 0; i < _0tokens.length; i++) {\r\n            pairMaps[_0tokens[i]] = _1tokens[i];\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external override returns (uint256[] memory amounts) {\r\n        address tok0 = path[0];\r\n        address tok1 = pairMaps[tok0];\r\n        // Give 1:1\r\n        uint256 amountOut = amountIn.scaleBy(\r\n            Helpers.getDecimals(tok1),\r\n            Helpers.getDecimals(tok0)\r\n        );\r\n        require(amountOut >= amountOutMin, \"Slippage error\");\r\n\r\n        IERC20(tok0).transferFrom(msg.sender, address(this), amountIn);\r\n        IERC20(tok1).transfer(to, amountOut);\r\n    }\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut)\r\n    {\r\n        bytes memory tok0Bytes = new bytes(20);\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            tok0Bytes[i] = params.path[i];\r\n        }\r\n\r\n        address tok0 = address(bytes20(tok0Bytes));\r\n        address tok1 = pairMaps[tok0];\r\n\r\n        amountOut = params.amountIn.scaleBy(\r\n            Helpers.getDecimals(tok1),\r\n            Helpers.getDecimals(tok0)\r\n        );\r\n        IERC20(tok0).transferFrom(msg.sender, address(this), params.amountIn);\r\n        IERC20(tok1).transfer(params.recipient, amountOut);\r\n        require(\r\n            amountOut >= params.amountOutMinimum,\r\n            \"UniswapMock: amountOut less than amountOutMinimum\"\r\n        );\r\n        return amountOut;\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        override\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        // this is needed to make this contract whole else it'd be just virtual\r\n    }\r\n\r\n    function WETH() external pure override returns (address) {\r\n        return address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n}\r\n"
    },
    "contracts/mocks/curve/MockCurvePool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\r\nimport { ICurvePool } from \"../../strategies/ICurvePool.sol\";\r\nimport { StableMath } from \"../../utils/StableMath.sol\";\r\nimport \"../../utils/Helpers.sol\";\r\n\r\ncontract MockCurvePool {\r\n    using StableMath for uint256;\r\n\r\n    address[] public coins;\r\n    uint256[3] public balances;\r\n    address lpToken;\r\n\r\n    constructor(address[3] memory _coins, address _lpToken) {\r\n        coins = _coins;\r\n        lpToken = _lpToken;\r\n    }\r\n\r\n    // Returns the same amount of LP tokens in 1e18 decimals\r\n    function add_liquidity(uint256[3] calldata _amounts, uint256 _minAmount)\r\n        external\r\n    {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            if (_amounts[i] > 0) {\r\n                IERC20(coins[i]).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _amounts[i]\r\n                );\r\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\r\n                // Convert to 1e18 and add to sum\r\n                sum += _amounts[i].scaleBy(18, assetDecimals);\r\n                balances[i] = balances[i] + _amounts[i];\r\n            }\r\n        }\r\n        // Hacky way of simulating slippage to check _minAmount\r\n        if (sum == 29000e18) sum = 14500e18;\r\n        require(sum >= _minAmount, \"Slippage ruined your day\");\r\n        // Send LP token to sender, e.g. 3CRV\r\n        IMintableERC20(lpToken).mint(sum);\r\n        IERC20(lpToken).transfer(msg.sender, sum);\r\n    }\r\n\r\n    // Dumb implementation that returns the same amount\r\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\r\n        return _amount.scaleBy(assetDecimals, 18);\r\n    }\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 _amount,\r\n        int128 _index,\r\n        uint256 _minAmount\r\n    ) external {\r\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);\r\n        uint256[] memory amounts = new uint256[](coins.length);\r\n        amounts[uint128(_index)] = _amount;\r\n        uint256 amount = calc_withdraw_one_coin(_amount, _index);\r\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, amount);\r\n        balances[uint128(_index)] = balances[uint128(_index)] - amount;\r\n    }\r\n\r\n    function get_virtual_price() external pure returns (uint256) {\r\n        return 1 * 10**18;\r\n    }\r\n\r\n    function remove_liquidity(uint256 _amount, uint256[3] memory _min_amounts)\r\n        public\r\n    {\r\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);\r\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            uint256 amount = (_amount / totalSupply) *\r\n                IERC20(coins[i]).balanceOf(address(this));\r\n            IERC20(coins[i]).transfer(msg.sender, amount);\r\n            balances[i] = balances[i] - amount;\r\n        }\r\n    }\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[3] memory _amounts,\r\n        uint256 _max_burned_tokens\r\n    ) public {\r\n        IERC20(lpToken).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _max_burned_tokens\r\n        );\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            IERC20(coins[i]).transfer(msg.sender, _amounts[i]);\r\n            balances[i] = balances[i] - _amounts[i];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ninterface IMintableERC20 {\r\n    function mint(uint256 value) external;\r\n\r\n    function mintTo(address to, uint256 value) external;\r\n}\r\n\r\n/**\r\n * @title MintableERC20\r\n * @dev Exposes the mint function of ERC20 for tests\r\n */\r\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _value The amount of tokens to mint.\r\n     */\r\n    function mint(uint256 _value) public virtual override {\r\n        _mint(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to Address to mint to.\r\n     * @param _value The amount of tokens to mint.\r\n     */\r\n    function mintTo(address _to, uint256 _value) public virtual override {\r\n        _mint(_to, _value);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockWMATIC.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockWMATIC is MintableERC20 {\r\n    constructor() ERC20(\"WMATIC\", \"WMATIC\") {}\r\n}\r\n"
    },
    "contracts/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockWETH is MintableERC20 {\r\n    constructor() ERC20(\"WETH\", \"WETH\") {}\r\n}\r\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockUSDT is MintableERC20 {\r\n    constructor() ERC20(\"USDT Coin\", \"USDT\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 6;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockUSDC is MintableERC20 {\r\n    constructor() ERC20(\"USDC Coin\", \"USDC\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 6;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockTUSD.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockTUSD is MintableERC20 {\r\n    constructor() ERC20(\"TrueUSD\", \"TUSD\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockNonStandardToken.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\n/**\r\n * Mock token contract to simulate tokens that don't\r\n * throw/revert when a transfer/transferFrom call fails\r\n */\r\ncontract MockNonStandardToken is MintableERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    constructor() ERC20(\"NonStandardToken\", \"NonStandardToken\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 6;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (balanceOf(msg.sender) < amount) {\r\n            // Fail silently\r\n            return false;\r\n        }\r\n\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        if (balanceOf(sender) < amount) {\r\n            // Fail silently\r\n            return false;\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            allowance(sender, _msgSender()).sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/VaultValueChecker.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { VaultCore } from \"../vault/VaultCore.sol\";\r\n\r\ncontract VaultValueChecker {\r\n    uint256 public snapshotValue;\r\n    VaultCore public vault;\r\n\r\n    constructor(address _vault) {\r\n        vault = VaultCore(payable(_vault));\r\n    }\r\n\r\n    function takeSnapshot() external {\r\n        snapshotValue = vault.totalValue();\r\n    }\r\n\r\n    function checkLoss(int256 maxLoss) external {\r\n        uint256 currentValue = vault.totalValue();\r\n        int256 actualLoss = int256(snapshotValue) - int256(currentValue);\r\n        require(actualLoss < maxLoss, \"Max loss exceeded\");\r\n    }\r\n}\r\n"
    },
    "contracts/oracle/OracleRouter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\r\nimport { IOracle } from \"../interfaces/IOracle.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\nabstract contract OracleRouterBase is IOracle {\r\n    uint256 constant MIN_DRIFT = uint256(70000000);\r\n    uint256 constant MAX_DRIFT = uint256(130000000);\r\n\r\n    /**\r\n     * @dev The price feed contract to use for a particular asset.\r\n     * @param asset address of the asset\r\n     * @return address address of the price feed for the asset\r\n     */\r\n    function feed(address asset) internal view virtual returns (address);\r\n\r\n    /**\r\n     * @notice Returns the total price in 8 digit USD for a given asset.\r\n     * @param asset address of the asset\r\n     * @return uint256 USD price of 1 of the asset, in 8 decimal fixed\r\n     */\r\n    function price(address asset) external view override returns (uint256) {\r\n        console.log(\"OracleRouterBase: Getting the address of\", asset);\r\n        address _feed = feed(asset);\r\n        //require(_feed != address(0), \"Asset not available: Price\");\r\n        (, int256 _iprice, , , ) = AggregatorV3Interface(_feed)\r\n            .latestRoundData();\r\n        uint256 _price = uint256(_iprice);\r\n        if (isStablecoin(asset)) {\r\n            require(_price <= MAX_DRIFT, \"Oracle: Price exceeds max\");\r\n            require(_price >= MIN_DRIFT, \"Oracle: Price under min\");\r\n        }\r\n        return uint256(_price);\r\n    }\r\n\r\n    function isStablecoin(address _asset) internal view returns (bool) {\r\n        string memory symbol = Helpers.getSymbol(_asset);\r\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\r\n        return\r\n            symbolHash == keccak256(abi.encodePacked(\"DAI\")) ||\r\n            symbolHash == keccak256(abi.encodePacked(\"USDC\")) ||\r\n            symbolHash == keccak256(abi.encodePacked(\"USDT\"));\r\n    }\r\n}\r\n\r\ncontract OracleRouter is OracleRouterBase {\r\n    /**\r\n     * @dev The price feed contract to use for a particular asset.\r\n     * @param asset address of the asset\r\n     */\r\n    function feed(address asset) internal pure override returns (address) {\r\n        if (asset == address(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063)) {\r\n            // Chainlink: DAI/USD\r\n            return address(0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D);\r\n        } else if (\r\n            asset == address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174)\r\n        ) {\r\n            // Chainlink: USDC/USD\r\n            return address(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7);\r\n        } else if (\r\n            asset == address(0xc2132D05D31c914a87C6611C10748AEb04B58e8F)\r\n        ) {\r\n            // Chainlink: USDT/USD\r\n            return address(0x0A6513e40db6EB1b165753AD52E80663aeA50545);\r\n\r\n\r\n        // COMP not available in Polygon\r\n        } else if (\r\n            asset == address(0xc00e94Cb662C3520282E6f5717214004A7f26888)\r\n        ) {\r\n            // Chainlink: COMP/USD\r\n            return address(0x2A8758b7257102461BC958279054e372C2b1bDE6);\r\n        } else if (\r\n            asset == address(0xD6DF932A45C0f255f85145f286eA0b292B21C90B)\r\n        ) {\r\n            // Chainlink: AAVE/USD\r\n            return address(0x72484B12719E23115761D5DA1646945632979bB6);\r\n        } else if (\r\n            asset == address(0x172370d5Cd63279eFa6d502DAB29171933a610AF)\r\n        ) {\r\n            // Chainlink: CRV/USD\r\n            return address(0x336584C8E6Dc19637A5b36206B1c79923111b405);\r\n        } else if (\r\n            asset == address(0x4257EA7637c355F81616050CbB6a9b709fd72683)\r\n        ) {\r\n            // Chainlink: CVX/USD\r\n            return address(0x5ec151834040B4D453A1eA46aA634C1773b36084);\r\n        } else if (\r\n            asset == address(0x2e1AD108fF1D8C782fcBbB89AAd783aC49586756)\r\n        ) {\r\n            // Chainlink: TUSD/USD\r\n            return address(0x7C5D415B64312D38c56B54358449d0a4058339d2);\r\n        } else {\r\n            revert(\"Asset not available\");\r\n        }\r\n    }\r\n    \r\n}\r\n\r\ncontract OracleRouterDev is OracleRouterBase {\r\n    mapping(address => address) public assetToFeed;\r\n\r\n    function setFeed(address _asset, address _feed) external {\r\n        assetToFeed[_asset] = _feed;\r\n    }\r\n\r\n    /**\r\n     * @dev The price feed contract to use for a particular asset.\r\n     * @param asset address of the asset\r\n     */\r\n    function feed(address asset) internal view override returns (address) {\r\n        return assetToFeed[asset];\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n"
    },
    "contracts/mocks/MockChainlinkOracleFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\r\n\r\ncontract MockChainlinkOracleFeed is AggregatorV3Interface {\r\n    int256 price;\r\n    uint8 numDecimals;\r\n\r\n    constructor(int256 _price, uint8 _decimals) {\r\n        price = _price;\r\n        numDecimals = _decimals;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return numDecimals;\r\n    }\r\n\r\n    function description() external pure override returns (string memory) {\r\n        return \"MockOracleEthFeed\";\r\n    }\r\n\r\n    function version() external pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    function setPrice(int256 _price) public {\r\n        price = _price;\r\n    }\r\n\r\n    function setDecimals(uint8 _decimals) public {\r\n        numDecimals = _decimals;\r\n    }\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        roundId = _roundId;\r\n        answer = price;\r\n        startedAt = 0;\r\n        updatedAt = 0;\r\n        answeredInRound = 0;\r\n    }\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        roundId = 0;\r\n        answer = price;\r\n        startedAt = 0;\r\n        updatedAt = 0;\r\n        answeredInRound = 0;\r\n    }\r\n}\r\n"
    },
    "contracts/harvest/Harvester.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\nimport { IVault } from \"../interfaces/IVault.sol\";\r\nimport { IOracle } from \"../interfaces/IOracle.sol\";\r\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\r\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\r\nimport \"../utils/Helpers.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Harvester is Governable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n\r\n    event UniswapUpdated(address _address);\r\n    event SupportedStrategyUpdate(address _address, bool _isSupported);\r\n   \r\n    mapping(address => bool) public supportedStrategies;\r\n\r\n    address public immutable vaultAddress;\r\n    address public immutable primaryStableAddress;\r\n\r\n    /**\r\n     * Address receiving rewards proceeds. Initially the Vault contract later will possibly\r\n     * be replaced by another contract that eases out rewards distribution.\r\n     */\r\n    address public rewardProceedsAddress;\r\n    address public labsAddress;\r\n    uint256 public labsFeeBps;\r\n\r\n    address public teamAddress;\r\n    uint256 public teamFeeBps;\r\n\r\n\r\n    /**\r\n     * @dev Constructor to set up initial internal state\r\n     * @param _vaultAddress Address of the Vault\r\n     * @param _primaryStableAddress Address of primaryStable\r\n     */\r\n    constructor(address _vaultAddress, address _primaryStableAddress) {\r\n        require(address(_vaultAddress) != address(0));\r\n        require(address(_primaryStableAddress) != address(0));\r\n        vaultAddress = _vaultAddress;\r\n        primaryStableAddress = _primaryStableAddress;\r\n    }\r\n\r\n    /***************************************\r\n                 Configuration\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Throws if called by any address other than the Vault.\r\n     */\r\n    modifier onlyVaultOrGovernor() {\r\n        require(\r\n            msg.sender == vaultAddress || isGovernor(),\r\n            \"Caller is not the Vault or Governor\"\r\n        );\r\n        _;\r\n    }\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the Address receiving rewards proceeds.\r\n     * @param _rewardProceedsAddress Address of the reward token\r\n     */\r\n    function setRewardsProceedsAddress(address _rewardProceedsAddress)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        require(\r\n            _rewardProceedsAddress != address(0),\r\n            \"Rewards proceeds address should be a non zero address\"\r\n        );\r\n\r\n        rewardProceedsAddress = _rewardProceedsAddress;\r\n    }\r\n\r\n\r\n    function setLabs(address _labs, uint256 _feeBps) external onlyVaultOrGovernor {\r\n        require(\r\n            _labs != address(0),\r\n            \"Labs address should be a non zero address\"\r\n        );\r\n        require(\r\n            _feeBps > 0,\r\n            \"Labs fee should be greater than zero\"\r\n        );\r\n        labsAddress = _labs;\r\n        labsFeeBps = _feeBps;\r\n    }\r\n    function setTeam(address _team, uint256 _feeBps) external onlyVaultOrGovernor {\r\n        require(\r\n            _team != address(0),\r\n            \"Team address should be a non zero address\"\r\n        );\r\n        require(\r\n            _feeBps > 0,\r\n            \"Team fee should be greater than zero\"\r\n        );\r\n        teamAddress = _team;\r\n        teamFeeBps = _feeBps;\r\n    }\r\n    function getLabs() public view returns (address, uint256) {\r\n        return (labsAddress, labsFeeBps);\r\n    }\r\n    function getTeam() public view returns (address, uint256) {\r\n        return (teamAddress, teamFeeBps);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Flags a strategy as supported or not supported one\r\n     * @param _strategyAddress Address of the strategy\r\n     * @param _isSupported Bool marking strategy as supported or not supported\r\n     */\r\n    function setSupportedStrategy(address _strategyAddress, bool _isSupported)\r\n        external\r\n        onlyVaultOrGovernor\r\n    {\r\n        supportedStrategies[_strategyAddress] = _isSupported;\r\n        emit SupportedStrategyUpdate(_strategyAddress, _isSupported);\r\n    }\r\n\r\n    /***************************************\r\n                    Rewards\r\n    ****************************************/\r\n    /*\r\n     * @dev Collect reward tokens from all strategies and distrubte primaryStable\r\n     *      to labs, teams and dripper accounts/contracts.\r\n     */\r\n    function harvestAndDistribute() external onlyGovernor nonReentrant {\r\n        _harvest();\r\n        _distribute();\r\n    }\r\n    function harvestAndDistribute(address _strategy) external onlyGovernor nonReentrant {\r\n        _harvest(_strategy);\r\n        _distribute();\r\n    }\r\n    function _distribute() internal {\r\n        if ( IERC20(primaryStableAddress).balanceOf(address(this)) > 10)  {\r\n            _distributeFees(IERC20(primaryStableAddress).balanceOf(address(this)));\r\n            _distributeProceeds(IERC20(primaryStableAddress).balanceOf(address(this)));\r\n        } \r\n    }\r\n    function _distributeFees(uint256 _amount) internal {\r\n        require(\r\n            _amount > 0,\r\n            \"Amount should be greater than zero\"\r\n        );\r\n        console.log(\"Distributing fees: \", _amount);\r\n        uint256 labsfees = ((_amount * labsFeeBps) / 100.0) / 100.0;\r\n        console.log(\"Labs fees: \" , labsfees);\r\n        uint256 teamfees = ((_amount * teamFeeBps) / 100.0) / 100.0;\r\n        console.log(\"Team fees: \" , teamfees);\r\n        IERC20(primaryStableAddress).transfer(\r\n            labsAddress,\r\n            labsfees\r\n        );\r\n        IERC20(primaryStableAddress).transfer(\r\n            teamAddress,\r\n            teamfees\r\n        );\r\n    }\r\n    function distributeFees() external onlyGovernor {\r\n        _distributeFees(IERC20(primaryStableAddress).balanceOf(address(this)));\r\n    }\r\n    function _distributeProceeds(uint256 _amount) internal {\r\n        require(\r\n            _amount > 0,\r\n            \"Amount should be greater than zero\"\r\n        );\r\n        console.log(\"Distributing proceeds: \", _amount);\r\n        IERC20(primaryStableAddress).transfer(\r\n            rewardProceedsAddress,\r\n            _amount\r\n        );\r\n    }\r\n    function distributeProceeds() external onlyGovernor {\r\n        _distributeProceeds(IERC20(primaryStableAddress).balanceOf(address(this)));\r\n    }\r\n    /**\r\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\r\n     *      contract, i.e. mistaken sends.\r\n     * @param _asset Address for the asset\r\n     * @param _amount Amount of the asset to transfer\r\n     */\r\n    function transferToken(address _asset, uint256 _amount)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        IERC20(_asset).safeTransfer(governor(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Collect reward tokens from all strategies\r\n     */\r\n    function harvest() external onlyGovernor nonReentrant {\r\n        _harvest();\r\n    }\r\n    /**\r\n     * @dev Collect reward tokens for a specific strategy.\r\n     * @param _strategyAddr Address of the strategy to collect rewards from\r\n     */\r\n    function harvest(address _strategyAddr) external onlyGovernor nonReentrant {\r\n        _harvest(_strategyAddr);\r\n    }\r\n    /**\r\n     * @dev Collect reward tokens from all strategies\r\n     */\r\n    function _harvest() internal {\r\n        address[] memory allStrategies = IVault(vaultAddress)\r\n            .getAllStrategies();\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            _harvest(allStrategies[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Collect reward tokens from a single strategy and swap them for a\r\n     *      supported stablecoin via Uniswap\r\n     * @param _strategyAddr Address of the strategy to collect rewards from.\r\n     */\r\n    function _harvest(address _strategyAddr) internal {\r\n        require(\r\n            supportedStrategies[_strategyAddr],\r\n            \"Not a valid strategy address\"\r\n        );\r\n\r\n        IStrategy strategy = IStrategy(_strategyAddr);\r\n        strategy.collectRewardTokens();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IVault {\r\n    struct StrategyWeight {\r\n        address strategy;\r\n        uint256 minWeight;\r\n        uint256 targetWeight;\r\n        uint256 maxWeight;\r\n        bool enabled;\r\n        bool enabledReward;\r\n    }\r\n\r\n    event AssetSupported(address _asset);\r\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\r\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\r\n    event StrategyApproved(address _addr);\r\n    event StrategyRemoved(address _addr);\r\n    event Mint(address _addr, uint256 _value);\r\n    event Redeem(address _addr, uint256 _value);\r\n    event CapitalPaused();\r\n    event CapitalUnpaused();\r\n    event RebasePaused();\r\n    event RebaseUnpaused();\r\n    event VaultBufferUpdated(uint256 _vaultBuffer);\r\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\r\n    event PriceProviderUpdated(address _priceProvider);\r\n    event AllocateThresholdUpdated(uint256 _threshold);\r\n    event RebaseThresholdUpdated(uint256 _threshold);\r\n    event StrategistUpdated(address _address);\r\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\r\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\r\n    event TrusteeFeeBpsChanged(uint256 _basis);\r\n    event TrusteeAddressChanged(address _address);\r\n\r\n    // Governable.sol\r\n    function transferGovernance(address _newGovernor) external;\r\n\r\n    function claimGovernance() external;\r\n\r\n    function governor() external view returns (address);\r\n\r\n    // VaultAdmin.sol\r\n    function setPriceProvider(address _priceProvider) external;\r\n\r\n    function priceProvider() external view returns (address);\r\n\r\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\r\n\r\n    function redeemFeeBps() external view returns (uint256);\r\n\r\n    function setVaultBuffer(uint256 _vaultBuffer) external;\r\n\r\n    function vaultBuffer() external view returns (uint256);\r\n\r\n    function setAutoAllocateThreshold(uint256 _threshold) external;\r\n\r\n    function autoAllocateThreshold() external view returns (uint256);\r\n\r\n    function setRebaseThreshold(uint256 _threshold) external;\r\n\r\n    function rebaseThreshold() external view returns (uint256);\r\n\r\n    function setStrategistAddr(address _address) external;\r\n\r\n    function strategistAddr() external view returns (address);\r\n\r\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\r\n\r\n    function maxSupplyDiff() external view returns (uint256);\r\n\r\n    function setTrusteeAddress(address _address) external;\r\n\r\n\r\n    function trusteeAddress() external view returns (address);\r\n\r\n    function setTrusteeFeeBps(uint256 _basis) external;\r\n\r\n    function trusteeFeeBps() external view returns (uint256);\r\n\r\n    function supportAsset(address _asset) external;\r\n\r\n    function approveStrategy(address _addr) external;\r\n\r\n    function removeStrategy(address _addr) external;\r\n\r\n    function setAssetDefaultStrategy(address _asset, address _strategy)\r\n        external;\r\n\r\n    function assetDefaultStrategies(address _asset)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function pauseRebase() external;\r\n\r\n    function unpauseRebase() external;\r\n\r\n    function rebasePaused() external view returns (bool);\r\n\r\n    function pauseCapital() external;\r\n\r\n    function unpauseCapital() external;\r\n\r\n    function capitalPaused() external view returns (bool);\r\n\r\n    function transferToken(address _asset, uint256 _amount) external;\r\n\r\n    function priceUSDMint(address asset) external view returns (uint256);\r\n\r\n    function priceUSDRedeem(address asset) external view returns (uint256);\r\n\r\n    function withdrawAllFromStrategy(address _strategyAddr) external;\r\n\r\n    function withdrawAllFromStrategies() external;\r\n\r\n    function reallocate(\r\n        address _strategyFromAddress,\r\n        address _strategyToAddress,\r\n        address[] calldata _assets,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    // VaultCore.sol\r\n    function mint(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _minimumCASHAmount\r\n    ) external;\r\n    function justMint(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _minimumCASHAmount\r\n    ) external;\r\n\r\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\r\n\r\n    function redeemAll(uint256 _minimumUnitAmount) external;\r\n\r\n    function allocate() external;\r\n    \r\n    function quickAllocate() external;\r\n\r\n    function rebase() external;\r\n\r\n    function totalValue() external view returns (uint256 value);\r\n\r\n    function checkBalance() external view returns (uint256);\r\n\r\n    function calculateRedeemOutput(uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getAssetCount() external view returns (uint256);\r\n\r\n    function getAllAssets() external view returns (address[] memory);\r\n\r\n    function getStrategyCount() external view returns (uint256);\r\n\r\n    function getAllStrategies() external view returns (address[] memory);\r\n\r\n    function isSupportedAsset(address _asset) external view returns (bool);\r\n\r\n    function balance() external;\r\n\r\n    function payout() external;\r\n\r\n    function setStrategyWithWeights(StrategyWeight[] calldata _strategyWeights) external;\r\n\r\n    function setSwapper(address _balancerVault, address _balancerPoolId) external;\r\n\r\n    function setQuickDepositStartegies(address[] calldata _quickDepositStartegies) external;\r\n    \r\n    function setPrimaryStable(address _primaryStable) external;\r\n    function primaryStableAddress() external view returns (address);\r\n\r\n\r\n    function getFeeParams() external view returns  (address, uint256, address, uint256);\r\n    function setFeeParams(address _labsAddress, uint256 _labsFeeBps, address _teamAddress, uint256 _teamFeeBps) external;\r\n    \r\n}\r\n"
    },
    "contracts/mocks/MockMeshSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\r\nimport { Helpers } from \"../utils/Helpers.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\n\r\n\r\ncontract MockMeshSwapRouter is IUniswapV2Router {\r\n    using StableMath for uint256;\r\n\r\n    mapping(address => address) public pairMaps;\r\n\r\n    function initialize(\r\n        address[] calldata _0tokens,\r\n        address[] calldata _1tokens\r\n    ) public {\r\n        require(\r\n            _0tokens.length == _1tokens.length,\r\n            \"Mock token pairs should be of the same length\"\r\n        );\r\n        for (uint256 i = 0; i < _0tokens.length; i++) {\r\n            pairMaps[_0tokens[i]] = _1tokens[i];\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external override returns (uint256[] memory amounts) {\r\n        address tok0 = path[0];\r\n        address tok1 = pairMaps[tok0];\r\n        // Give 1:1\r\n        uint256 amountOut = amountIn.scaleBy(\r\n            Helpers.getDecimals(tok1),\r\n            Helpers.getDecimals(tok0)\r\n        );\r\n        require(amountOut >= amountOutMin, \"Slippage error\");\r\n\r\n        IERC20(tok0).transferFrom(msg.sender, address(this), amountIn);\r\n        IERC20(tok1).transfer(to, amountOut);\r\n    }\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut)\r\n    {\r\n        bytes memory tok0Bytes = new bytes(20);\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            tok0Bytes[i] = params.path[i];\r\n        }\r\n\r\n        address tok0 = address(bytes20(tok0Bytes));\r\n        address tok1 = pairMaps[tok0];\r\n\r\n        amountOut = params.amountIn.scaleBy(\r\n            Helpers.getDecimals(tok1),\r\n            Helpers.getDecimals(tok0)\r\n        );\r\n        IERC20(tok0).transferFrom(msg.sender, address(this), params.amountIn);\r\n        IERC20(tok1).transfer(params.recipient, amountOut);\r\n        require(\r\n            amountOut >= params.amountOutMinimum,\r\n            \"UniswapMock: amountOut less than amountOutMinimum\"\r\n        );\r\n        return amountOut;\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        override\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        // this is needed to make this contract whole else it'd be just virtual\r\n    }\r\n\r\n    function WETH() external pure override returns (address) {\r\n        return address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockRebornMinter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IVault } from \"../interfaces/IVault.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Sanctum {\r\n    address public asset;\r\n    address public vault;\r\n    address public reborner;\r\n    bool public shouldAttack = false;\r\n    uint256 public targetMethod;\r\n    address public cashContract;\r\n\r\n    constructor(address _asset, address _vault) {\r\n        asset = _asset;\r\n        vault = _vault;\r\n    }\r\n\r\n    function deploy(uint256 salt, bytes memory bytecode)\r\n        public\r\n        returns (address addr)\r\n    {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n    }\r\n\r\n    function computeAddress(uint256 salt, bytes memory bytecode)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 bytecodeHashHash = keccak256(bytecode);\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff),\r\n                address(this),\r\n                salt,\r\n                bytecodeHashHash\r\n            )\r\n        );\r\n        return address(bytes20(_data << 96));\r\n    }\r\n\r\n    function setShouldAttack(bool _shouldAttack) public {\r\n        shouldAttack = _shouldAttack;\r\n    }\r\n\r\n    function setTargetMethod(uint256 target) public {\r\n        targetMethod = target;\r\n    }\r\n\r\n    function setCASHAddress(address _cashContract) public {\r\n        cashContract = _cashContract;\r\n    }\r\n}\r\n\r\ncontract Reborner {\r\n    Sanctum sanctum;\r\n    bool logging = false;\r\n\r\n    constructor(address _sanctum) {\r\n        log(\"We are created...\");\r\n        sanctum = Sanctum(_sanctum);\r\n        if (sanctum.shouldAttack()) {\r\n            log(\"We are attacking now...\");\r\n\r\n            uint256 target = sanctum.targetMethod();\r\n\r\n            if (target == 1) {\r\n                redeem();\r\n            } else if (target == 2) {\r\n                transfer();\r\n            } else {\r\n                mint();\r\n            }\r\n        }\r\n    }\r\n\r\n    function mint() public {\r\n        log(\"We are attempting to mint..\");\r\n        address asset = sanctum.asset();\r\n        address vault = sanctum.vault();\r\n        IERC20(asset).approve(vault, 1e18);\r\n        IVault(vault).mint(asset, 1e18, 0);\r\n        log(\"We are now minting..\");\r\n    }\r\n\r\n    function redeem() public {\r\n        log(\"We are attempting to redeem..\");\r\n        address vault = sanctum.vault();\r\n        IVault(vault).redeem(1e18, 1e18);\r\n        log(\"We are now redeeming..\");\r\n    }\r\n\r\n    function transfer() public {\r\n        log(\"We are attempting to transfer..\");\r\n        address cash = sanctum.cashContract();\r\n        require(IERC20(cash).transfer(address(1), 1e18), \"transfer failed\");\r\n        log(\"We are now transfering..\");\r\n    }\r\n\r\n    function bye() public {\r\n        log(\"We are now destructing..\");\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    function log(string memory message) internal view {\r\n        if (logging) {\r\n            console.log(message);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockNonRebasing.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport { IVault } from \"../interfaces/IVault.sol\";\r\n\r\nimport { CASH } from \"../token/CASH.sol\";\r\n\r\ncontract MockNonRebasing {\r\n    CASH cash;\r\n\r\n    function setCASH(address _cashAddress) public {\r\n        cash = CASH(_cashAddress);\r\n    }\r\n\r\n    function rebaseOptIn() public {\r\n        cash.rebaseOptIn();\r\n    }\r\n\r\n    function rebaseOptOut() public {\r\n        cash.rebaseOptOut();\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        cash.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public {\r\n        cash.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function increaseAllowance(address _spender, uint256 _addedValue) public {\r\n        cash.increaseAllowance(_spender, _addedValue);\r\n    }\r\n\r\n    function mintCASH(\r\n        address _vaultContract,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) public {\r\n        IVault(_vaultContract).justMint(_asset, _amount, 0);\r\n    }\r\n\r\n    function redeemCASH(address _vaultContract, uint256 _amount) public {\r\n        IVault(_vaultContract).redeem(_amount, 0);\r\n    }\r\n\r\n    function approveFor(\r\n        address _contract,\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) public {\r\n        IERC20(_contract).approve(_spender, _addedValue);\r\n    }\r\n}\r\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport { Governable } from \"../governance/Governable.sol\";\r\n\r\n/**\r\n * @title BaseGovernedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with our governor system.\r\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\r\n * with Solidity ^0.8.0.\r\n * @author Stabl Protocol Inc\r\n */\r\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     * @param implementation Address of the new implementation.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Contract initializer with Governor enforcement\r\n     * @param _logic Address of the initial implementation.\r\n     * @param _initGovernor Address of the initial Governor.\r\n     * @param _data Data to send as msg.data to the implementation to initialize\r\n     * the proxied contract.\r\n     * It should include the signature and the parameters of the function to be\r\n     * called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     * This parameter is optional, if no data is given the initialization call\r\n     * to proxied contract will be skipped.\r\n     */\r\n    function initialize(\r\n        address _logic,\r\n        address _initGovernor,\r\n        bytes memory _data\r\n    ) public payable onlyGovernor {\r\n        require(_implementation() == address(0), \"implementation already set\");\r\n        assert(\r\n            IMPLEMENTATION_SLOT ==\r\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\r\n        );\r\n        _changeGovernor(_initGovernor);\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return The address of the proxy admin/it's also the governor.\r\n     */\r\n    function admin() external view returns (address) {\r\n        return _governor();\r\n    }\r\n\r\n    /**\r\n     * @return The address of the implementation.\r\n     */\r\n    function implementation() external view returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the backing implementation of the proxy.\r\n     * Only the admin can call this function.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function upgradeTo(address newImplementation) external onlyGovernor {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the backing implementation of the proxy and call a function\r\n     * on the new implementation.\r\n     * This is useful to initialize the proxied contract.\r\n     * @param newImplementation Address of the new implementation.\r\n     * @param data Data to send as msg.data in the low level call.\r\n     * It should include the signature and the parameters of the function to be called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        onlyGovernor\r\n    {\r\n        _upgradeTo(newImplementation);\r\n        (bool success, ) = newImplementation.delegatecall(data);\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function.\r\n     * Implemented entirely in `_fallback`.\r\n     */\r\n    fallback() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * This is a low level function that doesn't return to its internal call site.\r\n     * It will return to the external caller whatever the implementation returns.\r\n     * @param _impl Address to delegate.\r\n     */\r\n    function _delegate(address _impl) internal {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function that is run as the first thing in the fallback function.\r\n     * Can be redefined in derived contracts to add functionality.\r\n     * Redefinitions must call super._willFallback().\r\n     */\r\n    function _willFallback() internal {}\r\n\r\n    /**\r\n     * @dev fallback implementation.\r\n     * Extracted to enable manual triggering.\r\n     */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT =\r\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     * @return impl Address of the current implementation\r\n     */\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the proxy to a new implementation.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the implementation address of the proxy.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(\r\n            Address.isContract(newImplementation),\r\n            \"Cannot set a proxy implementation to a non-contract address\"\r\n        );\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\r\n\r\n\r\n/**\r\n * @notice CASHProxy delegates calls to an CASH implementation\r\n */\r\ncontract BoxProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice CASHProxy delegates calls to an CASH implementation\r\n */\r\ncontract CASHProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice WrappedCASHProxy delegates calls to a WrappedCASH implementation\r\n */\r\ncontract WrappedCASHProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice VaultProxy delegates calls to a Vault implementation\r\n */\r\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice CompoundStrategyProxy delegates calls to a CompoundStrategy implementation\r\n */\r\ncontract CompoundStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice AaveStrategyUSDCProxy delegates calls to a AaveStrategy implementation\r\n */\r\ncontract AaveStrategyUSDCProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice AaveStrategyDAIProxy delegates calls to a AaveStrategy implementation\r\n */\r\ncontract AaveStrategyDAIProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice AaveStrategyUSDTProxy delegates calls to a AaveStrategy implementation\r\n */\r\ncontract AaveStrategyUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice ThreePoolStrategyProxy delegates calls to a ThreePoolStrategy implementation\r\n */\r\ncontract ThreePoolStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice ConvexStrategyProxy delegates calls to a ConvexStrategy implementation\r\n */\r\ncontract ConvexStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @notice DystopiaStrategyUsdcDaiProxy delegates calls to a DystopiaStrategy implementation\r\n */\r\ncontract DystopiaStrategyUsdcDaiProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice DystopiaStrategyUsdcUsdtProxy delegates calls to a DystopiaStrategy implementation\r\n */\r\ncontract DystopiaStrategyUsdcUsdtProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice DystopiaStrategyDaiUsdtProxy delegates calls to a DystopiaStrategy implementation\r\n */\r\ncontract DystopiaStrategyDaiUsdtProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice MeshSwapStrategyDAIProxy delegates calls to a MeshSwapStrategy implementation\r\n */\r\ncontract MeshSwapStrategyDAIProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice MeshSwapStrategyUSDTProxy delegates calls to a MeshSwapStrategy implementation\r\n */\r\ncontract MeshSwapStrategyUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice MeshSwapStrategyUSDCProxy delegates calls to a MeshSwapStrategy implementation\r\n */\r\ncontract MeshSwapStrategyUSDCProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice MeshSwapStrategyUSDCUSDTProxy delegates calls to a MeshSwapStrategyDual implementation\r\n */\r\ncontract MeshSwapStrategyUSDCUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice MeshSwapStrategyUSDCDAIProxy delegates calls to a MeshSwapStrategyDual implementation\r\n */\r\ncontract MeshSwapStrategyUSDCDAIProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice MeshSwapStrategyUSDTDAIProxy delegates calls to a MeshSwapStrategyDual implementation\r\n */\r\ncontract MeshSwapStrategyUSDTDAIProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice QuickSwapStrategyUSDCDAIProxy delegates calls to a QuickSwapStrategy implementation\r\n */\r\ncontract QuickSwapStrategyUSDCDAIProxy is InitializeGovernedUpgradeabilityProxy {\r\n}\r\n\r\n/**\r\n * @notice QuickSwapStrategyUSDCUSDTProxy delegates calls to a QuickSwapStrategy implementation\r\n */\r\ncontract QuickSwapStrategyUSDCUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Am3CurveStrategyProxy delegates calls to a Am3CurveStrategy implementation\r\n */\r\ncontract Am3CurveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice Am3CurveStrategyUSDTProxy delegates calls to a Am3CurveStrategy implementation\r\n */\r\ncontract Am3CurveStrategyUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice SynapseStrategyProxy delegates calls to a SynapseStrategy implementation\r\n */\r\ncontract SynapseStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice SynapseStrategyUSDTProxy delegates calls to a SynapseStrategy implementation\r\n */\r\ncontract SynapseStrategyUSDTProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice DodoStrategyProxy delegates calls to a DodoStrategy implementation\r\n */\r\ncontract DodoStrategyProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice HarvesterProxy delegates calls to a Harvester implementation\r\n */\r\ncontract HarvesterProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n\r\n/**\r\n * @notice DripperProxy delegates calls to a Dripper implementation\r\n */\r\ncontract DripperProxy is InitializeGovernedUpgradeabilityProxy {\r\n\r\n}\r\n"
    },
    "contracts/oracle/MixOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\n// DEPRECATED - This contract is no longer used in production\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH MixOracle Contract\r\n * @notice The MixOracle pulls exchange rate from multiple oracles and returns\r\n *         min and max values.\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { IPriceOracle } from \"../interfaces/IPriceOracle.sol\";\r\nimport { IEthUsdOracle } from \"../interfaces/IEthUsdOracle.sol\";\r\nimport { IMinMaxOracle } from \"../interfaces/IMinMaxOracle.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\n\r\ncontract MixOracle is IMinMaxOracle, Governable {\r\n    event DriftsUpdated(uint256 _minDrift, uint256 _maxDrift);\r\n    event EthUsdOracleRegistered(address _oracle);\r\n    event EthUsdOracleDeregistered(address _oracle);\r\n    event TokenOracleRegistered(\r\n        string symbol,\r\n        address[] ethOracles,\r\n        address[] usdOracles\r\n    );\r\n\r\n    address[] public ethUsdOracles;\r\n\r\n    struct MixConfig {\r\n        address[] usdOracles;\r\n        address[] ethOracles;\r\n    }\r\n\r\n    mapping(bytes32 => MixConfig) configs;\r\n\r\n    uint256 constant MAX_INT = 2**256 - 1;\r\n    uint256 public maxDrift;\r\n    uint256 public minDrift;\r\n\r\n    constructor(uint256 _maxDrift, uint256 _minDrift) {\r\n        maxDrift = _maxDrift;\r\n        minDrift = _minDrift;\r\n        emit DriftsUpdated(_minDrift, _maxDrift);\r\n    }\r\n\r\n    function setMinMaxDrift(uint256 _minDrift, uint256 _maxDrift)\r\n        public\r\n        onlyGovernor\r\n    {\r\n        minDrift = _minDrift;\r\n        maxDrift = _maxDrift;\r\n        emit DriftsUpdated(_minDrift, _maxDrift);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an oracle to the list of oracles to pull data from.\r\n     * @param oracle Address of an oracle that implements the IEthUsdOracle interface.\r\n     **/\r\n    function registerEthUsdOracle(address oracle) public onlyGovernor {\r\n        for (uint256 i = 0; i < ethUsdOracles.length; i++) {\r\n            require(ethUsdOracles[i] != oracle, \"Oracle already registered.\");\r\n        }\r\n        ethUsdOracles.push(oracle);\r\n        emit EthUsdOracleRegistered(oracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes an oracle to the list of oracles to pull data from.\r\n     * @param oracle Address of an oracle that implements the IEthUsdOracle interface.\r\n     **/\r\n    function unregisterEthUsdOracle(address oracle) public onlyGovernor {\r\n        for (uint256 i = 0; i < ethUsdOracles.length; i++) {\r\n            if (ethUsdOracles[i] == oracle) {\r\n                // swap with the last element of the array, and then delete last element (could be itself)\r\n                ethUsdOracles[i] = ethUsdOracles[ethUsdOracles.length - 1];\r\n                delete ethUsdOracles[ethUsdOracles.length - 1];\r\n                emit EthUsdOracleDeregistered(oracle);\r\n                ethUsdOracles.pop();\r\n                return;\r\n            }\r\n        }\r\n        revert(\"Oracle not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an oracle to the list of oracles to pull data from.\r\n     * @param ethOracles Addresses of oracles that implements the IEthUsdOracle interface and answers for this asset\r\n     * @param usdOracles Addresses of oracles that implements the IPriceOracle interface and answers for this asset\r\n     **/\r\n    function registerTokenOracles(\r\n        string calldata symbol,\r\n        address[] calldata ethOracles,\r\n        address[] calldata usdOracles\r\n    ) external onlyGovernor {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        config.ethOracles = ethOracles;\r\n        config.usdOracles = usdOracles;\r\n        emit TokenOracleRegistered(symbol, ethOracles, usdOracles);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the min price of an asset in USD.\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @return price Min price from all the oracles, in USD with 8 decimal digits.\r\n     **/\r\n    function priceMin(string calldata symbol)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 price)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        uint256 ep;\r\n        uint256 p; //holder variables\r\n        price = MAX_INT;\r\n        if (config.ethOracles.length > 0) {\r\n            ep = MAX_INT;\r\n            for (uint256 i = 0; i < config.ethOracles.length; i++) {\r\n                p = IEthUsdOracle(config.ethOracles[i]).tokEthPrice(symbol);\r\n                if (ep > p) {\r\n                    ep = p;\r\n                }\r\n            }\r\n            price = ep;\r\n            ep = MAX_INT;\r\n            for (uint256 i = 0; i < ethUsdOracles.length; i++) {\r\n                p = IEthUsdOracle(ethUsdOracles[i]).ethUsdPrice();\r\n                if (ep > p) {\r\n                    ep = p;\r\n                }\r\n            }\r\n            if (price != MAX_INT && ep != MAX_INT) {\r\n                // tokEthPrice has precision of 8 which ethUsdPrice has precision of 6\r\n                // we want precision of 8\r\n                price = (price * ep) / 1e6;\r\n            }\r\n        }\r\n\r\n        if (config.usdOracles.length > 0) {\r\n            for (uint256 i = 0; i < config.usdOracles.length; i++) {\r\n                // upscale by 2 since price oracles are precision 6\r\n                p = IPriceOracle(config.usdOracles[i]).price(symbol) * 1e2;\r\n                if (price > p) {\r\n                    price = p;\r\n                }\r\n            }\r\n        }\r\n        require(price <= maxDrift, \"Price exceeds maxDrift\");\r\n        require(price >= minDrift, \"Price below minDrift\");\r\n        require(\r\n            price != MAX_INT,\r\n            \"None of our oracles returned a valid min price!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns max price of an asset in USD.\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @return price Max price from all the oracles, in USD with 8 decimal digits.\r\n     **/\r\n    function priceMax(string calldata symbol)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 price)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        uint256 ep;\r\n        uint256 p; //holder variables\r\n        price = 0;\r\n        if (config.ethOracles.length > 0) {\r\n            ep = 0;\r\n            for (uint256 i = 0; i < config.ethOracles.length; i++) {\r\n                p = IEthUsdOracle(config.ethOracles[i]).tokEthPrice(symbol);\r\n                if (ep < p) {\r\n                    ep = p;\r\n                }\r\n            }\r\n            price = ep;\r\n            ep = 0;\r\n            for (uint256 i = 0; i < ethUsdOracles.length; i++) {\r\n                p = IEthUsdOracle(ethUsdOracles[i]).ethUsdPrice();\r\n                if (ep < p) {\r\n                    ep = p;\r\n                }\r\n            }\r\n            if (price != 0 && ep != 0) {\r\n                // tokEthPrice has precision of 8 which ethUsdPrice has precision of 6\r\n                // we want precision of 8\r\n                price = (price * ep) / 1e6;\r\n            }\r\n        }\r\n\r\n        if (config.usdOracles.length > 0) {\r\n            for (uint256 i = 0; i < config.usdOracles.length; i++) {\r\n                // upscale by 2 since price oracles are precision 6\r\n                p = IPriceOracle(config.usdOracles[i]).price(symbol) * 1e2;\r\n                if (price < p) {\r\n                    price = p;\r\n                }\r\n            }\r\n        }\r\n\r\n        require(price <= maxDrift, \"Price exceeds maxDrift\");\r\n        require(price >= minDrift, \"Price below minDrift\");\r\n        require(price != 0, \"None of our oracles returned a valid max price!\");\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the length of the usdOracles array for a given token\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @return length of the USD oracles array\r\n     **/\r\n    function getTokenUSDOraclesLength(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        return config.usdOracles.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of a specific USD oracle\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @param idx Index of the array value to return\r\n     * @return address of the oracle\r\n     **/\r\n    function getTokenUSDOracle(string calldata symbol, uint256 idx)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        return config.usdOracles[idx];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the length of the ethOracles array for a given token\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @return length of the ETH oracles array\r\n     **/\r\n    function getTokenETHOraclesLength(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        return config.ethOracles.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of a specific ETH oracle\r\n     * @param symbol Asset symbol. Example: \"DAI\"\r\n     * @param idx Index of the array value to return\r\n     * @return address of the oracle\r\n     **/\r\n    function getTokenETHOracle(string calldata symbol, uint256 idx)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\r\n        return config.ethOracles[idx];\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPriceOracle {\r\n    /**\r\n     * @dev returns the asset price in USD, 6 decimal digits.\r\n     * Compatible with the Open Price Feed.\r\n     */\r\n    function price(string calldata symbol) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IEthUsdOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEthUsdOracle {\r\n    /**\r\n     * @notice Returns ETH price in USD.\r\n     * @return Price in USD with 6 decimal digits.\r\n     */\r\n    function ethUsdPrice() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns token price in USD.\r\n     * @param symbol. Asset symbol. For ex. \"DAI\".\r\n     * @return Price in USD with 6 decimal digits.\r\n     */\r\n    function tokUsdPrice(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the asset price in ETH.\r\n     * @param symbol. Asset symbol. For ex. \"DAI\".\r\n     * @return Price in ETH with 8 decimal digits.\r\n     */\r\n    function tokEthPrice(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IViewEthUsdOracle {\r\n    /**\r\n     * @notice Returns ETH price in USD.\r\n     * @return Price in USD with 6 decimal digits.\r\n     */\r\n    function ethUsdPrice() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns token price in USD.\r\n     * @param symbol. Asset symbol. For ex. \"DAI\".\r\n     * @return Price in USD with 6 decimal digits.\r\n     */\r\n    function tokUsdPrice(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the asset price in ETH.\r\n     * @param symbol. Asset symbol. For ex. \"DAI\".\r\n     * @return Price in ETH with 8 decimal digits.\r\n     */\r\n    function tokEthPrice(string calldata symbol)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IMinMaxOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMinMaxOracle {\r\n    //Assuming 8 decimals\r\n    function priceMin(string calldata symbol) external view returns (uint256);\r\n\r\n    function priceMax(string calldata symbol) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../interfaces/IMinMaxOracle.sol\";\r\n\r\n/**\r\n * Mock of both price Oracle and min max oracles\r\n */\r\ncontract MockOracle is IPriceOracle, IMinMaxOracle {\r\n    mapping(bytes32 => uint256) prices;\r\n    mapping(bytes32 => uint256[]) pricesMinMax;\r\n    uint256 ethMin;\r\n    uint256 ethMax;\r\n\r\n    /**\r\n     * @dev returns the asset price in USD, 6 decimal digits.\r\n     * Compatible with the Open Price Feed.\r\n     */\r\n    function price(string calldata symbol)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return prices[keccak256(abi.encodePacked(symbol))];\r\n    }\r\n\r\n    /**\r\n     * @dev sets the price of the asset in USD, 6 decimal digits\r\n     *\r\n     */\r\n    function setPrice(string calldata symbol, uint256 _price) external {\r\n        prices[keccak256(abi.encodePacked(symbol))] = _price;\r\n    }\r\n\r\n    /**\r\n     * @dev sets the min and max price of ETH in USD, 6 decimal digits\r\n     *\r\n     */\r\n    function setEthPriceMinMax(uint256 _min, uint256 _max) external {\r\n        ethMin = _min;\r\n        ethMax = _max;\r\n    }\r\n\r\n    /**\r\n     * @dev sets the prices Min Max for a specific symbol in ETH, 8 decimal digits\r\n     *\r\n     */\r\n    function setTokPriceMinMax(\r\n        string calldata symbol,\r\n        uint256 _min,\r\n        uint256 _max\r\n    ) external {\r\n        pricesMinMax[keccak256(abi.encodePacked(symbol))] = [_min, _max];\r\n    }\r\n\r\n    /**\r\n     * @dev get the price of asset in ETH, 8 decimal digits.\r\n     */\r\n    function priceMin(string calldata symbol)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256[] storage pMinMax = pricesMinMax[\r\n            keccak256(abi.encodePacked(symbol))\r\n        ];\r\n        return (pMinMax[0] * ethMin) / 1e6;\r\n    }\r\n\r\n    /**\r\n     * @dev get the price of asset in USD, 8 decimal digits.\r\n     * Not needed for now\r\n     */\r\n    function priceMax(string calldata symbol)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256[] storage pMinMax = pricesMinMax[\r\n            keccak256(abi.encodePacked(symbol))\r\n        ];\r\n        return (pMinMax[1] * ethMax) / 1e6;\r\n    }\r\n}\r\n"
    },
    "contracts/token/WrappedCASH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { ERC4626 } from \"../../lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { Governable } from \"../governance/Governable.sol\";\r\nimport { Initializable } from \"../utils/Initializable.sol\";\r\nimport { CASH } from \"./CASH.sol\";\r\n\r\ncontract WrappedCASH is ERC4626, Governable, Initializable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor(\r\n        ERC20 underlying_,\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC20(name_, symbol_) ERC4626(underlying_) Governable() {}\r\n\r\n    /**\r\n     * @notice Enable CASH rebasing for this contract\r\n     */\r\n    function initialize() external onlyGovernor initializer {\r\n        CASH(address(asset())).rebaseOptIn();\r\n    }\r\n\r\n    function name() public view override returns (string memory) {\r\n        return \"Wrapped CASH\";\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return \"wCASH\";\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer token to governor. Intended for recovering tokens stuck in\r\n     *      contract, i.e. mistaken sends. Cannot transfer CASH\r\n     * @param asset_ Address for the asset\r\n     * @param amount_ Amount of the asset to transfer\r\n     */\r\n    function transferToken(address asset_, uint256 amount_)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        require(asset_ != address(asset()), \"Cannot collect CASH\");\r\n        IERC20(asset_).safeTransfer(governor(), amount_);\r\n    }\r\n}\r\n"
    },
    "lib/openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC4626 } from \"../../../../interfaces/IERC4626.sol\";\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\n// From Open Zeppelin draft PR commit:\r\n// fac43034dca85ff539db3fc8aa2a7084b843d454\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3171\r\n\r\nabstract contract ERC4626 is ERC20, IERC4626 {\r\n    IERC20Metadata private immutable _asset;\r\n\r\n    constructor(IERC20Metadata __asset) {\r\n        _asset = __asset;\r\n    }\r\n\r\n    /** @dev See {IERC4262-asset} */\r\n    function asset() public view virtual override returns (address) {\r\n        return address(_asset);\r\n    }\r\n\r\n    /** @dev See {IERC4262-totalAssets} */\r\n    function totalAssets() public view virtual override returns (uint256) {\r\n        return _asset.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC4262-convertToShares}\r\n     *\r\n     * Will revert if asserts > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\r\n     * would represent an infinite amout of shares.\r\n     */\r\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\r\n        uint256 supply = totalSupply();\r\n\r\n        return\r\n            (assets == 0 || supply == 0)\r\n                ? (assets * 10**decimals()) / 10**_asset.decimals()\r\n                : (assets * supply) / totalAssets();\r\n    }\r\n\r\n    /** @dev See {IERC4262-convertToAssets} */\r\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\r\n        uint256 supply = totalSupply();\r\n\r\n        return (supply == 0) ? (shares * 10**_asset.decimals()) / 10**decimals() : (shares * totalAssets()) / supply;\r\n    }\r\n\r\n    /** @dev See {IERC4262-maxDeposit} */\r\n    function maxDeposit(address) public view virtual override returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    /** @dev See {IERC4262-maxMint} */\r\n    function maxMint(address) public view virtual override returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    /** @dev See {IERC4262-maxWithdraw} */\r\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\r\n        return convertToAssets(balanceOf(owner));\r\n    }\r\n\r\n    /** @dev See {IERC4262-maxRedeem} */\r\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\r\n        return balanceOf(owner);\r\n    }\r\n\r\n    /** @dev See {IERC4262-previewDeposit} */\r\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\r\n        return convertToShares(assets);\r\n    }\r\n\r\n    /** @dev See {IERC4262-previewMint} */\r\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\r\n        uint256 assets = convertToAssets(shares);\r\n        return assets + (convertToShares(assets) < shares ? 1 : 0);\r\n    }\r\n\r\n    /** @dev See {IERC4262-previewWithdraw} */\r\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\r\n        uint256 shares = convertToShares(assets);\r\n        return shares + (convertToAssets(shares) < assets ? 1 : 0);\r\n    }\r\n\r\n    /** @dev See {IERC4262-previewRedeem} */\r\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\r\n        return convertToAssets(shares);\r\n    }\r\n\r\n    /** @dev See {IERC4262-deposit} */\r\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\r\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more then max\");\r\n\r\n        address caller = _msgSender();\r\n        uint256 shares = previewDeposit(assets);\r\n\r\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\r\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\r\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(caller, receiver, assets, shares);\r\n\r\n        return shares;\r\n    }\r\n\r\n    /** @dev See {IERC4262-mint} */\r\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\r\n        require(shares <= maxMint(receiver), \"ERC4626: mint more then max\");\r\n\r\n        address caller = _msgSender();\r\n        uint256 assets = previewMint(shares);\r\n\r\n        // if _asset is ERC777, transferFrom can call reenter BEFORE the transfer happens through\r\n        // the tokensToSend hook, so we need to transfer before we mint to keep the invariants.\r\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(caller, receiver, assets, shares);\r\n\r\n        return assets;\r\n    }\r\n\r\n    /** @dev See {IERC4262-withdraw} */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual override returns (uint256) {\r\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more then max\");\r\n\r\n        address caller = _msgSender();\r\n        uint256 shares = previewWithdraw(assets);\r\n\r\n        if (caller != owner) {\r\n            _spendAllowance(owner, caller, shares);\r\n        }\r\n\r\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\r\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\r\n        _burn(owner, shares);\r\n        SafeERC20.safeTransfer(_asset, receiver, assets);\r\n\r\n        emit Withdraw(caller, receiver, owner, assets, shares);\r\n\r\n        return shares;\r\n    }\r\n\r\n    /** @dev See {IERC4262-redeem} */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual override returns (uint256) {\r\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more then max\");\r\n\r\n        address caller = _msgSender();\r\n        uint256 assets = previewRedeem(shares);\r\n\r\n        if (caller != owner) {\r\n            _spendAllowance(owner, caller, shares);\r\n        }\r\n\r\n        // if _asset is ERC777, transfer can call reenter AFTER the transfer happens through\r\n        // the tokensReceived hook, so we need to transfer after we burn to keep the invariants.\r\n        _burn(owner, shares);\r\n        SafeERC20.safeTransfer(_asset, receiver, assets);\r\n\r\n        emit Withdraw(caller, receiver, owner, assets, shares);\r\n\r\n        return assets;\r\n    }\r\n\r\n    // Included here, since this method was not yet present in\r\n    // the version of Open Zeppelin ERC20 code we use.\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n}"
    },
    "lib/openzeppelin/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed caller,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\r\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\r\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 assets);\r\n}"
    },
    "contracts/governance/InitializableGovernable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH InitializableGovernable Contract\r\n * @author Stabl Protocol Inc\r\n */\r\nimport { Initializable } from \"../utils/Initializable.sol\";\r\n\r\nimport { Governable } from \"./Governable.sol\";\r\n\r\ncontract InitializableGovernable is Governable, Initializable {\r\n    function _initialize(address _newGovernor) internal {\r\n        _changeGovernor(_newGovernor);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockLimitedWrappedCASH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { WrappedCASH } from \"../token/WrappedCASH.sol\";\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockLimitedWrappedCASH is WrappedCASH {\r\n    constructor(\r\n        ERC20 underlying_,\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) WrappedCASH(underlying_, name_, symbol_) {}\r\n\r\n    function maxDeposit(address)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return 1e18;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport { MintableERC20 } from \"./MintableERC20.sol\";\r\nimport { IAaveLendingPool, ILendingPoolAddressesProvider } from \"../strategies/IAave.sol\";\r\nimport { StableMath } from \"../utils/StableMath.sol\";\r\n\r\n// 1. User calls 'getLendingPool'\r\n// 2. User calls 'deposit' (Aave)\r\n//  - Deposit their underlying\r\n//  - Mint aToken to them\r\n// 3. User calls redeem (aToken)\r\n//  - Retrieve their aToken\r\n//  - Return equal amount of underlying\r\n\r\ncontract MockAToken is MintableERC20 {\r\n    address public lendingPool;\r\n    IERC20 public underlyingToken;\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor(\r\n        address _lendingPool,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        IERC20 _underlyingToken\r\n    ) ERC20(_name, _symbol) {\r\n        lendingPool = _lendingPool;\r\n        underlyingToken = _underlyingToken;\r\n        // addMinter(_lendingPool);\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return ERC20(address(underlyingToken)).decimals();\r\n    }\r\n\r\n    function poolRedeem(uint256 _amount, address _to) external {\r\n        require(msg.sender == lendingPool, \"pool only\");\r\n        // Redeem these a Tokens\r\n        _burn(_to, _amount);\r\n        // For the underlying\r\n        underlyingToken.safeTransferFrom(lendingPool, _to, _amount);\r\n    }\r\n}\r\n\r\ncontract MockAave is IAaveLendingPool, ILendingPoolAddressesProvider {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    mapping(address => address) reserveToAToken;\r\n    address pool = address(this);\r\n    address payable core = payable(address(this));\r\n    uint256 factor;\r\n\r\n    function addAToken(address _aToken, address _underlying) public {\r\n        IERC20(_underlying).safeApprove(_aToken, 0);\r\n        IERC20(_underlying).safeApprove(_aToken, type(uint256).max);\r\n        reserveToAToken[_underlying] = _aToken;\r\n    }\r\n\r\n    // set the reserve factor / basically the interest on deposit\r\n    // in 18 precision\r\n    // so 0.5% would be 5 * 10 ^ 15\r\n    function setFactor(uint256 factor_) public {\r\n        factor = factor_;\r\n    }\r\n\r\n    function deposit(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        address _to,\r\n        uint16 /*_referralCode*/\r\n    ) external override {\r\n        uint256 previousBal = IERC20(reserveToAToken[_reserve]).balanceOf(\r\n            msg.sender\r\n        );\r\n        uint256 interest = previousBal.mulTruncate(factor);\r\n        MintableERC20(reserveToAToken[_reserve]).mintTo(msg.sender, interest);\r\n        // Take their reserve\r\n        IERC20(_reserve).safeTransferFrom(msg.sender, address(this), _amount);\r\n        // Credit them with aToken\r\n        MintableERC20(reserveToAToken[_reserve]).mintTo(_to, _amount);\r\n    }\r\n\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external override returns (uint256) {\r\n        MockAToken atoken = MockAToken(reserveToAToken[asset]);\r\n        atoken.poolRedeem(amount, to);\r\n        return amount;\r\n    }\r\n\r\n    function getLendingPool() external view override returns (address) {\r\n        return pool;\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/IAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for Aaves Lending Pool\r\n * Documentation: https://developers.aave.com/#lendingpool\r\n */\r\ninterface IAaveLendingPool {\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev Interface for Aaves Lending Pool\r\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\r\n */\r\ninterface ILendingPoolAddressesProvider {\r\n    /**\r\n     * @notice Get the current address for Aave LendingPool\r\n     * @dev Lending pool is the core contract on which to call deposit\r\n     */\r\n    function getLendingPool() external view returns (address);\r\n}\r\n"
    },
    "contracts/mocks/curve/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport { ICurveGauge } from \"../../strategies/ICurveGauge.sol\";\r\n\r\ncontract MockCurveGauge is ICurveGauge {\r\n    mapping(address => uint256) private _balances;\r\n    address lpToken;\r\n\r\n    constructor(address _lpToken) {\r\n        lpToken = _lpToken;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function deposit(uint256 _value, address _account) external override {\r\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _value);\r\n        _balances[_account] += _value;\r\n    }\r\n    function deposit(uint256 _value, address _account, bool claimRewards) external override {\r\n        // IERC20(lpToken).transferFrom(msg.sender, address(this), _value);\r\n        // _balances[_account] += _value;\r\n    }\r\n\r\n    function deposit(uint256 _value) external override {\r\n        // TBD\r\n    }\r\n\r\n    function withdraw(uint256 _value) external override {\r\n        IERC20(lpToken).transfer(msg.sender, _value);\r\n        _balances[msg.sender] -= _value;\r\n    }\r\n    function withdraw(uint256 _value, bool claimRewards) external override {\r\n        IERC20(lpToken).transfer(msg.sender, _value);\r\n        _balances[msg.sender] -= _value;\r\n        if(claimRewards) {\r\n            this.claim_rewards();\r\n        }\r\n    }\r\n    function withdraw(uint256 _value,address _user, bool claimRewards) external override {\r\n        // NN\r\n    }\r\n    function claim_rewards() external override {\r\n        // TBD\r\n    }\r\n    function claim_rewards(address account) external override {\r\n        // TBD\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/BurnableERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ninterface IBurnableERC20 {\r\n    function burn(uint256 value) external returns (bool);\r\n\r\n    function burnFrom(address account, uint256 value) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title BurnableERC20\r\n * @dev Exposes the burn function of ERC20 for tests\r\n */\r\nabstract contract BurnableERC20 is IBurnableERC20, ERC20 {\r\n    /**\r\n     * @dev Function to burn tokens\r\n     * @param value The amount of tokens to burn.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function burn(uint256 value) public virtual override returns (bool) {\r\n        _burn(msg.sender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to burn tokens from a specific account\r\n     * @param account The address with the tokens to burn.\r\n     * @param value The amount of tokens to burn.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function burnFrom(address account, uint256 value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _burn(account, value);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/curve/MockBooster.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { MockRewardPool } from \"./MockRewardPool.sol\";\r\n\r\nimport { IRewardStaking } from \"../../strategies/IRewardStaking.sol\";\r\nimport { IMintableERC20, MintableERC20, ERC20 } from \"../MintableERC20.sol\";\r\nimport { IBurnableERC20, BurnableERC20 } from \"../BurnableERC20.sol\";\r\n\r\ncontract MockDepositToken is MintableERC20 {\r\n    constructor() ERC20(\"DCVX\", \"CVX Deposit Token\") {}\r\n}\r\n\r\ncontract MockBooster {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct PoolInfo {\r\n        address lptoken;\r\n        address token;\r\n        address crvRewards;\r\n    }\r\n\r\n    address public minter; // this is CVx for the booster on live\r\n    address public crv; // Curve rewards token\r\n    address public cvx; // Convex rewards token\r\n    mapping(uint256 => PoolInfo) public poolInfo;\r\n\r\n    constructor(\r\n        address _rewardsMinter,\r\n        address _crv,\r\n        address _cvx\r\n    ) public {\r\n        minter = _rewardsMinter;\r\n        crv = _crv;\r\n        cvx = _cvx;\r\n    }\r\n\r\n    function setPool(uint256 pid, address _lpToken) external returns (bool) {\r\n        address token = address(new MockDepositToken());\r\n        address rewards = address(\r\n            new MockRewardPool(pid, token, crv, cvx, address(this))\r\n        );\r\n\r\n        poolInfo[pid] = PoolInfo({\r\n            lptoken: _lpToken,\r\n            token: token,\r\n            crvRewards: rewards\r\n        });\r\n    }\r\n\r\n    function deposit(\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        bool _stake\r\n    ) public returns (bool) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n\r\n        address lptoken = pool.lptoken;\r\n\r\n        // hold on to the lptokens\r\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        address token = pool.token;\r\n        if (_stake) {\r\n            //mint here and send to rewards on user behalf\r\n            IMintableERC20(token).mint(_amount);\r\n            address rewardContract = pool.crvRewards;\r\n            IERC20(token).safeApprove(rewardContract, 0);\r\n            IERC20(token).safeApprove(rewardContract, _amount);\r\n            IRewardStaking(rewardContract).stakeFor(msg.sender, _amount);\r\n        } else {\r\n            //add user balance directly\r\n            IMintableERC20(token).mint(_amount);\r\n            IERC20(token).transfer(msg.sender, _amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //deposit all lp tokens and stake\r\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\r\n        address lptoken = poolInfo[_pid].lptoken;\r\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\r\n        deposit(_pid, balance, _stake);\r\n        return true;\r\n    }\r\n\r\n    //withdraw lp tokens\r\n    function _withdraw(\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        address _from,\r\n        address _to\r\n    ) internal {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        address lptoken = pool.lptoken;\r\n        address token = pool.token;\r\n\r\n        //remove lp balance\r\n        IBurnableERC20(token).burnFrom(_from, _amount);\r\n\r\n        //return lp tokens\r\n        IERC20(lptoken).safeTransfer(_to, _amount);\r\n    }\r\n\r\n    //withdraw lp tokens\r\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\r\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    //withdraw all lp tokens\r\n    function withdrawAll(uint256 _pid) public returns (bool) {\r\n        address token = poolInfo[_pid].token;\r\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\r\n        withdraw(_pid, userBal);\r\n        return true;\r\n    }\r\n\r\n    //allow reward contracts to send here and withdraw to user\r\n    function withdrawTo(\r\n        uint256 _pid,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external returns (bool) {\r\n        address rewardContract = poolInfo[_pid].crvRewards;\r\n        require(msg.sender == rewardContract, \"!auth\");\r\n\r\n        _withdraw(_pid, _amount, msg.sender, _to);\r\n        return true;\r\n    }\r\n\r\n    //callback from reward contract when crv is received.\r\n    function rewardClaimed(\r\n        uint256 _pid,\r\n        address _address,\r\n        uint256 _amount\r\n    ) external returns (bool) {\r\n        address rewardContract = poolInfo[_pid].crvRewards;\r\n        require(msg.sender == rewardContract, \"!auth\");\r\n\r\n        //mint reward tokens\r\n        // and transfer it\r\n        IMintableERC20(minter).mint(_amount);\r\n        IERC20(minter).transfer(msg.sender, _amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/curve/MockRewardPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ninterface IDeposit {\r\n    function poolInfo(uint256)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address,\r\n            address,\r\n            address,\r\n            address,\r\n            bool\r\n        );\r\n\r\n    function rewardClaimed(\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external;\r\n\r\n    function withdrawTo(\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) external;\r\n}\r\n\r\ncontract MockRewardPool {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public pid;\r\n    address public stakingToken;\r\n    address public rewardTokenA;\r\n    address public rewardTokenB;\r\n    address public operator;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => uint256) public rewards;\r\n\r\n    constructor(\r\n        uint256 _pid,\r\n        address _stakingToken,\r\n        address _rewardTokenA,\r\n        address _rewardTokenB,\r\n        address _operator\r\n    ) public {\r\n        pid = _pid;\r\n        stakingToken = _stakingToken;\r\n        rewardTokenA = _rewardTokenA;\r\n        rewardTokenB = _rewardTokenB;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function stakeFor(address _for, uint256 _amount) public returns (bool) {\r\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\r\n\r\n        //give to _for\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        _balances[_for] = _balances[_for].add(_amount);\r\n\r\n        //take away from sender\r\n        IERC20(stakingToken).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawAndUnwrap(uint256 amount, bool claim)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n\r\n        //tell operator to withdraw from here directly to user\r\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\r\n\r\n        //get rewards too\r\n        if (claim) {\r\n            getReward(msg.sender, true);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function withdrawAllAndUnwrap(bool claim) external {\r\n        withdrawAndUnwrap(_balances[msg.sender], claim);\r\n    }\r\n\r\n    function getReward(address _account, bool _claimExtras)\r\n        public\r\n        returns (bool)\r\n    {\r\n        IMintableERC20(rewardTokenA).mint(2 * 1e18);\r\n        IERC20(rewardTokenA).transfer(_account, 2 * 1e18);\r\n\r\n        IMintableERC20(rewardTokenB).mint(3 * 1e18);\r\n        IERC20(rewardTokenB).transfer(_account, 3 * 1e18);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getReward() public returns (bool) {\r\n        getReward(msg.sender, true);\r\n    }\r\n}\r\n"
    },
    "contracts/harvest/Dripper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { Governable } from \"../governance/Governable.sol\";\r\nimport { IVault } from \"../interfaces/IVault.sol\";\r\n\r\n/**\r\n * @title CASH Dripper\r\n *\r\n * The dripper contract smooths out the yield from point-in-time yield events\r\n * and spreads the yield out over a configurable time period. This ensures a\r\n * continuous per block yield to makes users happy as their next rebase\r\n * amount is always moving up. Also, this makes historical day to day yields\r\n * smooth, rather than going from a near zero day, to a large APY day, then\r\n * back to a near zero day again.\r\n *\r\n *\r\n * Design notes\r\n * - USDT has a smaller resolution than the number of seconds\r\n * in a week, which can make per block payouts have a rounding error. However\r\n * the total effect is not large - cents per day, and this money is\r\n * not lost, just distributed in the future. While we could use a higher\r\n * decimal precision for the drip perBlock, we chose simpler code.\r\n * - By calculating the changing drip rates on collects only, harvests and yield\r\n * events don't have to call anything on this contract or pay any extra gas.\r\n * Collect() is already be paying for a single write, since it has to reset\r\n * the lastCollect time.\r\n * - By having a collectAndRebase method, and having our external systems call\r\n * that, the CASH vault does not need any changes, not even to know the address\r\n * of the dripper.\r\n * - A rejected design was to retro-calculate the drip rate on each collect,\r\n * based on the balance at the time of the collect. While this would have\r\n * required less state, and would also have made the contract respond more quickly\r\n * to new income, it would break the predictability that is this contract's entire\r\n * purpose. If we did this, the amount of fundsAvailable() would make sharp increases\r\n * when funds were deposited.\r\n * - When the dripper recalculates the rate, it targets spending the balance over\r\n * the duration. This means that every time that collect is is called, if no\r\n * new funds have been deposited the duration is being pushed back and the\r\n * rate decreases. This is expected, and ends up following a smoother but\r\n * longer curve the more collect() is called without incoming yield.\r\n *\r\n *\r\n * UPDATE: USDT changed to USDC\r\n */\r\n\r\ncontract Dripper is Governable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct Drip {\r\n        uint64 lastCollect; // overflows 262 billion years after the sun dies\r\n        uint192 perBlock; // drip rate per block\r\n    }\r\n\r\n    address immutable vault; // CASH vault\r\n    address immutable token; // token to drip out\r\n    uint256 public dripDuration; // in seconds\r\n    Drip public drip; // active drip parameters\r\n\r\n    constructor(address _vault, address _token) {\r\n        vault = _vault;\r\n        token = _token;\r\n    }\r\n\r\n    /// @notice How much funds have dripped out already and are currently\r\n    //   available to be sent to the vault.\r\n    /// @return The amount that would be sent if a collect was called\r\n    function availableFunds() external view returns (uint256) {\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n        return _availableFunds(balance, drip);\r\n    }\r\n\r\n    /// @notice Collect all dripped funds and send to vault.\r\n    ///  Recalculate new drip rate.\r\n    function collect() external {\r\n        _collect();\r\n    }\r\n\r\n    /// @notice Collect all dripped funds, send to vault, recalculate new drip\r\n    ///  rate, and rebase CASH.\r\n    function collectAndRebase() external {\r\n        _collect();\r\n        IVault(vault).rebase();\r\n    }\r\n\r\n    /// @dev Change the drip duration. Governor only.\r\n    /// @param _durationSeconds the number of seconds to drip out the entire\r\n    ///  balance over if no collects were called during that time.\r\n    function setDripDuration(uint256 _durationSeconds) external onlyGovernor {\r\n        require(_durationSeconds > 0, \"duration must be non-zero\");\r\n        dripDuration = uint192(_durationSeconds);\r\n        Dripper(this).collect(); // duration change take immediate effect\r\n    }\r\n\r\n    /// @dev Transfer out ERC20 tokens held by the contract. Governor only.\r\n    /// @param _asset ERC20 token address\r\n    /// @param _amount amount to transfer\r\n    function transferToken(address _asset, uint256 _amount)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        IERC20(_asset).safeTransfer(governor(), _amount);\r\n    }\r\n\r\n    /// @dev Calculate available funds by taking the lower of either the\r\n    ///  currently dripped out funds or the balance available.\r\n    ///  Uses passed in parameters to calculate with for gas savings.\r\n    /// @param _balance current balance in contract\r\n    /// @param _drip current drip parameters\r\n    function _availableFunds(uint256 _balance, Drip memory _drip)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 elapsed = block.timestamp - _drip.lastCollect;\r\n        uint256 allowed = (elapsed * _drip.perBlock);\r\n        return (allowed > _balance) ? _balance : allowed;\r\n    }\r\n\r\n    /// @dev Sends the currently dripped funds to be vault, and sets\r\n    ///  the new drip rate based on the new balance.\r\n    function _collect() internal {\r\n        // Calculate send\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n        uint256 amountToSend = _availableFunds(balance, drip);\r\n        uint256 remaining = balance - amountToSend;\r\n        // Calculate new drip perBlock\r\n        //   Gas savings by setting entire struct at one time\r\n        drip = Drip({\r\n            perBlock: uint192(remaining / dripDuration),\r\n            lastCollect: uint64(block.timestamp)\r\n        });\r\n        // Send funds\r\n        IERC20(token).safeTransfer(vault, amountToSend);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockEvilDAI.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\nimport { IVault } from \"../interfaces/IVault.sol\";\r\n\r\ncontract MockEvilDAI is MintableERC20 {\r\n    address host;\r\n    address realCoin;\r\n\r\n    constructor(address _host, address _realCoin) ERC20(\"DAI\", \"DAI\") {\r\n        host = _host;\r\n        realCoin = _realCoin;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public override returns (bool) {\r\n        // call mint again!\r\n        if (_amount != 69) {\r\n            IVault(host).mint(address(this), 69, 0);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/timelock/Timelock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CASH Timelock Contract\r\n * @author Stabl Protocol Inc\r\n */\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ninterface CapitalPausable {\r\n    function pauseCapital() external;\r\n\r\n    function unpauseCapital() external;\r\n}\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint256;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint256 indexed newDelay);\r\n    event CancelTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    event ExecuteTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    event QueueTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        string signature,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n\r\n    uint256 public constant GRACE_PERIOD = 3 days;\r\n    uint256 public constant MINIMUM_DELAY = 1 minutes;\r\n    uint256 public constant MAXIMUM_DELAY = 2 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint256 public delay;\r\n\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Admin.\r\n     */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Caller is not the admin\");\r\n        _;\r\n    }\r\n\r\n    constructor(address admin_, uint256 delay_) {\r\n        require(\r\n            delay_ >= MINIMUM_DELAY,\r\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\r\n        );\r\n        require(\r\n            delay_ <= MAXIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\r\n        );\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    function setDelay(uint256 delay_) public {\r\n        require(\r\n            msg.sender == address(this),\r\n            \"Timelock::setDelay: Call must come from Timelock.\"\r\n        );\r\n        require(\r\n            delay_ >= MINIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\r\n        );\r\n        require(\r\n            delay_ <= MAXIMUM_DELAY,\r\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\r\n        );\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(\r\n            msg.sender == pendingAdmin,\r\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\r\n        );\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public onlyAdmin {\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(\r\n        address target,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) internal returns (bytes32) {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::queueTransaction: Call must come from admin.\"\r\n        );\r\n        require(\r\n            eta >= getBlockTimestamp().add(delay),\r\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, signature, keccak256(data), eta)\r\n        );\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(\r\n        address target,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) internal {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::cancelTransaction: Call must come from admin.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, signature, keccak256(data), eta)\r\n        );\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, signature, data, eta);\r\n    }\r\n\r\n    function _getRevertMsg(bytes memory _returnData)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        // If the _res length is less than 68, then the transaction failed\r\n        // silently (without a revert message)\r\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\r\n\r\n        assembly {\r\n            // Slice the sighash.\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        return abi.decode(_returnData, (string));\r\n    }\r\n\r\n    function executeTransaction(\r\n        address target,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::executeTransaction: Call must come from admin.\"\r\n        );\r\n\r\n        bytes32 txHash = keccak256(\r\n            abi.encode(target, signature, keccak256(data), eta)\r\n        );\r\n        require(\r\n            queuedTransactions[txHash],\r\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\r\n        );\r\n        require(\r\n            getBlockTimestamp() >= eta,\r\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\r\n        );\r\n        require(\r\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\r\n            \"Timelock::executeTransaction: Transaction is stale.\"\r\n        );\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(\r\n                bytes4(keccak256(bytes(signature))),\r\n                data\r\n            );\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = target.call(callData);\r\n\r\n        if (!success) {\r\n            revert(_getRevertMsg(returnData));\r\n        }\r\n\r\n        emit ExecuteTransaction(txHash, target, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint256) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n\r\n    function pauseCapital(address target) external {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::pauseCapital: Call must come from admin.\"\r\n        );\r\n        CapitalPausable(target).pauseCapital();\r\n    }\r\n\r\n    function unpauseCapital(address target) external {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Timelock::unpauseCapital: Call must come from admin.\"\r\n        );\r\n        CapitalPausable(target).unpauseCapital();\r\n    }\r\n}\r\n"
    },
    "contracts/governance/Governor.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./../timelock/Timelock.sol\";\r\n\r\n// Modeled off of Compound's Governor Alpha\r\n//    https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\r\ncontract Governor is Timelock {\r\n    // @notice The total number of proposals\r\n    uint256 public proposalCount;\r\n\r\n    struct Proposal {\r\n        // @notice Unique id for looking up a proposal\r\n        uint256 id;\r\n        // @notice Creator of the proposal\r\n        address proposer;\r\n        // @notice The timestamp that the proposal will be available for\r\n        // execution, set once the vote succeeds\r\n        uint256 eta;\r\n        // @notice the ordered list of target addresses for calls to be made\r\n        address[] targets;\r\n        // @notice The ordered list of function signatures to be called\r\n        string[] signatures;\r\n        // @notice The ordered list of calldata to be passed to each call\r\n        bytes[] calldatas;\r\n        // @notice Flag marking whether the proposal has been executed\r\n        bool executed;\r\n    }\r\n\r\n    // @notice The official record of all proposals ever proposed\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    // @notice An event emitted when a new proposal is created\r\n    event ProposalCreated(\r\n        uint256 id,\r\n        address proposer,\r\n        address[] targets,\r\n        string[] signatures,\r\n        bytes[] calldatas,\r\n        string description\r\n    );\r\n\r\n    // @notice An event emitted when a proposal has been queued in the Timelock\r\n    event ProposalQueued(uint256 id, uint256 eta);\r\n\r\n    // @notice An event emitted when a proposal has been executed in the Timelock\r\n    event ProposalExecuted(uint256 id);\r\n\r\n    // @notice An event emitted when a proposal has been cancelled\r\n    event ProposalCancelled(uint256 id);\r\n\r\n    uint256 public constant MAX_OPERATIONS = 32;\r\n\r\n    // @notice Possible states that a proposal may be in\r\n    enum ProposalState {\r\n        Pending,\r\n        Queued,\r\n        Expired,\r\n        Executed\r\n    }\r\n\r\n    constructor(address admin_, uint256 delay_) Timelock(admin_, delay_) {}\r\n\r\n    /**\r\n     * @notice Propose Governance call(s)\r\n     * @param targets Ordered list of targeted addresses\r\n     * @param signatures Orderd list of function signatures to be called\r\n     * @param calldatas Orderded list of calldata to be passed with each call\r\n     * @param description Description of the governance\r\n     * @return uint256 id of the proposal\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        string[] memory signatures,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) public returns (uint256) {\r\n        // Allow anyone to propose for now, since only admin can queue the\r\n        // transaction it should be harmless, you just need to pay the gas\r\n        require(\r\n            targets.length == signatures.length &&\r\n                targets.length == calldatas.length,\r\n            \"Governor::propose: proposal function information arity mismatch\"\r\n        );\r\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\r\n        require(\r\n            targets.length <= MAX_OPERATIONS,\r\n            \"Governor::propose: too many actions\"\r\n        );\r\n\r\n        proposalCount++;\r\n        Proposal memory newProposal = Proposal({\r\n            id: proposalCount,\r\n            proposer: msg.sender,\r\n            eta: 0,\r\n            targets: targets,\r\n            signatures: signatures,\r\n            calldatas: calldatas,\r\n            executed: false\r\n        });\r\n\r\n        proposals[newProposal.id] = newProposal;\r\n\r\n        emit ProposalCreated(\r\n            newProposal.id,\r\n            msg.sender,\r\n            targets,\r\n            signatures,\r\n            calldatas,\r\n            description\r\n        );\r\n        return newProposal.id;\r\n    }\r\n\r\n    /**\r\n     * @notice Queue a proposal for execution\r\n     * @param proposalId id of the proposal to queue\r\n     */\r\n    function queue(uint256 proposalId) public onlyAdmin {\r\n        require(\r\n            state(proposalId) == ProposalState.Pending,\r\n            \"Governor::queue: proposal can only be queued if it is pending\"\r\n        );\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.eta = block.timestamp + delay;\r\n\r\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n            _queueOrRevert(\r\n                proposal.targets[i],\r\n                proposal.signatures[i],\r\n                proposal.calldatas[i],\r\n                proposal.eta\r\n            );\r\n        }\r\n\r\n        emit ProposalQueued(proposal.id, proposal.eta);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the state of a proposal\r\n     * @param proposalId id of the proposal\r\n     * @return ProposalState\r\n     */\r\n    function state(uint256 proposalId) public view returns (ProposalState) {\r\n        require(\r\n            proposalCount >= proposalId && proposalId > 0,\r\n            \"Governor::state: invalid proposal id\"\r\n        );\r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        } else if (proposal.eta == 0) {\r\n            return ProposalState.Pending;\r\n        } else if (block.timestamp >= proposal.eta + GRACE_PERIOD) {\r\n            return ProposalState.Expired;\r\n        } else {\r\n            return ProposalState.Queued;\r\n        }\r\n    }\r\n\r\n    function _queueOrRevert(\r\n        address target,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) internal {\r\n        require(\r\n            !queuedTransactions[\r\n                keccak256(abi.encode(target, signature, keccak256(data), eta))\r\n            ],\r\n            \"Governor::_queueOrRevert: proposal action already queued at eta\"\r\n        );\r\n        require(\r\n            queuedTransactions[queueTransaction(target, signature, data, eta)],\r\n            \"Governor::_queueOrRevert: failed to queue transaction\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a proposal.\r\n     * @param proposalId id of the proposal\r\n     */\r\n    function execute(uint256 proposalId) public {\r\n        require(\r\n            state(proposalId) == ProposalState.Queued,\r\n            \"Governor::execute: proposal can only be executed if it is queued\"\r\n        );\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.executed = true;\r\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n            executeTransaction(\r\n                proposal.targets[i],\r\n                proposal.signatures[i],\r\n                proposal.calldatas[i],\r\n                proposal.eta\r\n            );\r\n        }\r\n        emit ProposalExecuted(proposalId);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel a proposal.\r\n     * @param proposalId id of the proposal\r\n     */\r\n    function cancel(uint256 proposalId) public onlyAdmin {\r\n        ProposalState proposalState = state(proposalId);\r\n\r\n        require(\r\n            proposalState == ProposalState.Queued ||\r\n                proposalState == ProposalState.Pending,\r\n            \"Governor::execute: proposal can only be cancelled if it is queued or pending\"\r\n        );\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.eta = 1; // To mark the proposal as `Expired`\r\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n            cancelTransaction(\r\n                proposal.targets[i],\r\n                proposal.signatures[i],\r\n                proposal.calldatas[i],\r\n                proposal.eta\r\n            );\r\n        }\r\n        emit ProposalCancelled(proposalId);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the actions that a proposal will take.\r\n     * @param proposalId id of the proposal\r\n     */\r\n    function getActions(uint256 proposalId)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory targets,\r\n            string[] memory signatures,\r\n            bytes[] memory calldatas\r\n        )\r\n    {\r\n        Proposal storage p = proposals[proposalId];\r\n        return (p.targets, p.signatures, p.calldatas);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockMintableUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\nimport \"./MockUniswapPair.sol\";\r\n\r\ncontract MockMintableUniswapPair is MockUniswapPair, MintableERC20 {\r\n    constructor(\r\n        address _token0,\r\n        address _token1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1\r\n    )\r\n        MockUniswapPair(_token0, _token1, _reserve0, _reserve1)\r\n        ERC20(\"Uniswap V2\", \"UNI-v2\")\r\n    {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IMockUniswapV2Pair } from \"../interfaces/uniswap/IMockUniswapV2Pair.sol\";\r\n\r\ncontract MockUniswapPair is IMockUniswapV2Pair {\r\n    address tok0;\r\n    address tok1;\r\n    uint112 reserve0;\r\n    uint112 reserve1;\r\n    uint256 blockTimestampLast;\r\n\r\n    bool public hasSynced = false;\r\n\r\n    constructor(\r\n        address _token0,\r\n        address _token1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1\r\n    ) {\r\n        tok0 = _token0;\r\n        tok1 = _token1;\r\n        reserve0 = _reserve0;\r\n        reserve1 = _reserve1;\r\n        blockTimestampLast = block.timestamp;\r\n    }\r\n\r\n    function token0() external view override returns (address) {\r\n        return tok0;\r\n    }\r\n\r\n    function token1() external view override returns (address) {\r\n        return tok1;\r\n    }\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        )\r\n    {\r\n        return (reserve0, reserve1, uint32(blockTimestampLast));\r\n    }\r\n\r\n    function setReserves(uint112 _reserve0, uint112 _reserve1) public {\r\n        reserve0 = _reserve0;\r\n        reserve1 = _reserve1;\r\n        blockTimestampLast = block.timestamp;\r\n    }\r\n\r\n    // CAUTION This will not work if you setReserves multiple times over\r\n    // multiple different blocks because then it wouldn't be a continuous\r\n    // reserve factor over that blockTimestamp, this assumes an even reserve\r\n    // ratio all the way through\r\n    function price0CumulativeLast() external view override returns (uint256) {\r\n        return\r\n            uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\r\n            blockTimestampLast;\r\n    }\r\n\r\n    function price1CumulativeLast() external view override returns (uint256) {\r\n        return\r\n            uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\r\n            blockTimestampLast;\r\n    }\r\n\r\n    function sync() external override {\r\n        hasSynced = true;\r\n    }\r\n\r\n    function checkHasSynced() external view {\r\n        require(hasSynced, \"Not synced\");\r\n    }\r\n}\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << 112) / denominator);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/uniswap/IMockUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMockUniswapV2Pair {\r\n\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function sync() external;\r\n\r\n}"
    },
    "contracts/mocks/MockMeshToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockMeshToken is MintableERC20 {\r\n    constructor() ERC20(\"MeshToken\", \"MeshToken\") {}\r\n}\r\n"
    },
    "contracts/mocks/MockMeshSwapUniPoolLP.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockMeshSwapUniPoolLP is MintableERC20 {\r\n    constructor() ERC20(\"MockMeshSwapUniPoolLP\", \"MockMeshSwapUniPoolLP\") {}\r\n    function depositToken(uint256 _amount) external {\r\n        \r\n    }\r\n    function withdrawToken(uint256 _amount) external {\r\n        \r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockDAI.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockDAI is MintableERC20 {\r\n    constructor() ERC20(\"DAI\", \"DAI\") {}\r\n}\r\n"
    },
    "contracts/mocks/MockAAVEToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockAAVEToken is MintableERC20 {\r\n    constructor() ERC20(\"AAVE\", \"AAVE\") {}\r\n}\r\n"
    },
    "contracts/mocks/MockStkAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./MintableERC20.sol\";\r\n\r\ncontract MockStkAave is MintableERC20 {\r\n    uint256 public COOLDOWN_SECONDS = 864000;\r\n    uint256 public UNSTAKE_WINDOW = 172800;\r\n    address public STAKED_TOKEN;\r\n\r\n    mapping(address => uint256) public stakerRewardsToClaim;\r\n    mapping(address => uint256) public stakersCooldowns;\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor(address _stakedToken) ERC20(\"Staked Aave\", \"stkAAVE\") {\r\n        STAKED_TOKEN = _stakedToken;\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function setStakedToken(address _stakedToken) external {\r\n        STAKED_TOKEN = _stakedToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Redeems staked tokens, and stop earning rewards\r\n     * @param to Address to redeem to\r\n     * @param amount Amount to redeem\r\n     **/\r\n    function redeem(address to, uint256 amount) external {\r\n        uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\r\n        uint256 windowStart = cooldownStartTimestamp + COOLDOWN_SECONDS;\r\n        require(amount != 0, \"INVALID_ZERO_AMOUNT\");\r\n        require(block.timestamp > windowStart, \"INSUFFICIENT_COOLDOWN\");\r\n        require(\r\n            block.timestamp - windowStart <= UNSTAKE_WINDOW,\r\n            \"UNSTAKE_WINDOW_FINISHED\"\r\n        );\r\n        uint256 balanceOfMessageSender = balanceOf(msg.sender);\r\n        uint256 amountToRedeem = (amount > balanceOfMessageSender)\r\n            ? balanceOfMessageSender\r\n            : amount;\r\n\r\n        stakersCooldowns[msg.sender] = 0;\r\n        _burn(msg.sender, amountToRedeem);\r\n        IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);\r\n    }\r\n\r\n    /**\r\n     * @dev Activates the cooldown period to unstake\r\n     * - It can't be called if the user is not staking\r\n     **/\r\n    function cooldown() external {\r\n        require(balanceOf(msg.sender) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\r\n        stakersCooldowns[msg.sender] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Test helper function to allow changing the cooldown\r\n     **/\r\n    function setCooldown(address account, uint256 _cooldown) external {\r\n        stakersCooldowns[account] = _cooldown;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { MockStkAave } from \"./MockStkAave.sol\";\r\n\r\ncontract MockAaveIncentivesController {\r\n    mapping(address => uint256) private rewards;\r\n    MockStkAave public REWARD_TOKEN;\r\n\r\n    constructor(address _reward_token) {\r\n        REWARD_TOKEN = MockStkAave(_reward_token);\r\n    }\r\n\r\n    function setRewardsBalance(address user, uint256 amount) external {\r\n        rewards[user] = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n     * @param user The address of the user\r\n     * @return The rewards\r\n     **/\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rewards[user];\r\n    }\r\n\r\n    /**\r\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256) {\r\n        require(amount > 0);\r\n        require(rewards[to] == amount);\r\n        REWARD_TOKEN.mint(amount);\r\n        require(REWARD_TOKEN.transfer(to, amount));\r\n        rewards[to] = 0;\r\n        return amount;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/curve/MockCVX.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../MintableERC20.sol\";\r\n\r\ncontract MockCVX is MintableERC20 {\r\n    constructor() ERC20(\"CVX\", \"CVX DAO Token\") {}\r\n}\r\n"
    },
    "contracts/mocks/curve/MockCRVMinter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\r\n\r\ncontract MockCRVMinter {\r\n    address crv;\r\n\r\n    constructor(address _crv) {\r\n        crv = _crv;\r\n    }\r\n\r\n    function mint(address _address) external {\r\n        uint256 amount = 2e18;\r\n        IMintableERC20(crv).mint(amount);\r\n        IERC20(crv).transfer(_address, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/curve/MockCRV.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../MintableERC20.sol\";\r\n\r\ncontract MockCRV is MintableERC20 {\r\n    constructor() ERC20(\"Curve DAO Token\", \"CRV\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/curve/Mock3CRV.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../MintableERC20.sol\";\r\n\r\ncontract Mock3CRV is MintableERC20 {\r\n    constructor() ERC20(\"Curve.fi DAI/USDC/USDT\", \"3Crv\") {}\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function burnFrom(address from, uint256 value) public {\r\n        _burn(from, value);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}